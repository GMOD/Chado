-- these are nearly identical to the triggers that flybase uses, but will
-- serve as the foundation of general triggers for GMOD.  Things that need to
-- be done:
--
--* indentify the items that have to be dynamically (at make time) extrapolated.
--* allow a more flexible naming scheme
--* remove the portion creating a flybase dbxref.
--* probably 20 more things I haven't thought of yet.



--gets the next available uniquename; note that it is
--destructive because it calls nextval on a sequence 
CREATE OR REPLACE FUNCTION next_uniquename() RETURNS varchar AS $$

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    # Prefix of the name
    my $prefix = $get_single_value->(
        q[
        SELECT cp.value FROM cvtermprop cp, cvterm, cv
        WHERE cvterm.name = 'prefix' and
            cp.cvterm_id = cvterm.cvterm_id and
            cvterm.cv_id = cv.cv_id and
            cv.name = 'apollo';
    ],
        'value'
    );

    # Suffix of the name
    my $suffix = $get_single_value->(
        q[
        SELECT cp.value FROM cvtermprop cp, cvterm, cv
        WHERE cvterm.name = 'suffix' and
            cp.cvterm_id = cvterm.cvterm_id and
            cvterm.cv_id = cv.cv_id and
            cv.name = 'apollo';
    ],
        'value'
    );

    my $max_id = $get_single_value->(
        q[ SELECT nextval('uniquename_id_generator') as nextval ], 'nextval',
    );
    $max_id = sprintf( "%06d", $max_id );

    return $prefix . $max_id . $suffix;

END;
$$ LANGUAGE plperl;

DROP TRIGGER tr_feature_del  ON feature;

CREATE OR REPLACE function fn_feature_del() RETURNS TRIGGER AS $$

    my $f_type_gene                 = q[gene];
    my $f_type_exon                 = q[exon];
    my $f_type_transcript           = q[mRNA];
    my $f_type_snoRNA               = q[snoRNA];
    my $f_type_ncRNA                = q[ncRNA];
    my $f_type_snRNA                = q[snRNA];
    my $f_type_tRNA                 = q[tRNA];
    my $f_type_rRNA                 = q[rRNA];
    my $f_type_promoter             = q[promoter];
    my $f_type_repeat_region        = q[repeat_region];
    my $f_type_miRNA                = q[miRNA];
    my $f_type_transposable_element = q[transposable_element];
    my $f_type_pseudo               = q[pseudogene];
    my $f_type_protein              = q[polypeptide];
    my $f_type_allele               = q[alleleof];

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    #RAISE NOTICE ''enter f_d, feature uniquename:%,
    #type_id:%'',$_TD->{old}{'uniquename'}, $_TD->{old}{'type_id'};

    my $f_return = $_TD->{old}{'feature_id'};

    my $f_type = $get_single_value->(
        q[
        SELECT c.name from feature f, cvterm c where f.feature_id=]
            . $_TD->{old}{'feature_id'} 
            . q[ and f.type_id=c.cvterm_id], 'name'
    );

    if ( $f_type eq $f_type_gene ) {
        my $f_id_allele = $get_single_value->(
            q[
            SELECT fr.subject_id 
            from  feature_relationship fr, cvterm c 
            where  (fr.object_id=]
                . $_TD->{old}{'feature_id'}
                . q[ or fr.subject_id=]
                . $_TD->{old}{'feature_id'}
                . q[)  and fr.type_id=c.cvterm_id and c.name=']
                . $f_type_allele . q['],
            'subject_id'
        );

        if ( not $f_id_allele ) {
            my $sql_str
                = q[SELECT * from feature_relationship fr where fr.object_id=]
                . $_TD->{old}{'feature_id'};
            my $rv = spi_exec_query($sql_str);
            foreach my $fr_row ( @{ $rv->{q[rows]} || [] } ) {

                my $f_id_transcript = $get_single_value->(
                    q[
                SELECT f.feature_id 
                from feature f, 
                cvterm c 
                where f.feature_id=] . $fr_row->{q[subject_id]} . q[ 
                and f.type_id=c.cvterm_id 
                and (c.name=']
                        . $f_type_transcript
                        . q[' or c.name=']
                        . $f_type_ncRNA
                        . q[' or c.name=']
                        . $f_type_snoRNA
                        . q[' or c.name=']
                        . $f_type_snRNA
                        . q[' or c.name=']
                        . $f_type_tRNA
                        . q['  or c.name=']
                        . $f_type_rRNA
                        . q['  or c.name=']
                        . $f_type_pseudo
                        . q['  or c.name=']
                        . $f_type_miRNA
                        . q[' or c.name=']
                        . $f_type_transposable_element
                        . q[' or c.name=']
                        . $f_type_promoter
                        . q[' or c.name=']
                        . $f_type_repeat_region . q[')],
                    'feature_id'
                );
                my $f_id_gene = $get_single_value->(
                    q[
                SELECT f.feature_id 
                from feature f, feature_relationship fr, cvterm c 
                where f.feature_id=fr.object_id and fr.subject_id=]
                        . $f_id_transcript
                        . q[ and f.type_id=c.cvterm_id and c.name=']
                        . $f_type_gene
                        . q[' and f.feature_id !=]
                        . $_TD->{old}{'feature_id'} . q[],
                    'feature_id'
                );
                if ( defined($f_id_transcript) and not defined($f_id_gene) ) {

                    # RAISE NOTICE ''delete lonely transcript:%'',
                    # $f_id_transcript;
                    my $message
                        = "delete lonely transcript $f_id_transcript ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_transcript);"
                    );

                    my $sql_str
                        = "delete from feature where feature_id=$f_id_transcript;";
                    spi_exec_query($sql_str);
                }
                elsif ( defined($f_id_gene) and defined($f_id_transcript) ) {

                    # RAISE NOTICE ''There is another gene:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_gene,
                    # $f_id_transcript;
                    my $message = "There is another gene: $f_id_gene "
                        . "associated with this transcript: $f_id_transcript";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', 'feature', $f_id_transcript);"
                    );
                }
            }
            my $message = "delete gene: " . $_TD->{old}{'feature_id'} . " ";
            spi_exec_query( "insert into trigger_log(value, table_name, id)"
                    . " values('$message', 'feature', $_TD->{old}{'feature_id'});"
            );
        }
        else {

            #RAISE NOTICE ''there is other allele associated with this
            #gene:%'', f_id_allele;
            my $message
                = "There is other allele associated with this gene: $f_id_allele ";
            spi_exec_query( "insert into trigger_log(value, table_name, id)"
                    . " values('$message', 'feature', $f_id_allele);" );
            return;
        }
    }
    elsif ($f_type eq $f_type_transcript
        or $f_type eq $f_type_ncRNA
        or $f_type eq $f_type_snoRNA
        or $f_type eq $f_type_snRNA
        or $f_type eq $f_type_tRNA
        or $f_type eq $f_type_rRNA
        or $f_type eq $f_type_pseudo
        or $f_type eq $f_type_miRNA
        or $f_type eq $f_type_transposable_element
        or $f_type eq $f_type_promoter
        or $f_type eq $f_type_repeat_region )
    {

        my $sql_str
            = q[SELECT * from feature_relationship fr where fr.object_id=]
            . $_TD->{old}{'feature_id'};
        my $rv = spi_exec_query($sql_str);
        foreach my $fr_row ( @{ $rv->{q[rows]} || [] } ) {

            # Handle Exons
            my $f_id_exon = $get_single_value->(
                q[SELECT f.feature_id from feature f, cvterm c where f.feature_id=]
                    . $fr_row->{q[subject_id]}
                    . qq[ and f.type_id=c.cvterm_id and c.name='$f_type_exon'],
                'feature_id'
            );
            if ($f_id_exon) {
                my $f_id_exon_transcript = $get_single_value->(
                    q[
                        SELECT f.feature_id 
                        from feature f, feature_relationship fr, cvterm c 
                        where f.feature_id=fr.object_id ]
                        . "and fr.subject_id=$f_id_exon "
                        . "and f.type_id=c.cvterm_id "
                        . "and (c.name='$f_type_transcript'"
                        . " or c.name='$f_type_ncRNA'"
                        . " or c.name='$f_type_snoRNA'"
                        . " or c.name='$f_type_snRNA'"
                        . " or c.name='$f_type_tRNA' "
                        . " or c.name='$f_type_rRNA' "
                        . " or c.name='$f_type_pseudo' "
                        . " or c.name='$f_type_miRNA'"
                        . " or c.name='$f_type_transposable_element'"
                        . " or c.name='$f_type_promoter'"
                        . " or c.name='$f_type_repeat_region') "
                        . "and f.feature_id!="
                        . $_TD->{old}{'feature_id'}, 'feature_id'
                );

                if ( not defined($f_id_exon_transcript)
                    and defined($f_id_exon) )
                {

                    # RAISE NOTICE ''delete lonely exon:%'',
                    # $f_id_exon;
                    my $message = "delete lonely exon $f_id_exon ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_exon);" );
                    spi_exec_query(
                        "delete from feature where feature_id=$f_id_exon;");
                }
                elsif ( defined($f_id_exon)
                    and defined($f_id_exon_transcript) )
                {

                    # RAISE NOTICE ''There is another exon:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_exon,
                    # $f_id_exon_transcript;
                    my $message = "There is another exon: $f_id_exon "
                        . "associated with this transcript: $f_id_exon)";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', ' feature', $f_id_exon);"
                    );
                }
            }

            # Handle Protein
            my $f_id_protein = $get_single_value->(
                q[SELECT f.feature_id from feature f, cvterm c where f.feature_id=]
                    . $fr_row->{q[subject_id]}
                    . qq[ and f.type_id=c.cvterm_id and c.name='$f_type_protein'],
                'feature_id'
            );
            if ($f_id_protein) {
                my $f_id_protein_transcript = $get_single_value->(
                    q[
            SELECT f.feature_id 
            from feature f, feature_relationship fr, cvterm c 
            where f.feature_id=fr.object_id ]
                        . qq[ and fr.subject_id='$f_id_protein' ]
                        . qq[ and f.type_id=c.cvterm_id ]
                        . qq[ and (c.name='$f_type_transcript' ]
                        . qq[ or c.name='$f_type_ncRNA' ]
                        . qq[ or c.name='$f_type_snoRNA' ]
                        . qq[ or c.name='$f_type_snRNA' ]
                        . qq[ or c.name='$f_type_tRNA'  ]
                        . qq[ or c.name='$f_type_rRNA'   ]
                        . qq[ or c.name='$f_type_pseudo' ]
                        . qq[ or c.name='$f_type_miRNA' ]
                        . qq[ or c.name='$f_type_transposable_element' ]
                        . qq[ or c.name='$f_type_promoter' ]
                        . qq[ or c.name='$f_type_repeat_region') ]
                        . qq[ and f.feature_id !=]
                        . $_TD->{old}{'feature_id'} . q[],
                    'feature_id'
                );
                if ( not defined($f_id_protein_transcript)
                    and defined($f_id_protein) )
                {

                    # RAISE NOTICE ''delete lonely protein:%'',
                    # $f_id_protein;
                    my $message = "delete lonely protein $f_id_protein ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_protein);"
                    );
                    spi_exec_query(
                        "delete from feature where feature_id=$f_id_protein;"
                    );
                }
                elsif ( defined($f_id_protein)
                    and defined($f_id_protein_transcript) )
                {

                    # RAISE NOTICE ''There is another protein:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_protein,
                    # $f_id_protein_transcript;
                    my $message
                        = "There is another protein: $f_id_protein "
                        . "associated with this transcript: $f_id_protein_transcript,"
                        . " so this exon will be kept";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', ' feature', $f_id_protein);"
                    );
                }
            }
        }
    }

    #RAISE NOTICE ''leave f_d ....'';
    return;
END;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION fn_feature_del() TO PUBLIC;

CREATE TRIGGER tr_feature_del BEFORE DELETE ON feature for EACH ROW EXECUTE PROCEDURE fn_feature_del();

DROP TRIGGER feature_assignname_tr_i ON feature;

CREATE OR REPLACE FUNCTION feature_assignname_fn_i() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncrna                = 'ncrna';
    my $f_type_snrna                = 'snrna';
    my $f_type_trna                 = 'trna';
    my $f_type_rrna                 = 'rrna';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_mirna                = 'mirna';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';
    my $f_type_remark               = 'remark';
    my $c_name_synonym              = 'synonym';
    my $cv_cvname_synonym           = 'null';
    my $p_miniref                   = 'none';

    my $f_name;

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    my $is_anal = $get_single_value->(
        q[SELECT is_analysis FROM feature WHERE uniquename =']
            . $_TD->{new}{'uniquename'}
            . q[' and type_id =]
            . $_TD->{new}{'type_id'}
            . q[ and organism_id =]
            . $_TD->{new}{'organism_id'} . q[],
        'is_analysis'
    );
    if ($is_anal) {
        return;
    }

    my $prefix = $get_single_value->(
        q[
    SELECT cp.value 
    FROM cvtermprop cp, cvterm, cv 
    WHERE cvterm.name = 'prefix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'
    ],
        'value'
    );
    my $suffix = $get_single_value->(
        q[
    SELECT cp.value 
    FROM cvtermprop cp, cvterm, cv 
    WHERE cvterm.name = 'suffix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'
    ], 'value'
    );
    my $f_type = $get_single_value->(
        q[
        SELECT c.name 
        from feature f, cvterm c 
        where f.type_id=c.cvterm_id and f.uniquename=']
            . $_TD->{new}{'uniquename'}
            . q[' and f.organism_id =]
            . $_TD->{new}{'organism_id'} . q[],
        'name'
    );
    my $p_id = $get_single_value->(
        qq[SELECT pub_id from pub where uniquename = '$p_miniref'], 'pub_id'
    );
    my $s_type_id = $get_single_value->(
        qq[
        SELECT cvterm_id 
        from cvterm c1, cv c2 
        where c1.name='$c_name_synonym' 
        and c2.name='$cv_cvname_synonym' 
        and c1.cv_id=c2.cv_id],
        'cvterm_id'
    );

    # RAISE NOTICE ''assigning names, prefix:%, suffix:%, type:%,
    # current uniquename:%'',prefix,suffix,f_type,$_TD->{new}{'uniquename'};

    if (   $_TD->{new}{'uniquename'} =~ /$prefix.*temp.*$suffix/
        or $_TD->{new}{'uniquename'} =~ /$prefix.*-temp/ )
    {

        $f_type = $get_single_value->(
            q[
            SELECT c.name 
            from feature f, cvterm c 
            where f.type_id=c.cvterm_id and f.uniquename=']
                . $_TD->{new}{'uniquename'}
                . q[' and f.organism_id =]
                . $_TD->{new}{'organism_id'} . q[],
            'name'
        );

        # my $p_id = $get_single_value->( q[SELECT pub_id from pub
        # where uniquename = $p_miniref],'pub_id');#LOOK AT
        # my $s_type_id = $get_single_value->( q[
        #   SELECT cvterm_id
        #   from cvterm c1, cv c2
        #   where c1.name=$c_name_synonym and c2.name=$cv_cvname_synonym
        #   and c1.cv_id=c2.cv_id],'cvterm_id');#LOOK AT

        my $f_uniquename = $get_single_value->(
            q[SELECT next_uniquename FROM next_uniquename()],
            'next_uniquename'
        );

        my $f_row_g = $get_single_row->(
                  q[SELECT * from feature where uniquename=']
                . $_TD->{new}{'uniquename'}
                . q[' and organism_id=]
                . $_TD->{new}{'organism_id'} . q[],
        );

        if ( $f_type eq $f_type_gene ) {

            if ( $_TD->{new}{'name'} =~ /temp/
                or not defined( $_TD->{new}{'name'} ) )
            {
                $f_name = $f_uniquename;
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_uniquename' ]
                        . qq[where feature_id=] . $f_row_g->{'feature_id'}
                );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename' where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }
        }
        elsif ($f_type eq $f_type_transcript
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_protein
            or $f_type eq $f_type_exon )
        {

            if (not defined(
                           $_TD->{new}{'name'}
                        or $_TD->{new}{'name'} =~ /temp/
                )
                )
            {
                spi_exec_query(
                          qq[UPDATE feature set uniquename='$f_uniquename',]
                        . qq[name=NULL where feature_id=]
                        . $f_row_g->{'feature_id'} );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                          qq[UPDATE feature set uniquename='$f_uniquename',]
                        . qq[name='$f_name' where feature_id=]
                        . $f_row_g->{'feature_id'} );
            }
        }
        elsif ($f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region
            or $f_type eq $f_type_remark )
        {

            if ( $_TD->{new}{'name'} =~ /temp/
                or not defined( $_TD->{new}{'name'} ) )
            {
                $f_name = $f_uniquename . '-' . $f_type;
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_uniquename' 
                    where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_name' 
                    where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }

        }

        # RAISE NOTICE''new uniquename of this feature is:%'', $f_uniquename;

        # insert into synonym, feature_synonym
        my $s_id = $get_single_value->(
            qq[
            SELECT synonym_id 
            from synonym 
            where name='$f_uniquename' and type_id=$s_type_id],
            'synonym_id'
        );
        if ( not defined($s_id) ) {
            spi_exec_query(
                qq[
            INSERT INTO synonym(name, synonym_sgml, type_id) 
            values('$f_uniquename', '$f_uniquename', $s_type_id)]
            );
            $s_id = $get_single_value->(
                qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_uniquename' and type_id=$s_type_id],
                'synonym_id'
            );
        }
        my $f_s_id = $get_single_value->(
            qq[
            SELECT feature_synonym_id 
            from feature_synonym 
            where feature_id=]
                . $f_row_g->{'feature_id'}
                . qq[ and synonym_id=$s_id and pub_id=$p_id],
            'feature_synonym_id'
        );
        if ( not_defined($f_s_id) ) {
            spi_exec_query(
                qq[
            INSERT INTO feature_synonym
            (feature_id, synonym_id, pub_id, is_current) 
            values (]
                    . $f_row_g->{'feature_id'} . qq[, $s_id, $p_id, 'true')]
            );
        }

        # RAISE NOTICE''feature_id:%, synonym_id:%
        # for uniquename'', $f_row_g->{'feature_id'}, $s_id;

        if ( not defined($f_name) ) {

            $s_id = $get_single_value->(
                qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                'synonym_id'
            );    #LOOK AT
            if ( not defined($s_id) ) {
                spi_exec_query(
                    qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id)]
                );
                $s_id = $get_single_value->(
                    qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );    #LOOK AT
            }
            $f_s_id = $get_single_value->(
                qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                    . $f_row_g->{'feature_id'}
                    . qq[ and synonym_id=$s_id and pub_id=$p_id],
                'feature_synonym_id'
            );        #LOOK AT
            if ( not defined $f_s_id ) {
                spi_exec_query(
                    qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                        . $f_row_g->{'feature_id'}
                        . qq[, $s_id, $p_id, 'true')]
                );
            }

            # RAISE NOTICE''feature_id:%, synonym_id:% for name'',
            # $f_row_g->{'feature_id'}, $s_id;
        }
    }    # ends if uniquename like temp

    return 'MODIFY';
END;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_assignname_fn_i() TO PUBLIC;

CREATE TRIGGER feature_assignname_tr_i AFTER INSERT ON feature for EACH ROW EXECUTE PROCEDURE feature_assignname_fn_i();

DROP TRIGGER feature_relationship_tr_d  ON feature_relationship;

CREATE OR REPLACE FUNCTION feature_relationship_fn_d() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncRNA                = 'ncRNA';
    my $f_type_snRNA                = 'snRNA';
    my $f_type_tRNA                 = 'tRNA';
    my $f_type_rRNA                 = 'rRNA';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_miRNA                = 'miRNA';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    #RAISE NOTICE ''enter fr_d, fr.object_id:%, fr.subject_id:%'',
    #$_TD->{old}{'object_id'}, $_TD->{old}{'subject_id'};
    my $f_type = $get_single_value->(
        qq[SELECT name from cvterm  where cvterm_id=]
            . $_TD->{old}{'type_id'} . q[],
        'name'
    );
    if ( $f_type eq $f_type_allele ) {

        # RAISE NOTICE''delete relationship beteen gene:%
        # and allele:%'', $_TD->{old}{'object_id'},
        # $_TD->{old}{'subject_id'};
    }
    else {
        $f_type = $get_single_value->(
            qq[
                SELECT c.name 
                from feature f, cvterm c  
                where f.type_id=c.cvterm_id and f.feature_id=]
                . $_TD->{old}{'object_id'} . q[],
            'name'
        );
        if ( $f_type eq $f_type_gene ) {
            my $f_type_temp = $get_single_value->(
                qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                    . $_TD->{old}{'subject_id'}
                    . q[ and f.type_id=c.cvterm_id],
                'name'
            );
            if (   $f_type_temp eq $f_type_transcript
                or $f_type_temp eq $f_type_ncRNA
                or $f_type_temp eq $f_type_snoRNA
                or $f_type_temp eq $f_type_snRNA
                or $f_type_temp eq $f_type_tRNA
                or $f_type_temp eq $f_type_rRNA
                or $f_type_temp eq $f_type_miRNA
                or $f_type_temp eq $f_type_pseudo
                or $f_type_temp eq $f_type_transposable_element
                or $f_type_temp eq $f_type_promoter
                or $f_type_temp eq $f_type_repeat_region )
            {

                my $fr_row = $get_single_row->(
                    qq[
                SELECT * 
                from feature_relationship where object_id<>]
                        . $_TD->{old}{'object_id'}
                        . qq[ and subject_id=]
                        . $_TD->{old}{'subject_id'} . q[],
                );
                if ( not defined( $fr_row->{'object_id'} ) ) {

                    # RAISE NOTICE''delete this lonely transcript:%'',
                    # $_TD->{old}{'subject_id'};
                    spi_exec_query( qq[delete from feature where feature_id=]
                            . $_TD->{old}{'subject_id'} );
                }
            }
            else {
                # RAISE NOTICE''wrong feature_relationship: 
                # gene->NO_transcript:object_id:%, subject_id:%'',
                # $_TD->{old}{'object_id'}, $_TD->{old}{'subject_id'};
            }
        }
        elsif ($f_type eq $f_type_transcript
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region )
        {

            $f_type_temp = $get_single_value->(
                qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                    . $_TD->{old}{'subject_id'}
                    . q[ and f.type_id=c.cvterm_id],
                'name'
            );
            if (   $f_type_temp eq $f_type_protein
                or $f_type_temp eq $f_type_exon )
            {
                my $fr_row
                    = $get_single_row->(
                    qq[SELECT * from feature_relationship where subject_id=]
                        . $_TD->{old}{'subject_id'}
                        . q[ and object_id<>$_TD->{old}{'object_id'}] );
                if ( not defined( $fr_row->{'object_id'} ) ) {

                    # RAISE NOTICE''delete this lonely exon/polypeptide:%'',
                    # $_TD->{old}{'subject_id'};
                    spi_exec_query( qq[delete from feature where feature_id=]
                            . $_TD->{old}{'subject_id'} );
                }
            }
            else {

                # RAISE NOTICE''wrong relationship:
                # transcript->NO_polypeptide/exon: objfeature:%,
                # subjfeature:%'',$_TD->{old}{'object_id'},
                # $_TD->{old}{'subject_id'};
            }
        }
    }

    # RAISE NOTICE ''leave fr_d ....'';
    return;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_relationship_fn_d() TO PUBLIC;

CREATE TRIGGER feature_relationship_tr_d BEFORE DELETE ON feature_relationship  for EACH ROW EXECUTE PROCEDURE feature_relationship_fn_d();

DROP TABLE trigger_log;
CREATE TABLE trigger_log(
   value   varchar(255) not null,
   timeaccessioned   timestamp not null default current_timestamp,
   table_name   varchar(50),
   id      int 
);

GRANT ALL ON TABLE trigger_log TO PUBLIC;


DROP TRIGGER feature_relationship_propagatename_tr_i ON feature_relationship;

CREATE OR REPLACE FUNCTION feature_relationship_propagatename_fn_i() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncRNA                = 'ncRNA';
    my $f_type_snRNA                = 'snRNA';
    my $f_type_tRNA                 = 'tRNA';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_miRNA                = 'miRNA';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_rRNA                 = 'rRNA';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';
    my $c_name_synonym              = 'synonym';
    my $cv_cvname_synonym           = 'null';
    my $p_miniref                   = 'none';
    my $get_single_value            = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    my $prefix = $get_single_value->(
        qq[
        SELECT cp.value 
        FROM cvtermprop cp, cvterm, cv 
        WHERE cvterm.name = 'prefix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'],
        'value'
    );
    my $suffix = $get_single_value->(
        qq[
        SELECT cp.value 
        FROM cvtermprop cp, cvterm, cv 
        WHERE cvterm.name = 'suffix' 
        and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id 
        and cv.name = 'apollo'],
        'value'
    );

    my $p_id = $get_single_value->(
        qq[
        SELECT pub_id 
        from pub 
        where uniquename = '$p_miniref'], 'pub_id'
    );
    my $s_type_id = $get_single_value->(
        qq[
        SELECT cvterm_id 
        from cvterm c1, cv c2 
        where c1.name='$c_name_synonym' and c2.name='$cv_cvname_synonym' 
        and c1.cv_id=c2.cv_id], 'cvterm_id'
    );

    #RAISE NOTICE ''propagating names, prefix:%,
    #$suffix:%'',prefix,$suffix;

    #RAISE NOTICE ''enter fr_i, fr.object_id:%, fr.subject_id:%'',
    #$_TD->{new}{'object_id'}, $_TD->{new}{'subject_id'};
    my $f_type = $get_single_value->(
        qq[
        SELECT c.name 
        from feature f, cvterm c  
        where f.type_id=c.cvterm_id 
        and f.feature_id=] . $_TD->{new}{'object_id'} . q[], 'name'
    );

    my $f_name = $get_single_value->(
        qq[
        SELECT name 
        from feature 
        where feature_id =] . $_TD->{new}{'subject_id'}, 'name'
    );

    # OK, the thing having a child added is a gene
    if ( ( not defined($f_name) or $f_name =~ /$prefix.*temp/ )
        and $f_type eq $f_type_gene )
    {
        my $f_type_temp = $get_single_value->(
            qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                . $_TD->{new}{'subject_id'}
                . q[ and f.type_id=c.cvterm_id],
            'name'
        );
        if (   $f_type_temp eq $f_type_transcript
            or $f_type_temp eq $f_type_snoRNA
            or $f_type_temp eq $f_type_ncRNA
            or $f_type_temp eq $f_type_snRNA
            or $f_type_temp eq $f_type_tRNA
            or $f_type_temp eq $f_type_rRNA
            or $f_type_temp eq $f_type_miRNA
            or $f_type_temp eq $f_type_pseudo
            or $f_type_temp eq $f_type_transposable_element
            or $f_type_temp eq $f_type_promoter
            or $f_type_temp eq $f_type_repeat_region )
        {

            # Generate a new name based on the gene name
            # the name is like: genename-transcript#
            my $f_name_gene = $get_single_value->(
                qq[SELECT name from feature where feature_id=]
                    . $_TD->{new}{'object_id'} . q[],
                'name'
            );

# my $maxid = $get_single_value->( qq[ SELECT to_number(max(substring(name from (length(f_name_gene)+1+10))), '99999') FROM feature where name like f_name_gene||'-transcript%'],'to_number(max(substring(name');#
            my $c_cv_id = $get_single_value->(
                qq[
            SELECT cv_id 
            FROM cv WHERE name = 'Sequence Ontology Feature Annotation'],
                'cv_id'
            );
            my $fng_type_id = $get_single_value->(
                qq[
            SELECT cvterm_id 
            FROM cvterm 
            WHERE name = 'transcript' 
            AND cv_id = $c_cv_id], 'cvterm_id'
            );
            my $maxid = $get_single_value->(
                qq[
            SELECT count 
            FROM feature_namegenerator 
            WHERE name = '$f_name_gene' AND type_id = $fng_type_id], 'count'
            );
            if ( not defined($maxid) ) {
                $maxid = 1;
            }
            else {
                $maxid = $maxid + 1;
            }

            $f_name = $f_name_gene . '-transcript' . $maxid;

            # RAISE NOTICE''start to update feature, gene name:%,
            # new feature name:%'', $f_name_gene, $f_name;
            spi_exec_query(
                qq[UPDATE feature set name='$f_name' where feature_id=]
                    . $_TD->{new}{'subject_id'} );

            spi_exec_query(
                qq[
            DELETE 
            FROM feature_namegenerator 
            WHERE name = '$f_name_gene' AND type_id = $fng_type_id;]
            );
            spi_exec_query(
                qq[
            INSERT INTO feature_namegenerator (name,type_id,count) 
            VALUES ('$f_name_gene', $fng_type_id, $maxid);]
            );

            my $s_id = $get_single_value->(
                qq[
            SELECT synonym_id 
            from synonym 
            where name='$f_name' 
            and type_id=$s_type_id],
                'synonym_id'
            );

            if ( not defined $s_id ) {
                spi_exec_query(
                    qq[
                INSERT INTO synonym(name, synonym_sgml, type_id) 
                values('$f_name', '$f_name', $s_type_id);]
                );
                $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
            }

            # RAISE NOTICE ''start to insert feature_synonym:
            # synonym_id:%,feature_id:%,
            # pub_id:%'', $s_id, $_TD->{new}{'subject_id'}, $p_id;
            my $f_s_id = $get_single_value->(
                qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                    . $_TD->{new}{'subject_id'}
                    . q[ and synonym_id=$s_id and pub_id=$p_id],
                'feature_synonym_id'
            );
            if ( not defined $f_s_id ) {
                spi_exec_query(
                    qq[
                INSERT INTO feature_synonym
                (feature_id, synonym_id, pub_id, is_current) 
                values (]
                        . $_TD->{new}{'subject_id'}
                        . qq[, $s_id, $p_id, 'true');]
                );
            }
        }

        # here the thing having a child added is a second level thing
        # (eg, a transcript is getting an exon or protein)
    }
    elsif (
        ( not defined($f_name) or $f_name =~ /$prefix.*temp/ )
        and (  $f_type eq $f_type_transcript
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region )
        )
    {
        my $f_name_gene = $get_single_value->(
            qq[
            SELECT f.name 
            from feature f, feature_relationship fr, cvterm c 
            where f.feature_id=fr.object_id and fr.subject_id=]
                . $_TD->{new}{'object_id'}
                . q[ and f.type_id=c.cvterm_id and c.name=f_type_gene],
            'name'
        );
        my $f_type_temp = $get_single_value->(
            qq[
            SELECT c.name 
            from feature f, cvterm c 
            where f.feature_id=]
                . $_TD->{new}{'subject_id'} 
                . q[ and f.type_id=c.cvterm_id], 'name'
        );

        # Adding a protein to a transcript
        if ( $f_type_temp eq $f_type_protein ) {
            if ( defined $f_name_gene ) {
                my $f_row_p
                    = $get_single_row->(
                    qq[SELECT * from feature where feature_id=]
                        . $_TD->{new}{'subject_id'} );

                # Create a new name for this protein
                # (again repeating code in assign_names)
                my $c_cv_id = $get_single_value->(
                    qq[
                SELECT cv_id 
                FROM cv 
                WHERE name = 'Sequence Ontology'], 'cv_id'
                );
                my $fng_type_id = $get_single_value->(
                    qq[
                SELECT cvterm_id 
                FROM cvterm 
                WHERE name = '$f_type_protein' AND cv_id = $c_cv_id],
                    'cvterm_id'
                );
                my $maxid = $get_single_value->(
                    qq[
                SELECT count 
                FROM feature_namegenerator 
                WHERE name = '$f_name_gene' AND type_id = $fng_type_id],
                    'count'
                );
                if ( not defined($maxid) ) {
                    $maxid = 1;
                }
                else {
                    $maxid = $maxid + 1;
                }

                $f_name = $f_name_gene . '-' . $f_type_protein . $maxid;

# RAISE NOTICE'update name of polypeptide:% to new name:%',f_row_p.name, $f_name;
                spi_exec_query(
                    qq[
                UPDATE feature set name='$f_name' 
                where feature_id=] . $_TD->{new}{'subject_id'}
                );

                spi_exec_query(
                    qq[
                DELETE FROM feature_namegenerator
                WHERE name = '$f_name_gene' AND type_id = $fng_type_id;]
                );
                spi_exec_query(
                    qq[
                INSERT INTO feature_namegenerator (name,type_id,count) 
                VALUES ('$f_name_gene', $fng_type_id, $maxid);]
                );

                my $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
                if ( not defined($s_id) ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id);]
                    );
                    my $s_id = $get_single_value->(
                        qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id], 'synonym_id'
                    );
                }

                my $f_s_id = $get_single_value->(
                    qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                        . $f_row_p->{'feature_id'} 
                        . qq[and synonym_id=$s_id],
                    'feature_synonym_id'
                );
                if ( not defined $f_s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                            . $f_row_p->{'feature_id'}
                            . qq[, $s_id, $p_id, 'true');]
                    );
                }
            }
            else {

                # RAISE NOTICE'Couldnt find a gene to add this
                # polypeptide to (feature_id:%)', $_TD->{new}{'subject_id'} ;
            }

            # Adding an exon to a transcript
        }
        elsif ( $f_type_temp eq $f_type_exon ) {
            if ( defined $f_name_gene ) {
                my $f_row_e
                    = $get_single_row->(
                    qq[SELECT * from feature where feature_id=]
                        . $_TD->{new}{'subject_id'} );
                my $fl_row_e
                    = $get_single_row->(
                          qq[SELECT * from featureloc where feature_id =]
                        . $_TD->{new}{'subject_id'}
                        . q[ and rank=0] );
                if (   not defined( $fl_row_e->{'fmin'} )
                    or not defined( $fl_row_e->{'fmax'} ) )
                {

             # RAISE NOTICE'cant create exon name for feature_id %
             # since there is no featureloc entry', $_TD->{new}{'subject_id'};
                    return 'MODIFY';
                }
                else {
                    $f_name
                        = $f_name_gene . ':'
                        . $fl_row_e->{'fmin'} . '-'
                        . $fl_row_e->{'fmax'};
                }

                # RAISE NOTICE'exon new name:%', $f_name;
                spi_exec_query(
                    qq[UPDATE feature set name='$f_name' where feature_id=]
                        . $_TD->{new}{'subject_id'} );

                my $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
                if ( not defined $s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id);]
                    );
                    my $s_id = $get_single_value->(
                        qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id],
                        'synonym_id'
                    );
                }

                my $f_s_id = $get_single_value->(
                    qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                        . $f_row_e->{'feature_id'}
                        . qq[ and synonym_id=$s_id],
                    'feature_synonym_id'
                );
                if ( not defined $f_s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                            . $f_row_e->{'feature_id'}
                            . qq[, $s_id, $p_id, 'true');]
                    );
                }
            }
            else {

                # RAISE NOTICE'Couldnt find a gene to add
                # this exon to (feature_id:%)',$_TD->{new}{'subject_id'};
            }
        }
    }
    else {

        # Nothing to do, the name is not null or containing temp
    }

    #RAISE NOTICE 'leave fr_i ....';
    return 'MODIFY';

$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_relationship_propagatename_fn_i() TO PUBLIC;

CREATE TRIGGER feature_relationship_propagatename_tr_i AFTER INSERT ON feature_relationship FOR EACH ROW EXECUTE PROCEDURE feature_relationship_propagatename_fn_i();


DROP TRIGGER feature_update_name_tr_u ON feature;

CREATE OR REPLACE FUNCTION feature_fn_u() RETURNS TRIGGER AS
'
DECLARE
  f_type          cvterm.name%TYPE;
  f_type_gene     CONSTANT varchar :=''gene'';
  f_row           feature%ROWTYPE;
  s_type_id       synonym.type_id%TYPE;
  s_id            synonym.synonym_id%TYPE;
  f_s_id          feature_synonym.feature_synonym_id%TYPE;
  p_id            pub.pub_id%TYPE;
  p_miniref       CONSTANT varchar:=''none'';
  c_name_synonym  CONSTANT varchar:=''synonym'';
  cv_cvname_synonym CONSTANT varchar:=''null'';
  name_suffix     varchar;
  child_name      varchar;
BEGIN
  IF OLD.uniquename <> NEW.uniquename AND OLD.uniquename NOT LIKE ''%temp%'' THEN
      RAISE NOTICE ''You may not change the uniquename of a feature'';
      RAISE NOTICE ''if you feel you must, contact your database admin'';
      RETURN OLD;
  END IF;
  IF OLD.name = NEW.name THEN
      --not updating name, so go ahead 
      RETURN NEW;
  END IF;


--fetch a few useful things
  SELECT INTO s_type_id cvterm_id from cvterm c1, cv c2 where c1.name=c_name_synonym and c2.name=cv_cvname_synonym and c1.cv_id=c2.cv_id;
  SELECT INTO f_type cv.name FROM feature f, cvterm cv WHERE f.feature_id = OLD.feature_id and f.type_id = cv.cvterm_id; 
  SELECT INTO p_id pub_id from pub where uniquename = p_miniref;



--  IF f_type <> f_type_gene THEN
--      --its not a gene, so go ahead
--      --but insert the new name into the synonym table


  --On gene name update, we also update the gene inner synonym (ie himself)
  --so for all features, the inner synonym gets updated
      IF NEW.name IS NOT NULL THEN
          SELECT INTO s_id synonym_id from synonym where name=NEW.name and type_id=s_type_id;
          IF s_id IS NULL THEN
              INSERT INTO synonym(name, synonym_sgml, type_id) values(NEW.name, NEW.name, s_type_id);
              SELECT INTO s_id synonym_id from synonym where name=NEW.name and type_id=s_type_id;
          END IF;
          SELECT INTO f_s_id feature_synonym_id from feature_synonym where feature_id=NEW.feature_id and synonym_id=s_id and pub_id=p_id;
          IF f_s_id IS NULL THEN
              INSERT INTO feature_synonym(feature_id, synonym_id, pub_id, is_current) values (NEW.feature_id, s_id, p_id, ''true'');
          END IF;
      END IF;
 
  IF f_type <> f_type_gene THEN
      --its not a gene, so go ahead   
      RETURN NEW;
  END IF;

  --OK, so its a gene, and were changing the name...




  --For corectly handling alternate transcript of a gene, we must add a distinct in order not to process the same exon multiple times (exons are shared in chado)
  FOR f_row IN SELECT DISTINCT f.* FROM feature f, get_sub_feature_ids(OLD.feature_id) ch WHERE f.feature_id = ch.feature_id LOOP
      --This one process the transcripts and the proteins
--      IF f_row.name LIKE OLD.name||''-%'' THEN
--          SELECT INTO name_suffix  substring(name from OLD.name||''(-.+)'') FROM feature where feature_id = f_row.feature_id;
--          child_name = NEW.name||name_suffix;
--          UPDATE feature SET name = child_name WHERE feature_id = f_row.feature_id;

--          SELECT INTO s_id synonym_id from synonym where name=child_name and type_id=s_type_id;
--          IF s_id IS NULL THEN
--              INSERT INTO synonym(name, synonym_sgml, type_id) values(child_name, child_name, s_type_id);
--              SELECT INTO s_id synonym_id from synonym where name=child_name and type_id=s_type_id;
--          END IF;
--          SELECT INTO f_s_id feature_synonym_id from feature_synonym where feature_id=f_row.feature_id and synonym_id=s_id and pub_id=p_id;
--          IF f_s_id IS NULL THEN
--              INSERT INTO feature_synonym(feature_id, synonym_id, pub_id, is_current) values (f_row.feature_id, s_id, p_id, ''true'');
--          END IF;
--      END IF;

      --And this one process the exons (of form gene_name:something)
      --Be careful, this could lead to problems with some autogenerated split names which for flybase are also of the form gene_name:#) TODO : move this regexp to something like /gene_name:\d-\d/
      IF  f_row.name LIKE OLD.name||'':%'' THEN
          SELECT INTO name_suffix  substring(name from OLD.name||''(:.+)'') FROM feature where feature_id = f_row.feature_id;
          child_name = NEW.name||name_suffix;
          RAISE NOTICE ''feature_id:%, name:% , new name : %, namesuffix:%, geneName:%'', f_row.feature_id, f_row.name, child_name,name_suffix, NEW.name ;
          UPDATE feature SET name = child_name WHERE feature_id = f_row.feature_id;

          SELECT INTO s_id synonym_id from synonym where name=child_name and type_id=s_type_id;
          IF s_id IS NULL THEN
              INSERT INTO synonym(name, synonym_sgml, type_id) values(child_name, child_name, s_type_id);
              SELECT INTO s_id synonym_id from synonym where name=child_name and type_id=s_type_id;
          END IF;
          SELECT INTO f_s_id feature_synonym_id from feature_synonym where feature_id=f_row.feature_id and synonym_id=s_id and pub_id=p_id;
          IF f_s_id IS NULL THEN
              INSERT INTO feature_synonym(feature_id, synonym_id, pub_id, is_current) values (f_row.feature_id, s_id, p_id, ''true'');          END IF;

      END IF; 

  END LOOP;  
  
  RETURN NEW; 
END;
'LANGUAGE plpgsql;

CREATE TRIGGER feature_update_name_tr_u BEFORE UPDATE ON feature FOR EACH ROW EXECUTE PROCEDURE feature_fn_u();

-- function to fascilitate gene merges
-- returns the uniquename of the merged gene
--WARNING: COMPLETELY UNTESTED
CREATE OR REPLACE FUNCTION apollo_merge(varchar, varchar) RETURNS varchar AS
'
DECLARE
  f1_uniquename		ALIAS FOR $1;
  f2_uniquename		ALIAS FOR $2;
  f_uniquename		feature.uniquename%TYPE;
  f1_fid		feature.feature_id%TYPE;
  f2_fid		feature.feature_id%TYPE;
  f_id			feature.feature_id%TYPE;
  f1_type		cvterm.name%TYPE;
  f2_type		cvterm.name%TYPE;
  f1_organism_id	feature.organism_id%TYPE;
  f2_organism_id        feature.organism_id%TYPE;	
  f_type_gene		CONSTANT varchar :=''gene'';
  c_cvterm_id		cvterm.cvterm_id%TYPE;
  s_id			synonym.synonym_id%TYPE;
  dbxref_id		dbxref.dbxref_id%TYPE;
  fd_row                feature_dbxref%ROWTYPE;
  p_id			pub.pub_id%TYPE;
  fpub_row		feature_pub%ROWTYPE;
  fp_row		featureprop%ROWTYPE;
  fc_row		feature_cvterm%ROWTYPE;
  fs_row		feature_synonym%ROWTYPE;
BEGIN
--check that they are both genes
  SELECT INTO f1_type c.name FROM feature f, cvterm c
                            WHERE f.uniquename = f1_uniquename AND
                                  f.type_id    = c.cvterm_id;
  SELECT INTO f2_type c.name FROM feature f, cvterm c
                            WHERE f.uniquename = f1_uniquename AND
                                  f.type_id    = c.cvterm_id;

  IF f1_type <> f_type_gene OR f2_type <> f_type_gene THEN
      RAISE NOTICE ''The uniquenames for the features provided must be those of genes'';
      RETURN OLD;
  END IF;

--check that they come from the same organism
  SELECT INTO f1_organism_id FROM feature WHERE uniquename=f1_uniquename;
  SELECT INTO f2_organism_id FROM feature WHERE uniquename=f2_uniquename;

  IF f1_organism_id <> f2_organism_id THEN
      RAISE NOTICE ''The merged genes must come from the same organism'';
      RETURN OLD;
  END IF;

  SELECT INTO c_cvterm_id type_id FROM feature
                                 WHERE uniquename = f1_uniquename;

  SELECT INTO f_uniquename next_uniquename();

--create the new gene
  INSERT INTO feature (organism_id, uniquename, type_id)
              VALUES  (f1_organism_id, f_uniquename, c_cvterm_id);

  SELECT INTO f_id feature_id FROM feature
                             WHERE uniquename  = f_uniquename AND
                                   organism_id = f_organism_id AND
                                   type_id     = c_cvterm_id;

  SELECT INTO f1_id feature_id FROM feature
                             WHERE uniquename  = f1_uniquename AND
                                   organism_id = f1_organism_id AND
                                   type_id     = c_cvterm_id;

  SELECT INTO f2_id feature_id FROM feature
                             WHERE uniquename  = f2_uniquename AND
                                   organism_id = f2_organism_id AND
                                   type_id     = c_cvterm_id;

--add synonyms to new feature for all of the synonyms of the old feature
  FOR fs_row IN SELECT * FROM feature_synonym
                               WHERE feature_id = f1_id OR
                                     feature_id = f2_id LOOP
      INSERT INTO feature_synonym (feature_id, synonym_id)
            VALUES (f_id, fs_row.synonym_id);
  END LOOP;

--copy dbxref, featureprop, cvterms, pubs to the new gene
  FOR fd_row IN SELECT * FROM feature_dbxref 
                                   WHERE feature_id = f1_id OR
                                         feature_id = f2_id LOOP
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES (f_id, fd_row.dbxref_id, 0);
  END LOOP;

  FOR fp_row IN SELECT * FROM featureprop
                        WHERE feature_id = f1_id OR
                              feature_id = f2_id LOOP
      INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES (f_id,fp_row.type_id,fp_row.value,fp_row.rank);
  END LOOP;

  FOR fc_row IN SELECT * FROM feature_cvterm
                        WHERE feature_id = f1_id OR
                              feature_id = f2_id LOOP
      INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES (f_id,fc_row.cvterm_id,fc_row.pub_id,fc_row.is_not);
  END LOOP; 

  FOR fpub_row IN SELECT * FROM feature_pub
                           WHERE feature_id = f1_id OR
                                 feature_id = f2_id LOOP
      INSERT INTO feature_pub (feature_id,pub_id)
            VALUES (f_id,fpub_row.pub_id);
  END LOOP;

--delete featureloc entries for old genes
  DELETE FROM featureloc WHERE feature_id=f1_id;
  DELETE FROM featureloc WHERE feature_id=f2_id;

--mark old gene features as obsolete
  UPDATE feature SET is_obsolete=true WHERE feature_id=f1_id;
  UPDATE feature SET is_obsolete=true WHERE feature_id=f2_id;

--note in either feature_relationship or featureprop the origin of this gene



  RETURN f_uniquename;
END;
'LANGUAGE plpgsql; 


-- function to fascilitate gene splits
-- Takes three arguments:
--   -the feature_id of the old gene that was split
--   -the feature_id of the new genes
--WARNING: COMPLETELY UNTESTED
CREATE OR REPLACE FUNCTION apollo_split(int,int,int) RETURNS int AS
'
DECLARE
  f_id                  ALIAS FOR $1;
  f1_id                ALIAS FOR $2;
  f2_id                ALIAS FOR $3;
  f_type                cvterm.name%TYPE;
  f_organism_id		feature.organism_id%TYPE;
  f1_organism_id        feature.organism_id%TYPE;
  f2_organism_id        feature.organism_id%TYPE;
  f_type_gene           CONSTANT varchar :=''gene'';
  c_cvterm_id           cvterm.cvterm_id%TYPE;
  fs_row                feature_synonym%ROWTYPE;
  fd_row		feature_dbxref%ROWTYPE;
  fpub_row              pub%ROWTYPE;
  fp_row                featureprop%ROWTYPE;
  fc_row                feature_cvterm%ROWTYPE;
BEGIN

--do some error checking; first, make sure they are all genes
  SELECT INTO f_type c.name FROM feature f, cvterm c
                            WHERE f.feature_id = f_id AND
                                  f.type_id    = c.cvterm_id;

  IF f_type <> f_type_gene THEN
      RAISE NOTICE ''The uniquename for the feature provided must be that of a gene'';
      RETURN OLD;
  END IF;

  SELECT INTO f_type c.name FROM feature f, cvterm c
                            WHERE f.feature_id = f1_id AND
                                  f.type_id    = c.cvterm_id;

  IF f_type <> f_type_gene THEN
      RAISE NOTICE ''The uniquename for the feature provided must be that of a gene'';
      RETURN OLD;
  END IF;

  SELECT INTO f_type c.name FROM feature f, cvterm c
                            WHERE f.feature_id = f2_id AND
                                  f.type_id    = c.cvterm_id;

  IF f_type <> f_type_gene THEN
      RAISE NOTICE ''The uniquename for the feature provided must be that of a gene'';
      RETURN OLD;
  END IF;

--more error checking: are they all from the same organism?
  SELECT INTO f_organism_id organism_id FROM feature
                                        WHERE feature_id = f_id;

  SELECT INTO f1_organism_id organism_id FROM feature
                                        WHERE feature_id = f1_id;

  SELECT INTO f2_organism_id organism_id FROM feature
                                        WHERE feature_id = f2_id;

  IF f_organism_id <> f1_organism_id OR f_organism_id <> f2_organism_id THEN
      RAISE NOTICE ''The new gene and the old genes need to come from the same organism'';
      RETURN OLD;
  END IF;

  SELECT INTO c_cvterm_id type_id FROM feature
                                 WHERE feature_id = f_id;

--add synonyms to new feature for all of the synonyms of the old feature
  FOR fs_row IN SELECT * FROM feature_synonym
                        WHERE feature_id = f_id LOOP
      INSERT INTO feature_synonym (feature_id, synonym_id, pub_id)
            VALUES (f1_id, fs_row.synonym_id, fs_row.pub_id);
      INSERT INTO feature_synonym (feature_id, synonym_id, pub_id)
            VALUES (f2_id, fs_row.synonym_id, fs_row.pub_id);
  END LOOP;

--copy dbxref, featureprop, cvterms, pubs to the new gene
  FOR fd_row IN SELECT * FROM feature_dbxref
                        WHERE feature_id = f_id LOOP
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES (f1_id, fd_row.dbxref_id, 0);
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES (f2_id, fd_row.dbxref_id, 0);
  END LOOP;

  FOR fp_row IN SELECT * FROM featureprop
                        WHERE feature_id = f_id LOOP
      INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES (f1_id,fp_row.type_id,fp_row.value,fp_row.rank);
      INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES (f2_id,fp_row.type_id,fp_row.value,fp_row.rank);

  END LOOP;

  FOR fc_row IN SELECT * FROM feature_cvterm
                        WHERE feature_id = f_id LOOP
      INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES (f1_id,fc_row.cvterm_id,fc_row.pub_id,fc_row.is_not);
      INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES (f2_id,fc_row.cvterm_id,fc_row.pub_id,fc_row.is_not);
  END LOOP;

  FOR fpub_row IN SELECT * FROM feature_pub
                       WHERE feature_id = f_id LOOP
      INSERT INTO feature_pub (feature_id,pub_id)
            VALUES (f1_id,p_row.pub_id);
      INSERT INTO feature_pub (feature_id,pub_id)
            VALUES (f2_id,p_row.pub_id);
  END LOOP;


--delete featureloc entries for old genes
  DELETE FROM featureloc WHERE feature_id=f_id;

--mark old gene features as obsolete
  UPDATE feature SET is_obsolete=true WHERE feature_id=f_id;

--note in either feature_relationship or featureprop the origin of this gene



  RETURN 1;
END;
'LANGUAGE plpgsql;


