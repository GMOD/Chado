-- these are nearly identical to the triggers that flybase uses, but will
-- serve as the foundation of general triggers for GMOD.  Things that need to
-- be done:
--
--* indentify the items that have to be dynamically (at make time) extrapolated.
--* allow a more flexible naming scheme
--* remove the portion creating a flybase dbxref.
--* probably 20 more things I haven't thought of yet.



--gets the next available uniquename; note that it is
--destructive because it calls nextval on a sequence 
CREATE OR REPLACE FUNCTION next_uniquename() RETURNS varchar AS $$

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    # Prefix of the name
    my $prefix = $get_single_value->(
        q[
        SELECT cp.value FROM cvtermprop cp, cvterm, cv
        WHERE cvterm.name = 'prefix' and
            cp.cvterm_id = cvterm.cvterm_id and
            cvterm.cv_id = cv.cv_id and
            cv.name = 'apollo';
    ],
        'value'
    );

    # Suffix of the name
    my $suffix = $get_single_value->(
        q[
        SELECT cp.value FROM cvtermprop cp, cvterm, cv
        WHERE cvterm.name = 'suffix' and
            cp.cvterm_id = cvterm.cvterm_id and
            cvterm.cv_id = cv.cv_id and
            cv.name = 'apollo';
    ],
        'value'
    );

    my $max_id = $get_single_value->(
        q[ SELECT nextval('uniquename_id_generator') as nextval ], 'nextval',
    );
    $max_id = sprintf( "%06d", $max_id );

    return $prefix . $max_id . $suffix;

END;
$$ LANGUAGE plperl;

DROP TRIGGER tr_feature_del  ON feature;

CREATE OR REPLACE function fn_feature_del() RETURNS TRIGGER AS $$

    my $f_type_gene                 = q[gene];
    my $f_type_exon                 = q[exon];
    my $f_type_transcript           = q[mRNA];
    my $f_type_snoRNA               = q[snoRNA];
    my $f_type_ncRNA                = q[ncRNA];
    my $f_type_snRNA                = q[snRNA];
    my $f_type_tRNA                 = q[tRNA];
    my $f_type_rRNA                 = q[rRNA];
    my $f_type_promoter             = q[promoter];
    my $f_type_repeat_region        = q[repeat_region];
    my $f_type_miRNA                = q[miRNA];
    my $f_type_transposable_element = q[transposable_element];
    my $f_type_pseudo               = q[pseudogene];
    my $f_type_protein              = q[polypeptide];
    my $f_type_allele               = q[alleleof];

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    #RAISE NOTICE ''enter f_d, feature uniquename:%,
    #type_id:%'',$_TD->{old}{'uniquename'}, $_TD->{old}{'type_id'};

    my $f_return = $_TD->{old}{'feature_id'};

    my $f_type = $get_single_value->(
        q[
        SELECT c.name from feature f, cvterm c where f.feature_id=]
            . $_TD->{old}{'feature_id'} 
            . q[ and f.type_id=c.cvterm_id], 'name'
    );

    if ( $f_type eq $f_type_gene ) {
        my $f_id_allele = $get_single_value->(
            q[
            SELECT fr.subject_id 
            from  feature_relationship fr, cvterm c 
            where  (fr.object_id=]
                . $_TD->{old}{'feature_id'}
                . q[ or fr.subject_id=]
                . $_TD->{old}{'feature_id'}
                . q[)  and fr.type_id=c.cvterm_id and c.name=']
                . $f_type_allele . q['],
            'subject_id'
        );

        if ( not $f_id_allele ) {
            my $sql_str
                = q[SELECT * from feature_relationship fr where fr.object_id=]
                . $_TD->{old}{'feature_id'};
            my $rv = spi_exec_query($sql_str);
            foreach my $fr_row ( @{ $rv->{q[rows]} || [] } ) {

                my $f_id_transcript = $get_single_value->(
                    q[
                SELECT f.feature_id 
                from feature f, 
                cvterm c 
                where f.feature_id=] . $fr_row->{q[subject_id]} . q[ 
                and f.type_id=c.cvterm_id 
                and (c.name=']
                        . $f_type_transcript
                        . q[' or c.name=']
                        . $f_type_ncRNA
                        . q[' or c.name=']
                        . $f_type_snoRNA
                        . q[' or c.name=']
                        . $f_type_snRNA
                        . q[' or c.name=']
                        . $f_type_tRNA
                        . q['  or c.name=']
                        . $f_type_rRNA
                        . q['  or c.name=']
                        . $f_type_pseudo
                        . q['  or c.name=']
                        . $f_type_miRNA
                        . q[' or c.name=']
                        . $f_type_transposable_element
                        . q[' or c.name=']
                        . $f_type_promoter
                        . q[' or c.name=']
                        . $f_type_repeat_region . q[')],
                    'feature_id'
                );
                my $f_id_gene = $get_single_value->(
                    q[
                SELECT f.feature_id 
                from feature f, feature_relationship fr, cvterm c 
                where f.feature_id=fr.object_id and fr.subject_id=]
                        . $f_id_transcript
                        . q[ and f.type_id=c.cvterm_id and c.name=']
                        . $f_type_gene
                        . q[' and f.feature_id !=]
                        . $_TD->{old}{'feature_id'} . q[],
                    'feature_id'
                );
                if ( defined($f_id_transcript) and not defined($f_id_gene) ) {

                    # RAISE NOTICE ''delete lonely transcript:%'',
                    # $f_id_transcript;
                    my $message
                        = "delete lonely transcript $f_id_transcript ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_transcript);"
                    );

                    my $sql_str
                        = "delete from feature where feature_id=$f_id_transcript;";
                    spi_exec_query($sql_str);
                }
                elsif ( defined($f_id_gene) and defined($f_id_transcript) ) {

                    # RAISE NOTICE ''There is another gene:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_gene,
                    # $f_id_transcript;
                    my $message = "There is another gene: $f_id_gene "
                        . "associated with this transcript: $f_id_transcript";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', 'feature', $f_id_transcript);"
                    );
                }
            }
            my $message = "delete gene: " . $_TD->{old}{'feature_id'} . " ";
            spi_exec_query( "insert into trigger_log(value, table_name, id)"
                    . " values('$message', 'feature', $_TD->{old}{'feature_id'});"
            );
        }
        else {

            #RAISE NOTICE ''there is other allele associated with this
            #gene:%'', f_id_allele;
            my $message
                = "There is other allele associated with this gene: $f_id_allele ";
            spi_exec_query( "insert into trigger_log(value, table_name, id)"
                    . " values('$message', 'feature', $f_id_allele);" );
            return;
        }
    }
    elsif ($f_type eq $f_type_transcript
        or $f_type eq $f_type_ncRNA
        or $f_type eq $f_type_snoRNA
        or $f_type eq $f_type_snRNA
        or $f_type eq $f_type_tRNA
        or $f_type eq $f_type_rRNA
        or $f_type eq $f_type_pseudo
        or $f_type eq $f_type_miRNA
        or $f_type eq $f_type_transposable_element
        or $f_type eq $f_type_promoter
        or $f_type eq $f_type_repeat_region )
    {

        my $sql_str
            = q[SELECT * from feature_relationship fr where fr.object_id=]
            . $_TD->{old}{'feature_id'};
        my $rv = spi_exec_query($sql_str);
        foreach my $fr_row ( @{ $rv->{q[rows]} || [] } ) {

            # Handle Exons
            my $f_id_exon = $get_single_value->(
                q[SELECT f.feature_id from feature f, cvterm c where f.feature_id=]
                    . $fr_row->{q[subject_id]}
                    . qq[ and f.type_id=c.cvterm_id and c.name='$f_type_exon'],
                'feature_id'
            );
            if ($f_id_exon) {
                my $f_id_exon_transcript = $get_single_value->(
                    q[
                        SELECT f.feature_id 
                        from feature f, feature_relationship fr, cvterm c 
                        where f.feature_id=fr.object_id ]
                        . "and fr.subject_id=$f_id_exon "
                        . "and f.type_id=c.cvterm_id "
                        . "and (c.name='$f_type_transcript'"
                        . " or c.name='$f_type_ncRNA'"
                        . " or c.name='$f_type_snoRNA'"
                        . " or c.name='$f_type_snRNA'"
                        . " or c.name='$f_type_tRNA' "
                        . " or c.name='$f_type_rRNA' "
                        . " or c.name='$f_type_pseudo' "
                        . " or c.name='$f_type_miRNA'"
                        . " or c.name='$f_type_transposable_element'"
                        . " or c.name='$f_type_promoter'"
                        . " or c.name='$f_type_repeat_region') "
                        . "and f.feature_id!="
                        . $_TD->{old}{'feature_id'}, 'feature_id'
                );

                if ( not defined($f_id_exon_transcript)
                    and defined($f_id_exon) )
                {

                    # RAISE NOTICE ''delete lonely exon:%'',
                    # $f_id_exon;
                    my $message = "delete lonely exon $f_id_exon ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_exon);" );
                    spi_exec_query(
                        "delete from feature where feature_id=$f_id_exon;");
                }
                elsif ( defined($f_id_exon)
                    and defined($f_id_exon_transcript) )
                {

                    # RAISE NOTICE ''There is another exon:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_exon,
                    # $f_id_exon_transcript;
                    my $message = "There is another exon: $f_id_exon "
                        . "associated with this transcript: $f_id_exon)";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', ' feature', $f_id_exon);"
                    );
                }
            }

            # Handle Protein
            my $f_id_protein = $get_single_value->(
                q[SELECT f.feature_id from feature f, cvterm c where f.feature_id=]
                    . $fr_row->{q[subject_id]}
                    . qq[ and f.type_id=c.cvterm_id and c.name='$f_type_protein'],
                'feature_id'
            );
            if ($f_id_protein) {
                my $f_id_protein_transcript = $get_single_value->(
                    q[
            SELECT f.feature_id 
            from feature f, feature_relationship fr, cvterm c 
            where f.feature_id=fr.object_id ]
                        . qq[ and fr.subject_id='$f_id_protein' ]
                        . qq[ and f.type_id=c.cvterm_id ]
                        . qq[ and (c.name='$f_type_transcript' ]
                        . qq[ or c.name='$f_type_ncRNA' ]
                        . qq[ or c.name='$f_type_snoRNA' ]
                        . qq[ or c.name='$f_type_snRNA' ]
                        . qq[ or c.name='$f_type_tRNA'  ]
                        . qq[ or c.name='$f_type_rRNA'   ]
                        . qq[ or c.name='$f_type_pseudo' ]
                        . qq[ or c.name='$f_type_miRNA' ]
                        . qq[ or c.name='$f_type_transposable_element' ]
                        . qq[ or c.name='$f_type_promoter' ]
                        . qq[ or c.name='$f_type_repeat_region') ]
                        . qq[ and f.feature_id !=]
                        . $_TD->{old}{'feature_id'} . q[],
                    'feature_id'
                );
                if ( not defined($f_id_protein_transcript)
                    and defined($f_id_protein) )
                {

                    # RAISE NOTICE ''delete lonely protein:%'',
                    # $f_id_protein;
                    my $message = "delete lonely protein $f_id_protein ";
                    spi_exec_query(
                              "insert into trigger_log(value, table_name, id)"
                            . " values('$message', 'feature', $f_id_protein);"
                    );
                    spi_exec_query(
                        "delete from feature where feature_id=$f_id_protein;"
                    );
                }
                elsif ( defined($f_id_protein)
                    and defined($f_id_protein_transcript) )
                {

                    # RAISE NOTICE ''There is another protein:% associated
                    # with this transcript:%,
                    # so this transcript will be kept'',$f_id_protein,
                    # $f_id_protein_transcript;
                    my $message
                        = "There is another protein: $f_id_protein "
                        . "associated with this transcript: $f_id_protein_transcript,"
                        . " so this exon will be kept";
                    spi_exec_query(
                        " insert into trigger_log( value, table_name, id ) "
                            . " values( '$message', ' feature', $f_id_protein);"
                    );
                }
            }
        }
    }

    #RAISE NOTICE ''leave f_d ....'';
    return;
END;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION fn_feature_del() TO PUBLIC;

CREATE TRIGGER tr_feature_del BEFORE DELETE ON feature for EACH ROW EXECUTE PROCEDURE fn_feature_del();

DROP TRIGGER feature_assignname_tr_i ON feature;

CREATE OR REPLACE FUNCTION feature_assignname_fn_i() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncrna                = 'ncrna';
    my $f_type_snrna                = 'snrna';
    my $f_type_trna                 = 'trna';
    my $f_type_rrna                 = 'rrna';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_mirna                = 'mirna';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';
    my $f_type_remark               = 'remark';
    my $c_name_synonym              = 'synonym';
    my $cv_cvname_synonym           = 'null';
    my $p_miniref                   = 'none';

    my $f_name;

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    my $is_anal = $get_single_value->(
        q[SELECT is_analysis FROM feature WHERE uniquename =']
            . $_TD->{new}{'uniquename'}
            . q[' and type_id =]
            . $_TD->{new}{'type_id'}
            . q[ and organism_id =]
            . $_TD->{new}{'organism_id'} . q[],
        'is_analysis'
    );
    if ($is_anal) {
        return;
    }

    my $prefix = $get_single_value->(
        q[
    SELECT cp.value 
    FROM cvtermprop cp, cvterm, cv 
    WHERE cvterm.name = 'prefix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'
    ],
        'value'
    );
    my $suffix = $get_single_value->(
        q[
    SELECT cp.value 
    FROM cvtermprop cp, cvterm, cv 
    WHERE cvterm.name = 'suffix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'
    ], 'value'
    );
    my $f_type = $get_single_value->(
        q[
        SELECT c.name 
        from feature f, cvterm c 
        where f.type_id=c.cvterm_id and f.uniquename=']
            . $_TD->{new}{'uniquename'}
            . q[' and f.organism_id =]
            . $_TD->{new}{'organism_id'} . q[],
        'name'
    );
    my $p_id = $get_single_value->(
        qq[SELECT pub_id from pub where uniquename = '$p_miniref'], 'pub_id'
    );
    my $s_type_id = $get_single_value->(
        qq[
        SELECT cvterm_id 
        from cvterm c1, cv c2 
        where c1.name='$c_name_synonym' 
        and c2.name='$cv_cvname_synonym' 
        and c1.cv_id=c2.cv_id],
        'cvterm_id'
    );

    # RAISE NOTICE ''assigning names, prefix:%, suffix:%, type:%,
    # current uniquename:%'',prefix,suffix,f_type,$_TD->{new}{'uniquename'};

    if (   $_TD->{new}{'uniquename'} =~ /$prefix.*temp.*$suffix/
        or $_TD->{new}{'uniquename'} =~ /$prefix.*-temp/ )
    {

        $f_type = $get_single_value->(
            q[
            SELECT c.name 
            from feature f, cvterm c 
            where f.type_id=c.cvterm_id and f.uniquename=']
                . $_TD->{new}{'uniquename'}
                . q[' and f.organism_id =]
                . $_TD->{new}{'organism_id'} . q[],
            'name'
        );

        # my $p_id = $get_single_value->( q[SELECT pub_id from pub
        # where uniquename = $p_miniref],'pub_id');#LOOK AT
        # my $s_type_id = $get_single_value->( q[
        #   SELECT cvterm_id
        #   from cvterm c1, cv c2
        #   where c1.name=$c_name_synonym and c2.name=$cv_cvname_synonym
        #   and c1.cv_id=c2.cv_id],'cvterm_id');#LOOK AT

        my $f_uniquename = $get_single_value->(
            q[SELECT next_uniquename FROM next_uniquename()],
            'next_uniquename'
        );

        my $f_row_g = $get_single_row->(
                  q[SELECT * from feature where uniquename=']
                . $_TD->{new}{'uniquename'}
                . q[' and organism_id=]
                . $_TD->{new}{'organism_id'} . q[],
        );

        if ( $f_type eq $f_type_gene ) {

            if ( $_TD->{new}{'name'} =~ /temp/
                or not defined( $_TD->{new}{'name'} ) )
            {
                $f_name = $f_uniquename;
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_uniquename' ]
                        . qq[where feature_id=] . $f_row_g->{'feature_id'}
                );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename' where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }
        }
        elsif ($f_type eq $f_type_transcript
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_protein
            or $f_type eq $f_type_exon )
        {

            if (not defined(
                           $_TD->{new}{'name'}
                        or $_TD->{new}{'name'} =~ /temp/
                )
                )
            {
                spi_exec_query(
                          qq[UPDATE feature set uniquename='$f_uniquename',]
                        . qq[name=NULL where feature_id=]
                        . $f_row_g->{'feature_id'} );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                          qq[UPDATE feature set uniquename='$f_uniquename',]
                        . qq[name='$f_name' where feature_id=]
                        . $f_row_g->{'feature_id'} );
            }
        }
        elsif ($f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region
            or $f_type eq $f_type_remark )
        {

            if ( $_TD->{new}{'name'} =~ /temp/
                or not defined( $_TD->{new}{'name'} ) )
            {
                $f_name = $f_uniquename . '-' . $f_type;
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_uniquename' 
                    where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }
            else {
                $f_name = $f_row_g->{'name'};
                spi_exec_query(
                    qq[
                    UPDATE feature 
                    set uniquename='$f_uniquename', name='$f_name' 
                    where feature_id=]
                        . $f_row_g->{'feature_id'}
                );
            }

        }

        # RAISE NOTICE''new uniquename of this feature is:%'', $f_uniquename;

        # insert into synonym, feature_synonym
        my $s_id = $get_single_value->(
            qq[
            SELECT synonym_id 
            from synonym 
            where name='$f_uniquename' and type_id=$s_type_id],
            'synonym_id'
        );
        if ( not defined($s_id) ) {
            spi_exec_query(
                qq[
            INSERT INTO synonym(name, synonym_sgml, type_id) 
            values('$f_uniquename', '$f_uniquename', $s_type_id)]
            );
            $s_id = $get_single_value->(
                qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_uniquename' and type_id=$s_type_id],
                'synonym_id'
            );
        }
        my $f_s_id = $get_single_value->(
            qq[
            SELECT feature_synonym_id 
            from feature_synonym 
            where feature_id=]
                . $f_row_g->{'feature_id'}
                . qq[ and synonym_id=$s_id and pub_id=$p_id],
            'feature_synonym_id'
        );
        if ( not_defined($f_s_id) ) {
            spi_exec_query(
                qq[
            INSERT INTO feature_synonym
            (feature_id, synonym_id, pub_id, is_current) 
            values (]
                    . $f_row_g->{'feature_id'} . qq[, $s_id, $p_id, 'true')]
            );
        }

        # RAISE NOTICE''feature_id:%, synonym_id:%
        # for uniquename'', $f_row_g->{'feature_id'}, $s_id;

        if ( not defined($f_name) ) {

            $s_id = $get_single_value->(
                qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                'synonym_id'
            );    #LOOK AT
            if ( not defined($s_id) ) {
                spi_exec_query(
                    qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id)]
                );
                $s_id = $get_single_value->(
                    qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );    #LOOK AT
            }
            $f_s_id = $get_single_value->(
                qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                    . $f_row_g->{'feature_id'}
                    . qq[ and synonym_id=$s_id and pub_id=$p_id],
                'feature_synonym_id'
            );        #LOOK AT
            if ( not defined $f_s_id ) {
                spi_exec_query(
                    qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                        . $f_row_g->{'feature_id'}
                        . qq[, $s_id, $p_id, 'true')]
                );
            }

            # RAISE NOTICE''feature_id:%, synonym_id:% for name'',
            # $f_row_g->{'feature_id'}, $s_id;
        }
    }    # ends if uniquename like temp

    return 'MODIFY';
END;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_assignname_fn_i() TO PUBLIC;

CREATE TRIGGER feature_assignname_tr_i AFTER INSERT ON feature for EACH ROW EXECUTE PROCEDURE feature_assignname_fn_i();

DROP TRIGGER feature_relationship_tr_d  ON feature_relationship;

CREATE OR REPLACE FUNCTION feature_relationship_fn_d() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncRNA                = 'ncRNA';
    my $f_type_snRNA                = 'snRNA';
    my $f_type_tRNA                 = 'tRNA';
    my $f_type_rRNA                 = 'rRNA';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_miRNA                = 'miRNA';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    #RAISE NOTICE ''enter fr_d, fr.object_id:%, fr.subject_id:%'',
    #$_TD->{old}{'object_id'}, $_TD->{old}{'subject_id'};
    my $f_type = $get_single_value->(
        qq[SELECT name from cvterm  where cvterm_id=]
            . $_TD->{old}{'type_id'} . q[],
        'name'
    );
    if ( $f_type eq $f_type_allele ) {

        # RAISE NOTICE''delete relationship beteen gene:%
        # and allele:%'', $_TD->{old}{'object_id'},
        # $_TD->{old}{'subject_id'};
    }
    else {
        $f_type = $get_single_value->(
            qq[
                SELECT c.name 
                from feature f, cvterm c  
                where f.type_id=c.cvterm_id and f.feature_id=]
                . $_TD->{old}{'object_id'} . q[],
            'name'
        );
        if ( $f_type eq $f_type_gene ) {
            my $f_type_temp = $get_single_value->(
                qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                    . $_TD->{old}{'subject_id'}
                    . q[ and f.type_id=c.cvterm_id],
                'name'
            );
            if (   $f_type_temp eq $f_type_transcript
                or $f_type_temp eq $f_type_ncRNA
                or $f_type_temp eq $f_type_snoRNA
                or $f_type_temp eq $f_type_snRNA
                or $f_type_temp eq $f_type_tRNA
                or $f_type_temp eq $f_type_rRNA
                or $f_type_temp eq $f_type_miRNA
                or $f_type_temp eq $f_type_pseudo
                or $f_type_temp eq $f_type_transposable_element
                or $f_type_temp eq $f_type_promoter
                or $f_type_temp eq $f_type_repeat_region )
            {

                my $fr_row = $get_single_row->(
                    qq[
                SELECT * 
                from feature_relationship where object_id<>]
                        . $_TD->{old}{'object_id'}
                        . qq[ and subject_id=]
                        . $_TD->{old}{'subject_id'} . q[],
                );
                if ( not defined( $fr_row->{'object_id'} ) ) {

                    # RAISE NOTICE''delete this lonely transcript:%'',
                    # $_TD->{old}{'subject_id'};
                    spi_exec_query( qq[delete from feature where feature_id=]
                            . $_TD->{old}{'subject_id'} );
                }
            }
            else {
                # RAISE NOTICE''wrong feature_relationship: 
                # gene->NO_transcript:object_id:%, subject_id:%'',
                # $_TD->{old}{'object_id'}, $_TD->{old}{'subject_id'};
            }
        }
        elsif ($f_type eq $f_type_transcript
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region )
        {

            $f_type_temp = $get_single_value->(
                qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                    . $_TD->{old}{'subject_id'}
                    . q[ and f.type_id=c.cvterm_id],
                'name'
            );
            if (   $f_type_temp eq $f_type_protein
                or $f_type_temp eq $f_type_exon )
            {
                my $fr_row
                    = $get_single_row->(
                    qq[SELECT * from feature_relationship where subject_id=]
                        . $_TD->{old}{'subject_id'}
                        . q[ and object_id<>$_TD->{old}{'object_id'}] );
                if ( not defined( $fr_row->{'object_id'} ) ) {

                    # RAISE NOTICE''delete this lonely exon/polypeptide:%'',
                    # $_TD->{old}{'subject_id'};
                    spi_exec_query( qq[delete from feature where feature_id=]
                            . $_TD->{old}{'subject_id'} );
                }
            }
            else {

                # RAISE NOTICE''wrong relationship:
                # transcript->NO_polypeptide/exon: objfeature:%,
                # subjfeature:%'',$_TD->{old}{'object_id'},
                # $_TD->{old}{'subject_id'};
            }
        }
    }

    # RAISE NOTICE ''leave fr_d ....'';
    return;
$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_relationship_fn_d() TO PUBLIC;

CREATE TRIGGER feature_relationship_tr_d BEFORE DELETE ON feature_relationship  for EACH ROW EXECUTE PROCEDURE feature_relationship_fn_d();

DROP TABLE trigger_log;
CREATE TABLE trigger_log(
   value   varchar(255) not null,
   timeaccessioned   timestamp not null default current_timestamp,
   table_name   varchar(50),
   id      int 
);

GRANT ALL ON TABLE trigger_log TO PUBLIC;


DROP TRIGGER feature_relationship_propagatename_tr_i ON feature_relationship;

CREATE OR REPLACE FUNCTION feature_relationship_propagatename_fn_i() RETURNS TRIGGER AS $$

    my $f_type_gene                 = 'gene';
    my $f_type_exon                 = 'exon';
    my $f_type_transcript           = 'mRNA';
    my $f_type_snoRNA               = 'snoRNA';
    my $f_type_ncRNA                = 'ncRNA';
    my $f_type_snRNA                = 'snRNA';
    my $f_type_tRNA                 = 'tRNA';
    my $f_type_promoter             = 'promoter';
    my $f_type_repeat_region        = 'repeat_region';
    my $f_type_miRNA                = 'miRNA';
    my $f_type_transposable_element = 'transposable_element';
    my $f_type_rRNA                 = 'rRNA';
    my $f_type_pseudo               = 'pseudogene';
    my $f_type_protein              = 'polypeptide';
    my $f_type_allele               = 'alleleof';
    my $c_name_synonym              = 'synonym';
    my $cv_cvname_synonym           = 'null';
    my $p_miniref                   = 'none';
    my $get_single_value            = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    my $prefix = $get_single_value->(
        qq[
        SELECT cp.value 
        FROM cvtermprop cp, cvterm, cv 
        WHERE cvterm.name = 'prefix' and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id and cv.name = 'apollo'],
        'value'
    );
    my $suffix = $get_single_value->(
        qq[
        SELECT cp.value 
        FROM cvtermprop cp, cvterm, cv 
        WHERE cvterm.name = 'suffix' 
        and cp.cvterm_id = cvterm.cvterm_id 
        and cvterm.cv_id = cv.cv_id 
        and cv.name = 'apollo'],
        'value'
    );

    my $p_id = $get_single_value->(
        qq[
        SELECT pub_id 
        from pub 
        where uniquename = '$p_miniref'], 'pub_id'
    );
    my $s_type_id = $get_single_value->(
        qq[
        SELECT cvterm_id 
        from cvterm c1, cv c2 
        where c1.name='$c_name_synonym' and c2.name='$cv_cvname_synonym' 
        and c1.cv_id=c2.cv_id], 'cvterm_id'
    );

    #RAISE NOTICE ''propagating names, prefix:%,
    #$suffix:%'',prefix,$suffix;

    #RAISE NOTICE ''enter fr_i, fr.object_id:%, fr.subject_id:%'',
    #$_TD->{new}{'object_id'}, $_TD->{new}{'subject_id'};
    my $f_type = $get_single_value->(
        qq[
        SELECT c.name 
        from feature f, cvterm c  
        where f.type_id=c.cvterm_id 
        and f.feature_id=] . $_TD->{new}{'object_id'} . q[], 'name'
    );

    my $f_name = $get_single_value->(
        qq[
        SELECT name 
        from feature 
        where feature_id =] . $_TD->{new}{'subject_id'}, 'name'
    );

    # OK, the thing having a child added is a gene
    if ( ( not defined($f_name) or $f_name =~ /$prefix.*temp/ )
        and $f_type eq $f_type_gene )
    {
        my $f_type_temp = $get_single_value->(
            qq[SELECT c.name from feature f, cvterm c where f.feature_id=]
                . $_TD->{new}{'subject_id'}
                . q[ and f.type_id=c.cvterm_id],
            'name'
        );
        if (   $f_type_temp eq $f_type_transcript
            or $f_type_temp eq $f_type_snoRNA
            or $f_type_temp eq $f_type_ncRNA
            or $f_type_temp eq $f_type_snRNA
            or $f_type_temp eq $f_type_tRNA
            or $f_type_temp eq $f_type_rRNA
            or $f_type_temp eq $f_type_miRNA
            or $f_type_temp eq $f_type_pseudo
            or $f_type_temp eq $f_type_transposable_element
            or $f_type_temp eq $f_type_promoter
            or $f_type_temp eq $f_type_repeat_region )
        {

            # Generate a new name based on the gene name
            # the name is like: genename-transcript#
            my $f_name_gene = $get_single_value->(
                qq[SELECT name from feature where feature_id=]
                    . $_TD->{new}{'object_id'} . q[],
                'name'
            );

# my $maxid = $get_single_value->( qq[ SELECT to_number(max(substring(name from (length(f_name_gene)+1+10))), '99999') FROM feature where name like f_name_gene||'-transcript%'],'to_number(max(substring(name');#
            my $c_cv_id = $get_single_value->(
                qq[
            SELECT cv_id 
            FROM cv WHERE name = 'Sequence Ontology Feature Annotation'],
                'cv_id'
            );
            my $fng_type_id = $get_single_value->(
                qq[
            SELECT cvterm_id 
            FROM cvterm 
            WHERE name = 'transcript' 
            AND cv_id = $c_cv_id], 'cvterm_id'
            );
            my $maxid = $get_single_value->(
                qq[
            SELECT count 
            FROM feature_namegenerator 
            WHERE name = '$f_name_gene' AND type_id = $fng_type_id], 'count'
            );
            if ( not defined($maxid) ) {
                $maxid = 1;
            }
            else {
                $maxid = $maxid + 1;
            }

            $f_name = $f_name_gene . '-transcript' . $maxid;

            # RAISE NOTICE''start to update feature, gene name:%,
            # new feature name:%'', $f_name_gene, $f_name;
            spi_exec_query(
                qq[UPDATE feature set name='$f_name' where feature_id=]
                    . $_TD->{new}{'subject_id'} );

            spi_exec_query(
                qq[
            DELETE 
            FROM feature_namegenerator 
            WHERE name = '$f_name_gene' AND type_id = $fng_type_id;]
            );
            spi_exec_query(
                qq[
            INSERT INTO feature_namegenerator (name,type_id,count) 
            VALUES ('$f_name_gene', $fng_type_id, $maxid);]
            );

            my $s_id = $get_single_value->(
                qq[
            SELECT synonym_id 
            from synonym 
            where name='$f_name' 
            and type_id=$s_type_id],
                'synonym_id'
            );

            if ( not defined $s_id ) {
                spi_exec_query(
                    qq[
                INSERT INTO synonym(name, synonym_sgml, type_id) 
                values('$f_name', '$f_name', $s_type_id);]
                );
                $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
            }

            # RAISE NOTICE ''start to insert feature_synonym:
            # synonym_id:%,feature_id:%,
            # pub_id:%'', $s_id, $_TD->{new}{'subject_id'}, $p_id;
            my $f_s_id = $get_single_value->(
                qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                    . $_TD->{new}{'subject_id'}
                    . q[ and synonym_id=$s_id and pub_id=$p_id],
                'feature_synonym_id'
            );
            if ( not defined $f_s_id ) {
                spi_exec_query(
                    qq[
                INSERT INTO feature_synonym
                (feature_id, synonym_id, pub_id, is_current) 
                values (]
                        . $_TD->{new}{'subject_id'}
                        . qq[, $s_id, $p_id, 'true');]
                );
            }
        }

        # here the thing having a child added is a second level thing
        # (eg, a transcript is getting an exon or protein)
    }
    elsif (
        ( not defined($f_name) or $f_name =~ /$prefix.*temp/ )
        and (  $f_type eq $f_type_transcript
            or $f_type eq $f_type_ncRNA
            or $f_type eq $f_type_snoRNA
            or $f_type eq $f_type_snRNA
            or $f_type eq $f_type_tRNA
            or $f_type eq $f_type_rRNA
            or $f_type eq $f_type_miRNA
            or $f_type eq $f_type_pseudo
            or $f_type eq $f_type_transposable_element
            or $f_type eq $f_type_promoter
            or $f_type eq $f_type_repeat_region )
        )
    {
        my $f_name_gene = $get_single_value->(
            qq[
            SELECT f.name 
            from feature f, feature_relationship fr, cvterm c 
            where f.feature_id=fr.object_id and fr.subject_id=]
                . $_TD->{new}{'object_id'}
                . q[ and f.type_id=c.cvterm_id and c.name=f_type_gene],
            'name'
        );
        my $f_type_temp = $get_single_value->(
            qq[
            SELECT c.name 
            from feature f, cvterm c 
            where f.feature_id=]
                . $_TD->{new}{'subject_id'} 
                . q[ and f.type_id=c.cvterm_id], 'name'
        );

        # Adding a protein to a transcript
        if ( $f_type_temp eq $f_type_protein ) {
            if ( defined $f_name_gene ) {
                my $f_row_p
                    = $get_single_row->(
                    qq[SELECT * from feature where feature_id=]
                        . $_TD->{new}{'subject_id'} );

                # Create a new name for this protein
                # (again repeating code in assign_names)
                my $c_cv_id = $get_single_value->(
                    qq[
                SELECT cv_id 
                FROM cv 
                WHERE name = 'Sequence Ontology'], 'cv_id'
                );
                my $fng_type_id = $get_single_value->(
                    qq[
                SELECT cvterm_id 
                FROM cvterm 
                WHERE name = '$f_type_protein' AND cv_id = $c_cv_id],
                    'cvterm_id'
                );
                my $maxid = $get_single_value->(
                    qq[
                SELECT count 
                FROM feature_namegenerator 
                WHERE name = '$f_name_gene' AND type_id = $fng_type_id],
                    'count'
                );
                if ( not defined($maxid) ) {
                    $maxid = 1;
                }
                else {
                    $maxid = $maxid + 1;
                }

                $f_name = $f_name_gene . '-' . $f_type_protein . $maxid;

# RAISE NOTICE'update name of polypeptide:% to new name:%',f_row_p.name, $f_name;
                spi_exec_query(
                    qq[
                UPDATE feature set name='$f_name' 
                where feature_id=] . $_TD->{new}{'subject_id'}
                );

                spi_exec_query(
                    qq[
                DELETE FROM feature_namegenerator
                WHERE name = '$f_name_gene' AND type_id = $fng_type_id;]
                );
                spi_exec_query(
                    qq[
                INSERT INTO feature_namegenerator (name,type_id,count) 
                VALUES ('$f_name_gene', $fng_type_id, $maxid);]
                );

                my $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
                if ( not defined($s_id) ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id);]
                    );
                    my $s_id = $get_single_value->(
                        qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id], 'synonym_id'
                    );
                }

                my $f_s_id = $get_single_value->(
                    qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                        . $f_row_p->{'feature_id'} 
                        . qq[and synonym_id=$s_id],
                    'feature_synonym_id'
                );
                if ( not defined $f_s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                            . $f_row_p->{'feature_id'}
                            . qq[, $s_id, $p_id, 'true');]
                    );
                }
            }
            else {

                # RAISE NOTICE'Couldnt find a gene to add this
                # polypeptide to (feature_id:%)', $_TD->{new}{'subject_id'} ;
            }

            # Adding an exon to a transcript
        }
        elsif ( $f_type_temp eq $f_type_exon ) {
            if ( defined $f_name_gene ) {
                my $f_row_e
                    = $get_single_row->(
                    qq[SELECT * from feature where feature_id=]
                        . $_TD->{new}{'subject_id'} );
                my $fl_row_e
                    = $get_single_row->(
                          qq[SELECT * from featureloc where feature_id =]
                        . $_TD->{new}{'subject_id'}
                        . q[ and rank=0] );
                if (   not defined( $fl_row_e->{'fmin'} )
                    or not defined( $fl_row_e->{'fmax'} ) )
                {

             # RAISE NOTICE'cant create exon name for feature_id %
             # since there is no featureloc entry', $_TD->{new}{'subject_id'};
                    return 'MODIFY';
                }
                else {
                    $f_name
                        = $f_name_gene . ':'
                        . $fl_row_e->{'fmin'} . '-'
                        . $fl_row_e->{'fmax'};
                }

                # RAISE NOTICE'exon new name:%', $f_name;
                spi_exec_query(
                    qq[UPDATE feature set name='$f_name' where feature_id=]
                        . $_TD->{new}{'subject_id'} );

                my $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$f_name' and type_id=$s_type_id],
                    'synonym_id'
                );
                if ( not defined $s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO synonym(name, synonym_sgml, type_id) 
                    values('$f_name', '$f_name', $s_type_id);]
                    );
                    my $s_id = $get_single_value->(
                        qq[
                    SELECT synonym_id 
                    from synonym 
                    where name='$f_name' and type_id=$s_type_id],
                        'synonym_id'
                    );
                }

                my $f_s_id = $get_single_value->(
                    qq[
                SELECT feature_synonym_id 
                from feature_synonym 
                where feature_id=]
                        . $f_row_e->{'feature_id'}
                        . qq[ and synonym_id=$s_id],
                    'feature_synonym_id'
                );
                if ( not defined $f_s_id ) {
                    spi_exec_query(
                        qq[
                    INSERT INTO feature_synonym
                    (feature_id, synonym_id, pub_id, is_current) 
                    values (]
                            . $f_row_e->{'feature_id'}
                            . qq[, $s_id, $p_id, 'true');]
                    );
                }
            }
            else {

                # RAISE NOTICE'Couldnt find a gene to add
                # this exon to (feature_id:%)',$_TD->{new}{'subject_id'};
            }
        }
    }
    else {

        # Nothing to do, the name is not null or containing temp
    }

    #RAISE NOTICE 'leave fr_i ....';
    return 'MODIFY';

$$ LANGUAGE plperl;

GRANT ALL ON FUNCTION feature_relationship_propagatename_fn_i() TO PUBLIC;

CREATE TRIGGER feature_relationship_propagatename_tr_i AFTER INSERT ON feature_relationship FOR EACH ROW EXECUTE PROCEDURE feature_relationship_propagatename_fn_i();


DROP TRIGGER feature_update_name_tr_u ON feature;

CREATE OR REPLACE FUNCTION feature_fn_u() RETURNS TRIGGER AS $$
    my $f_type_gene       = 'gene';
    my $p_miniref         = 'none';
    my $c_name_synonym    = 'synonym';
    my $cv_cvname_synonym = 'null';

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    if (    $_TD->{old}{'uniquename'} ne $_TD->{new}{'uniquename'}
        and $_TD->{old}{'uniquename'} !~ /temp/ )
    {

        # RAISE NOTICE'You may not change the uniquename of a feature';
        # RAISE NOTICE'if you feel you must, contact your database admin';
        return 'SKIP';
    }
    if ( $_TD->{old}{'name'} eq $_TD->{new}{'name'} ) {

        # Not updating name, so go ahead
        return;
    }

    # Fetch a few useful things
    my $s_type_id = $get_single_value->(
        qq[
        SELECT cvterm_id 
        from cvterm c1, cv c2 
        where c1.name='$c_name_synonym' and c2.name='$cv_cvname_synonym' 
        and c1.cv_id=c2.cv_id],
        'cvterm_id'
    );

    my $f_type = $get_single_value->(
        qq[
        SELECT cv.name 
        FROM feature f, cvterm cv 
        WHERE f.feature_id =]
            . $_TD->{old}{'feature_id'} 
            . q[ and f.type_id = cv.cvterm_id], 'name'
    );
    my $p_id = $get_single_value->(
        qq[
        SELECT pub_id 
        from pub 
        where uniquename = '$p_miniref'], 'pub_id'
    );

    #  IF $f_type <> $f_type_gene THEN
    #      #its not a gene, so go ahead
    #      #but insert the new name into the synonym table

    #On gene name update, we also update the gene inner synonym (ie himself)
    #so for all features, the inner synonym gets updated
    if ( defined( $_TD->{new}{'name'} ) ) {
        my $s_id = $get_single_value->(
            qq[
            SELECT synonym_id 
            from synonym 
            where name=']
                . $_TD->{new}{'name'} 
                . qq[' and type_id=$s_type_id], 'synonym_id'
        );
        if ( not defined($s_id) ) {
            spi_exec_query(
                qq[
                INSERT INTO synonym(name, synonym_sgml, type_id) 
                values(']
                    . $_TD->{new}{'name'} . qq[',']
                    . $_TD->{new}{'name'}
                    . qq[', $s_type_id);]
            );
            $s_id = $get_single_value->(
                qq[
                SELECT synonym_id 
                from synonym 
                where name=']
                    . $_TD->{new}{'name'} 
                    . qq[' and type_id=$s_type_id], 'synonym_id'
            );
        }
        my $f_s_id = $get_single_value->(
            qq[
            SELECT feature_synonym_id 
            from feature_synonym 
            where feature_id=]
                . $_TD->{new}{'feature_id'}
                . qq[ and synonym_id=$s_id and pub_id=$p_id],
            'feature_synonym_id'
        );
        if ( not defined($f_s_id) ) {
            spi_exec_query(
                qq[
                INSERT INTO feature_synonym
                (feature_id, synonym_id, pub_id, is_current) 
                values ($_TD->{new}{'feature_id'}, $s_id, $p_id, 'true');]
            );
        }
    }

    if ( $f_type ne $f_type_gene ) {

        #its not a gene, so go ahead
        return 'MODIFY';
    }

    #OK, so its a gene, and were changing the name...

    # For corectly handling alternate transcript of a gene,
    # we must add a distinct in order not to process the same
    # exon multiple times (exons are shared in chado)
    my $rv = spi_exec_query(
        qq[ 
        SELECT DISTINCT f.* 
        FROM feature f, get_sub_feature_ids(]
            . $_TD->{old}{'feature_id'} . qq[) ch 
        WHERE f.feature_id = ch.feature_id]
    );
    foreach my $f_row ( @{ $rv->{q[rows]} || [] } ) {

#This one process the transcripts and the proteins
#      IF f_row.name LIKE $_TD->{old}{'name'}||'-%' THEN
#          my $name_suffix = $get_single_value->(
#qq[
#SELECT substring(name from $_TD->{old}{'name'}||'(-.+)')
#FROM feature where feature_id = f_row.feature_id],'substring(name');#LOOK AT
#          $child_name = $_TD->{new}{'name'}||name_suffix;
#          UPDATE feature SET name = $child_name WHERE feature_id = f_row.feature_id;

#          #my $s_id = $get_single_value->( qq[
#          #SELECT synonym_id from synonym where name=$child_name and type_id=$s_type_id],'synonym_id');#LOOK AT
#          if (not defined($s_id)){
#              INSERT INTO synonym(name, synonym_sgml, type_id) values($child_name, $child_name, $s_type_id);
#              my $s_id = $get_single_value->(
#qq[SELECT synonym_id from synonym where name=$child_name and type_id=$s_type_id],'synonym_id');#LOOK AT
#          }
#          my $f_s_id = $get_single_value->(
#qq[SELECT feature_synonym_id from feature_synonym where feature_id=f_row.feature_id and synonym_id=s_id and pub_id=$p_id],'feature_synonym_id');#LOOK AT
#          if (not defined($f_s_id)){
#              INSERT INTO feature_synonym(feature_id, synonym_id, pub_id, is_current) values (f_row.feature_id, $s_id, $p_id, 'true');
#          }
#      END IF

        #And this one process the exons (of form gene_name:something)
        #Be careful, this could lead to problems with some autogenerated
        #split names which for flybase are also of the form gene_name:#)
        #TODO : move this regexp to something like /gene_name:\d-\d/
        if ( $f_row->{'name'} =~ $_TD->{old}{'name'} . ':' ) {
            my $name_suffix = '';
            my $old_name    = $_TD->{old}{'name'};
            if ( $f_row->{'name'} =~ /$old_name(:.+)/ ) {
                $name_suffix = $1;
            }

            my $child_name = $_TD->{new}{'name'} . $name_suffix;

# RAISE NOTICE'feature_id:%, name:% , new name : %, namesuffix:%, geneName:%', f_row.feature_id, f_row.name, $child_name,name_suffix, $_TD->{new}{'name'} ;
            spi_exec_query(
                qq[ 
                UPDATE feature SET name = '$child_name' 
                WHERE feature_id = ] . $f_row->{'feature_id'}
            );

            my $s_id = $get_single_value->(
                qq[
            SELECT synonym_id 
            from synonym 
            where name='$child_name' and type_id=$s_type_id], 'synonym_id'
            );
            if ( not defined($s_id) ) {
                spi_exec_query(
                    qq[
                INSERT INTO synonym(name, synonym_sgml, type_id) 
                values('$child_name', '$child_name', $s_type_id);]
                );
                $s_id = $get_single_value->(
                    qq[
                SELECT synonym_id 
                from synonym 
                where name='$child_name' and type_id=$s_type_id], 'synonym_id'
                );
            }
            my $f_s_id = $get_single_value->(
                qq[SELECT feature_synonym_id from feature_synonym where feature_id=]
                    . $f_row->{'feature_id'}
                    . qq[ and synonym_id=$s_id and pub_id=$p_id],
                'feature_synonym_id'
            );    #LOOK AT
            if ( not defined($f_s_id) ) {
                spi_exec_query(
                    qq[
                INSERT INTO feature_synonym
                (feature_id, synonym_id, pub_id, is_current) 
                values (]
                        . $f_row->{'feature_id'} . qq[, $s_id, $p_id, 'true')]
                );
            }

        }

    }

    return 'MODIFY';
$$ LANGUAGE plperl;

CREATE TRIGGER feature_update_name_tr_u BEFORE UPDATE ON feature FOR EACH ROW EXECUTE PROCEDURE feature_fn_u();

-- function to fascilitate gene merges
-- returns the uniquename of the merged gene
--WARNING: COMPLETELY UNTESTED
CREATE OR REPLACE FUNCTION apollo_merge(varchar, varchar) RETURNS varchar AS $$
{

    my $f1_uniquename = shift;
    my $f2_uniquename = shift;
    my $f_type_gene   = 'gene';

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    my $get_single_row = sub {
        my $sql_str = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0];
    };

    #Check that they are both genes
    my $f1_type = $get_single_value->(
        qq[
        SELECT c.name 
        FROM feature f, cvterm c 
        WHERE f.uniquename = '$f1_uniquename' and f.type_id    = c.cvterm_id],
        'name'
    );
    my $f2_type = $get_single_value->(
        qq[
        SELECT c.name 
        FROM feature f, cvterm c 
        WHERE f.uniquename = '$f2_uniquename' and f.type_id    = c.cvterm_id],
        'name'
    );

    if ( $f1_type ne $f_type_gene or $f2_type ne $f_type_gene ) {

        # RAISE NOTICE'The uniquenames for the features 
        # provided must be those of genes';
        return;
    }

    # check that they come from the same organism
    my $f1_organism_id = $get_single_value->(
        qq[
        SELECT 
        FROM feature 
        WHERE uniquename='$f1_uniquename'], 'organism_id'
    );
    my $f2_organism_id = $get_single_value->(
        qq[
        SELECT 
        FROM feature 
        WHERE uniquename='$f2_uniquename'], 'organism_id'
    );

    if ( $f1_organism_id <=> $f2_organism_id ) {

        # RAISE NOTICE'The merged genes must come from the same organism';
        return;
    }

    my $c_cvterm_id = $get_single_value->(
        qq[
        SELECT type_id 
        FROM feature 
        WHERE uniquename = '$f1_uniquename'], 'type_id'
    );

    my $f_uniquename = $get_single_value->(
        q[SELECT next_uniquename FROM next_uniquename()],
        'next_uniquename'
    );

    # create the new gene
    spi_exec_query(
        qq[
        INSERT INTO feature (organism_id, uniquename, type_id)
        VALUES  ($f1_organism_id, '$f_uniquename', $c_cvterm_id);]
    );

    my $f_id = $get_single_value->(
        qq[
        SELECT feature_id 
        FROM feature 
        WHERE uniquename  = '$f_uniquename' 
        and organism_id = f_organism_id 
        and type_id = $c_cvterm_id], 'feature_id'
    );

    my $f1_id = $get_single_value->(
        qq[
        SELECT feature_id 
        FROM feature 
        WHERE uniquename  = '$f1_uniquename' 
        and organism_id = $f1_organism_id 
        and type_id = $c_cvterm_id], 'feature_id'
    );

    my $f2_id = $get_single_value->(
        qq[
        SELECT feature_id 
        FROM feature 
        WHERE uniquename  = '$f2_uniquename' 
        and organism_id = $f1_organism_id 
        and type_id = $c_cvterm_id], 'feature_id'
    );

    # add synonyms to new feature for all of the synonyms of the old feature

    my $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_synonym
        WHERE feature_id = $f1_id or
              feature_id = $f2_id 
        ]
    );
    foreach my $fs_row ( @{ $rv->{q[rows]} || [] } ) {

        spi_exec_query(
            qq[
      INSERT INTO feature_synonym (feature_id, synonym_id)
            VALUES ($f_id, ] . $fs_row->{'synonym_id'} . qq[);]
        );
    }

    # copy dbxref, featureprop, cvterms, pubs to the new gene
    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_dbxref 
        WHERE feature_id = $f1_id or
              feature_id = $f2_id 
        ]
    );
    foreach my $fd_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES ($f_id, ] . $fd_row->{'dbxref_id'} . qq[, 0);]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM featureprop 
        WHERE feature_id = $f1_id or
              feature_id = $f2_id 
        ]
    );
    foreach my $fp_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES ($f_id,]
                . $fp_row->{'type_id'} . qq[,]
                . $fp_row->{'value'} . qq[,]
                . $fp_row->{'rank'} . qq[);]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_cvterm 
        WHERE feature_id = $f1_id or
              feature_id = $f2_id 
        ]
    );
    foreach my $fc_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES ($f_id,]
                . $fc_row->{'cvterm_id'} . qq[,]
                . $fc_row->{'pub_id'} . qq[,]
                . $fc_row->{'is_not'} . qq[);]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_pub 
        WHERE feature_id = $f1_id or
              feature_id = $f2_id 
        ]
    );
    foreach my $fpub_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO feature_pub (feature_id,pub_id)
            VALUES ($f_id,] . $fpub_row->{'pub_id'} . qq[);]
        );
    }

    # delete featureloc entries for old genes
    spi_exec_query(
        qq[
        DELETE FROM featureloc WHERE feature_id=$f1_id; ]
    );
    spi_exec_query(
        qq[
        DELETE FROM featureloc WHERE feature_id=$f2_id; ]
    );

    # mark old gene features as obsolete
    spi_exec_query(
        qq[
        UPDATE feature SET is_obsolete=true WHERE feature_id=$f1_id; ]
    );
    spi_exec_query(
        qq[
        UPDATE feature SET is_obsolete=true WHERE feature_id=$f2_id; ]
    );

  # note in either feature_relationship or featureprop the origin of this gene

    return $f_uniquename;
}
$$ LANGUAGE plperl; 


-- function to fascilitate gene splits
-- Takes three arguments:
--   -the feature_id of the old gene that was split
--   -the feature_id of the new genes
--WARNING: COMPLETELY UNTESTED

CREATE or REPLACE FUNCTION apollo_split(int,int,int) RETURNS int AS $$
{
    my $f_id        = shift;
    my $f1_id       = shift;
    my $f2_id       = shift;
    my $f_type_gene = 'gene';

    my $get_single_value = sub {
        my $sql_str     = shift;
        my $column_name = shift;

        my $rv          = spi_exec_query($sql_str);
        my $num_of_rows = $rv->{processed};
        unless ($num_of_rows) {
            return undef;
        }
        return $rv->{q[rows]}[0]{$column_name};
    };

    # do some error checking; first, make sure they are all genes
    my $f_type = $get_single_value->(
        qq[
        SELECT c.name 
        FROM feature f, cvterm c 
        WHERE f.feature_id = $f_id 
        and f.type_id    = c.cvterm_id], 'name'
    );    #LOOK AT

    if ( $f_type ne $f_type_gene ) {

        # RAISE NOTICE'The uniquename for the feature
        # provided must be that of a gene';
        return;
    }

    # more error checking: are they all from the same organism?
    my $f_organism_id = $get_single_value->(
        qq[
        SELECT organism_id 
        FROM feature 
        WHERE feature_id = $f_id], 'organism_id'
    );    #LOOK AT
    my $f1_organism_id = $get_single_value->(
        qq[
        SELECT organism_id 
        FROM feature 
        WHERE feature_id = $f1_id], 'organism_id'
    );
    my $f2_organism_id = $get_single_value->(
        qq[
        SELECT organism_id 
        FROM feature 
        WHERE feature_id = $f2_id], 'organism_id'
    );

    if (   $f_organism_id <=> $f1_organism_id
        or $f_organism_id <=> $f2_organism_id )
    {

        # RAISE NOTICE'The new gene and the old genes
        # need to come from the same organism';
        return;
    }

    # add synonyms to new feature for all of the synonyms of the old feature
    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_synonym
        WHERE feature_id = $f_id 
        ]
    );
    foreach my $fs_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO feature_synonym (feature_id, synonym_id, pub_id)
            VALUES ($f1_id, ]
                . $fs_row->{'synonym_id'} . qq[, ]
                . $fs_row->{'pub_id'} . qq[);]
        );
        spi_exec_query(
            qq[
      INSERT INTO feature_synonym (feature_id, synonym_id, pub_id)
            VALUES ($f2_id, ]
                . $fs_row->{'synonym_id'} . qq[, ]
                . $fs_row->{'pub_id'} . qq[);]
        );
    }

    # copy dbxref, featureprop, cvterms, pubs to the new gene
    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_dbxref
        WHERE feature_id = $f_id 
        ]
    );
    foreach my $fd_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES ($f1_id, ] . $fd_row->{'dbxref_id'} . qq[, 0);]
        );
        spi_exec_query(
            qq[
      INSERT INTO feature_dbxref (feature_id,dbxref_id,is_current)
            VALUES ($f2_id, ] . $fd_row->{'dbxref_id'} . qq[, 0);]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM featureprop
        WHERE feature_id = $f_id 
        ]
    );
    foreach my $fp_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
            INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES ($f1_id,]
                . $fp_row->{'type_id'} . qq[,]
                . $fp_row->{'value'} . qq[,]
                . $fp_row->{'rank'} . qq[);]
        );
        spi_exec_query(
            qq[
            INSERT INTO featureprop (feature_id,type_id,value,rank)
            VALUES ($f2_id,]
                . $fp_row->{'type_id'} . qq[,]
                . $fp_row->{'value'} . qq[,]
                . $fp_row->{'rank)'} . qq[;]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_cvterm
        WHERE feature_id = $f_id 
        ]
    );
    foreach my $fc_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
            INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES ($f1_id,]
                . $fc_row->{'cvterm_id'} . qq[,]
                . $fc_row->{'pub_id'} . qq[,]
                . $fc_row->{'is_not'} . qq[);]
        );
        spi_exec_query(
            qq[
            INSERT INTO feature_cvterm (feature_id,cvterm_id,pub_id,is_not)
            VALUES ($f2_id,]
                . $fc_row->{'cvterm_id'} . qq[,]
                . $fc_row->{'pub_id'} . qq[,]
                . $fc_row->{'is_not'} . qq[);]
        );
    }

    $rv = spi_exec_query(
        qq[
        SELECT * FROM feature_pub
        WHERE feature_id = $f_id 
        ]
    );
    foreach my $fpub_row ( @{ $rv->{q[rows]} || [] } ) {
        spi_exec_query(
            qq[
            INSERT INTO feature_pub (feature_id,pub_id)
            VALUES ($f1_id,] . $fpub_row->{'pub_id'} . qq[);]
        );
        spi_exec_query(
            qq[
            INSERT INTO feature_pub (feature_id,pub_id)
            VALUES ($f2_id,] . $fpub_row->{'pub_id'} . qq[);]
        );
    }

    # delete featureloc entries for old genes
    spi_exec_query(
        qq[
        DELETE FROM featureloc WHERE feature_id=$f_id;]
    );

    # mark old gene features as obsolete
    spi_exec_query(
        qq[
            UPDATE feature SET is_obsolete=true WHERE feature_id=$f_id;]
    );

  # note in either feature_relationship or featureprop the origin of this gene

    return 1;
}
$$ LANGUAGE plperl;

