## $Id: companalysis.sql,v 1.10 2002-11-20 18:45:02 cmungall Exp $

# an analysis is a particular execution of a computational analysis;
# it may be a blast of one sequence against another, or an all by all
# blast, or a different kind of analysis altogether.
# it is a single unit of computation - if different blast runs
# were instantiated over differnet query sequences, there would
# be multiple entries here.
#
# name: 
#   a way of grouping analyses. this should be a handy
#   short identifier that can help people find an analysis they
#   want. for instance "tRNAscan", "cDNA", "FlyPep", "SwissProt"
#   it should not be assumed to be unique. for instance, there may
#   be lots of seperate analyses done against a cDNA database.
#
# program: 
#   e.g. blastx, blastp, sim4, genscan
#
# programversion:
#   e.g. TBLASTX 2.0MP-WashU [09-Nov-2000]
#
# algorithm:
#   e.g. blast
#
# sourcename: 
#   e.g. cDNA, SwissProt
#
# queryfeature_id:
#   the sequence that was used as the query sequence can be
#   optionally included via queryfeature_id - even though this
#   is redundant with the tables below. this can still
#   be useful - for instance, we may have an analysis that blasts
#   contigs against a database. we may then transform those hits
#   into global coordinates; it may be useful to keep a record
#   of which contig was blasted as the query.
#
#
# MAPPING (bioperl): maps to Bio::Search::Result::ResultI

#
# sourceuri: 
#   This is an optional permanent URL/URI for the source of the
#   analysis. The idea is that someone could recreate the analysis
#   directly by going to this URI and fetching the source data
#   (eg the blast database, or the training model).

create table analysis (
    analysis_id serial not null,
    primary key (analysis_id),
    name varchar(255),
    description text,
    program varchar(255) not null,
    programversion varchar(255) not null,
    algorithm varchar(255),
    sourcename varchar(255),
    sourceversion varchar(255),
    sourceuri text,
    queryfeature_id int,
    foreign key (queryfeature_id) references feature (feature_id),

    timeentered timestamp not null default current_timestamp,
    timelastmod timestamp not null default current_timestamp
);

# analyses can have various properties attached - eg the parameters
# used in running a blast
create table analysisprop (
    analysis_id int not null,
    foreign key (analysis_id) references analysis (analysis_id),
    pkey_id int not null,
    foreign key (pkey_id) references cvterm (cvterm_id),
    pval text,

    timeentered timestamp not null default current_timestamp,
    timelastmod timestamp not null default current_timestamp
);


# computational analyses generate features (eg genscan generates
# transcripts and exons; sim4 alignments generate transcripts and
# exons; blastx generates CDS/ORFs and coding exons; VISTA generates
# syntenic-region features; interpro generates protein structure
# features). These features have two important
# characteristics - they are scored, and they need to be grouped
# together (eg in the case of alignments). The scoredset table
# is used to represent this grouping.
#
# score is not an attribute of the feature itself, it is an
# attribute of the set, which is why it is in this table.
# 
# do a natural join between scoredset, scoredset_feature (see below)
# and feature to get the grouping relationship.
#
# example scoredsets can represent:
#
#  Blast hits - in which case they group two features together
#  Blast HSPs - in which case they group two features together
#
#  Genscan exons - in which case they hold one feature
#  Genscan transcripts - in which case they hold one feature
#
#  Clustal sets - in which case they group N protein features together
#  Clustal blocks - in which case they group N sub-protein features together
#
#  Note that the main biological information goes in the feature and
#  feature_relationship tables. 
#
#  Example: For instance, aligning genomic to cDNA
#  would give one transcript containing n exons located on the genomic sequence,
#  (these would be anonymous features, they have no name or dbxref), and one
#  transcript containing n exons for the subject alignment. the subject
#  transcript would have a name and dbxref sourced from the FASTA dataset used,
#  and would have no location. The subject exons would be anonymous, and would
#  be located relative to the transcript.
#  There would be one scoredset, representing the hit, linking the two
#  transcripts, and n scoredsets, representing the HSPs, linking the exons.
#  Note that the scoredset table can be ignored, and we can still fetch
#  transcripts and exons from the db as normal features.
#
#  analysis_id:
#    scoredsets are grouped into analyses
#
#  rawscore:
#    this is the native score generated by the program; for example,
#    the bitscore generated by blast, sim4 or genscan scores.
#    one should not assume that high is necessarily better than low.
#
#  normscore:
#    this is the rawscore but semi-normalized. complete normalization
#    to allow comparison of features generated by different programs
#    would be nice but too difficult. instead the normalization should
#    strive to enforce the following semantics:
#
#    * normscores are floating point numbers >= 0
#    * high normscores are better than low one.
#
#    for most programs, it would be sufficient to make the normscore
#    the same as this rawscore, providing these semantics are
#    satisfied.
#
#  significance:
#    this is some kind of expectation or probability metric,
#    representing the probability that the scoredset would appear
#    randomly given the model.
#    as such, any program or person querying this table can assume
#    the following semantics:
#     * 0 <= significance <= n, where n is a positive number, theoretically
#       unbounded but unlikely to be more than 10
#     * low numbers are better than high numbers.
#
#  note that these 3 metrics do not cover the full range of scores
#  possible; it would be undesirable to list every score possible, as
#  this should be kept extensible. instead, for non-standard scores, use
#  the scoredsetprop table.
#
#  parentscoredset_id:
#    scoredsets are arranged hierarchically; each scoredset points to
#    its parents (e.g. HSPs point to Hits). The top level scoredset (eg Hit)
#    is null. note that this is usually redundant information, as the hierarchy
#    is obtainable from the feature graph of the computed features. however it
#    is included for two reasons: convenience of querying (at a possible risk
#    of redundancy), and to allow for hierarchical clustering - for instance,
#    representing a tree where the root nodes are proteins, and the proteins are
#    grouped into a tree. Perhaps this is too limiting; for example, it does
#    not allow unrooted trees. There is a case for removing this field
#    altogether and dealing with trees in a seperate table.
#
create table scoredset (
    scoredset_id serial not null,
    primary key (scoredset_id),
    analysis_id int,
    foreign key (analysis_id) references analysis (analysis_id),

    parentscoredset_id int,
    foreign key (parentscoredset_id) references scoredset (scoredset_id),

    rawscore double precision,
    normscore double precision,
    significance double precision,

    timeentered timestamp not null default current_timestamp
);

# links a scoredset to the contained features
#
# alignment is a string representing the residue substitutions
# that need to be made to map to other features in the set. this
# should only be instantiated for leaf features in the feature
# graph (for example, with HSP-contained features, but not 
# hit-contained features)
#
# set  align feature.residues
# 1    A-T-G  ATG
# 2    A-TCG  ATCG
# 3    AGTC-  AGTC
#
# this can be used in conjunction with the feature locations
# to build a residue to residue mapping betwen features
#
# OPEN QUESTION: should we make the constraints tighter,
# and force unique(feature_id)? - this makes sure every
# computed feature comes from one scoredset only
#
create table scoredset_feature (
    scoredset_feature_id serial not null,
    primary key (scoredset_feature_id),

    scoredset_id int not null,
    foreign key (scoredset_id) references scoredset (scoredset_id),

    feature_id int not null,
    foreign key (feature_id) references feature (feature_id),

    alignment text,

    unique (scoredset_id, feature_id)
);

# scoredsets can have various properties attached - eg non-standard
# scoring metrics. see the scoredset table for a discussion of
# the 3 scoring metrics that should NOT be included in here

create table scoredsetprop (
    scoredset_id int not null,
    foreign key (scoredset_id) references scoredset (scoredset_id),
    pkey_id int not null,
    foreign key (pkey_id) references cvterm (cvterm_id),
    pval text,

    timeentered timestamp not null default current_timestamp,
    timelastmod timestamp not null default current_timestamp
);

# OPEN QUESTION:
# should variation features (eg SNPs, P insertions, aberrations, deletions,...)
# be treated as standard features located on the wild genome (with residues
# equivalent to the residues in the mutant - ie location + residues gives the
# edit instructions to go wild->mutant), 
# OR should we use the tables above (even though it isn't scored) to link
# the variation features in each genome (wild, mutants).
# The former is better and we are not instantiating mutant genomes, we just
# want edits. the latter is better if we are instantiating mutant genomes,
# as we want to group the features together.
# same pattern as gene table: the gene table is a set of similar features
# just like a scoredset! exactly the same pattern. in this pattern, main
# data goes in wildtype, mutant can be inferred. same for snp?
# not quite the same as an alignment; eg for P insert
#
# mut  -----------------=====--------------
#                       \   /
#                        \ /
#                         V
#                         |
# wild -------------------+----------------
#
# not really an alignment between two genomes; better to represent as
# P insertion feature on wild, with P elt sequence, and if we instantiate
# mut, as P elt (eg just like transposons in wild); then represent set.
