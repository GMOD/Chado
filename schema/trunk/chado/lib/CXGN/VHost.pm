
=head1 NAME

CXGN::VHost

=head1 DESCRIPTION

This class is used by
sgn-tools/systems/vhost_config.pl. vhost_config.pl creates one of
these for each virtual host it is setting up. This is an class which
knows how to create host configuration objects and extract data from
those objects. It can use that data to give apache write permissions
to certain directories and to run make on other directories. It also
can spit out an apache vhost configuration stanza into a file. You
will need to create and use subclasses of this class if your vhost has
aliases, rewrite rules, access controls, etc. You can add these to
your overridden version of apache_config(), which is a function that
returns a big string of whatever vhost-specific configuration text you
need to add to the text generated by this module.

=head1 OBJECT METHODS

=head2 new

Create a new object. Do not use this directly; your subclass's new()
should call it instead.

=head2 chown_dirs

If apache_user and apache_writable_dirs are set in your configuration
files (for an example, see CXGN::VHost::SGN.HostConf.default) this
method will chown those dirs to apache.

=head2 chmod_dirs

If chmod_dirs are set in your configuration files, this method will
changes these directories so they are executable and group-writable
(775).

=head2 make_dirs

If make_dirs are set in your configuration files, this method will go
into those directories and run 'make -k'.

=head2 generate_apache_config_file

Print an apache configuration stanza to a file which is sent in.

=head2 apache_config

You will probably want to subclass this module and override this
function. See CXGN::VHost::SGN.pm for an example.

=head2 print_warning

This is used internally to print out warnings in a consistent
format. Your subclass should avoid calling die because when this
script is run, what we are trying to do is start apache! It is usually
better to start apache incorrectly that not start it at all.

=head2 get_conf

Return the value found in the vhost configuration file(s), or, when
necessary value retrieved from the environment.

=head1 MORE INFORMATION

For a better explanation of how these objects are used, see the
perldoc in the script which uses them:
sgn-tools/systems/vhost_config.pl.

=head1 AUTHOR

john binns - John Binns <zombieite@gmail.com>

=cut

package CXGN::VHost;

use strict;
use CXGN::Configuration;
use Carp;

use File::Basename;
use File::Spec;

use CXGN::Tools::List qw/distinct/;

sub new {
    my $class = shift;
    my ($params) = @_;
    $params ||= {};
    ref $params eq 'HASH'
      or confess "attempt to pass non-hashref options to CXGN::VHost::new";
    my $self = bless( $params, $class );

    # grab some data from environmental variables, since it is not
    # always sent in, and not all of it is can be found in the vhost
    # config files, as it may be set in All.MetaHostConf.default or
    # All.MetaHostConf instead
    $self->{vhost_config}->{project_name} = $self->{project_name} ||=
      $ENV{PROJECT_NAME};
    $self->{vhost_config}->{servername} = $self->{servername} ||=
      $ENV{SERVERNAME};
    $self->{vhost_config}->{basepath} = $self->{basepath} ||= $ENV{BASEPATH};
    $self->{vhost_config}->{perllib_path} = $self->{perllib_path} ||=
      $ENV{PERL5LIB};
    $self->{vhost_config}->{production_server} = $self->{production_server};

    unless ( defined( $self->{vhost_config}->{production_server} ) ) {
        $self->{vhost_config}->{production_server} = $ENV{PRODUCTION_SERVER};
    }
    # this can be zero so we have to check if it is DEFINED rather
    # than simply if it is "true" before discarding its value this is
    # the reverse order of precedence of the config files. every file
    # that is visited can overwrite the data from previous files.

    my @conf_file_locations =
      (
       (map File::Spec->catdir($_,qw!CXGN Configuration VHost!,'Default.HostConf.default'), reverse @INC),
       "/etc/cxgn/Default.HostConf",
      );

    #if we have a project name sent in, we can look further for more
    #detailed configuration files as well, using the project name as a
    #filename
    if ( $self->{vhost_config}->{project_name}
	 and $self->{vhost_config}->{project_name} ne 'Default' )
    {
        push @conf_file_locations,
	      ( (map File::Spec->catdir($_,qw! CXGN Configuration VHost !,"$self->{vhost_config}->{project_name}.HostConf.default"), reverse @INC),
		"/etc/cxgn/$self->{vhost_config}->{project_name}.HostConf",
	      );
    }

    #use Data::Dumper;
    #die Dumper(\@conf_file_locations,$self->{vhost_config});

    $self->{conf_object} = CXGN::Configuration->new(@conf_file_locations);
    return $self;
}

# resolve relative directories (starting with ./) relative to the document root
sub _resolve_relative_dir {
  my ($self,$dir) = @_;
  return $dir if -d $dir;

  my $basepath = $self->{basepath}
    or die "no basepath defined!";
  my $docroot = $self->{conf_object}->get_conf('document_root_subdir')
    or die "no document_root_subdir defined!";
  if( $dir =~ s/^\.+// ) {
    return File::Spec->catdir($basepath,$docroot,$dir);
  }

  return $dir;
}

sub chown_dirs {
  my $self = shift;

  my    ( $apache_user, $apache_group,  $apache_dirs          )
    = map $self->{conf_object}->get_conf($_),
      qw(  apache_user   apache_group    apache_writable_dirs );

  if ( $apache_dirs ) {
    $apache_user or die "must have an apache_user defined!";
    $apache_group or die "must have an apache_user defined!";

    my @dirs = ref $apache_dirs eq 'ARRAY' ? @$apache_dirs
             :                               ($apache_dirs);

    #also, don't forget to include the log dir(s), apache needs to write to them
    push @dirs, map {
	my $logfile = $self->{conf_object}->get_conf($_);
	my (undef,$logdir) = fileparse( $logfile );
	my $basepath = $self->{basepath}
	    or die "no basepath defined!";
	File::Spec->catdir( $basepath, $logdir );
    } 'error_log', 'access_log';

    #resolve any directories that begin with ./, which is relative to the docroot
    @dirs = distinct map $self->_resolve_relative_dir($_), @dirs;

    for my $dir (@dirs) {
	unless( -d $dir ) {
	    $self->print_warning("directory $dir not found, skipping chown");
	    next;
	}
	my $cmd =
	    "find $dir ! -wholename '*/.svn*' -exec chown $apache_user:$apache_group \{\} ';'";
	print "$cmd\n";
	system($cmd);
	if ($?) {
	    $self->print_warning(
		"Could not do '$cmd'. Note: this script must be run as root."
	    );
	}
    }
  }
}

sub chmod_dirs {
    my $self = shift;
    if ( $self->{conf_object}->get_conf('chmod_dirs') ) {
        my @dirs = map $self->_resolve_relative_dir($_), @{ $self->{conf_object}->get_conf_arrayref('chmod_dirs') };
        for my $dir (@dirs) {
	    unless( -d $dir ) {
		$self->print_warning("directory $dir not found, skipping chmod");
		next;
	    }
            my $cmd =
              "find $dir ! -wholename '*/.svn*' -exec chmod 775 \{\} ';'";
            print "$cmd\n";
            system($cmd);
            if ($?) {
                $self->print_warning(
"Could not do '$cmd'. Note: this script must be run as root."
                );
            }
        }
    }
}

sub make_dirs {
    my $self = shift;
    if ( $self->{conf_object}->get_conf('make_dirs') ) {
        my @dirs = @{ $self->{conf_object}->get_conf_arrayref('make_dirs') };
        for my $dir (@dirs) {
            my $cmd = "cd $dir; make -k";
            print "$cmd\n";
            system($cmd);
            if ($?) {
                $self->print_warning(
"Could not do (all of) '$cmd'. This is not usually a problem."
                );
            }
        }
    }
}

sub generate_apache_config_file {
    croak 'this method is abstract!';
}


sub apache_config {
    return
      ''
      ; #this method is meant to be overridden in your subclass if you need it. you can use this method to return a string of whatever else you would like to add to your virtual host configuration.
}

sub test_config {
    my $self = shift;

    #check for presence of required settings
    foreach my $key (qw/ project_name
			 servername
			 basepath
			 perllib_path
			 production_server
			 /
		     ) {

	unless ( defined $self->{vhost_config}->{$key} ) {
	    $self->print_warning("No $key given; unable to create vhost object.");
	    return 0;
	}
    }

    #make sure we can create a configuration object
    my $conf;
    unless ( $conf = $self->{conf_object} ) {
        $self->print_warning(
"Unable to create configuration object for '$self->{vhost_config}->{project_name}'. This vhost object cannot be created."
        );
        return 0;
    }


    #now run any test we can think of which might catch a problem before it happens.

    # check basepath
    my $basepath = $self->{basepath};
    unless ( -d ($basepath) ) {
        $self->print_warning("Basepath '$basepath' not found.");
        return 0;
    }

    # check perllib path
    my $perllib_path = $self->{perllib_path};
    unless ( -d ($perllib_path) ) {
        $self->print_warning("Perllib path '$perllib_path' not found.");
        return 0;
    }

    # check document root
    my $docroot = $conf->get_conf('document_root_subdir');
    unless ( -d ( $basepath . $docroot ) ) {
        $self->print_warning("Document root '$basepath$docroot' not found.");
        return 0;
    }

    # check executables subdir
    my $executable_subdir = $conf->get_conf('executable_subdir');
    if ($executable_subdir) {
        unless ( -d ( $basepath . $executable_subdir ) ) {
            $self->print_warning(
                "Executable directory '$basepath$executable_subdir' not found."
            );
            return 0;
        }
    }

    my $data_shared_website_path = $conf->get_conf('data_shared_website_path');
    if ($data_shared_website_path) {
        unless ( -d ($data_shared_website_path) ) {
            $self->print_warning(
"Data shared website path '$data_shared_website_path' not found. Attempting configuration anyway."
            );
        }
    }

    my $rewrite_log = $conf->get_conf('rewrite_log');
    if ($rewrite_log) {
        unless ( -f ( $basepath . $rewrite_log ) ) {
            $self->print_warning(
"Rewrite log file '$basepath$rewrite_log' not found. Apache will attempt to create this file. If apache cannot create this file, it WILL FAIL TO START."
            );
        }
    }

    return 1;    #all tests passed
}

sub print_warning {
    my $self = shift;
    my ($message) = @_;
    my $WARNING_HEADER =
      "***** $self->{vhost_config}->{project_name} WARNING *****\n";
    my $WARNING_FOOTER = "";
    print "$WARNING_HEADER$message\n$WARNING_FOOTER";
}

sub get_conf {
    shift->_get_conf( 'get_conf', @_ );
}

sub get_conf_arrayref {
    shift->_get_conf( 'get_conf_arrayref', @_ );
}

sub _get_conf {
    my $self               = shift;
    my $func               = shift;
    my ($requested_config) = @_;
    unless ($requested_config) {
        Carp::carp("CXGN::Configuration::VHost: no configuration requested");
        return;
    }

    # we hold some configuration values in this object--the ones which
    # are gathered from environmental variables
    if ( defined( $self->{vhost_config}->{$requested_config} ) ) {
        return $self->{vhost_config}->{$requested_config};
    }

    # all other configuration values are found in the conf object,
    # which gathers them from the configuration files
    else {
        return $self->{conf_object}->$func($requested_config);
    }
}


# no arguments.  returns a piece of text containing a <VirtualHost>
# block for a vhost that does nothing but direct requests for the
# aliases
sub _make_aliases_vhost {
    my ( $self ) = @_;

    # serveraliases might be undefined, and that's OK
    no warnings 'uninitialized';

    # return empty string if we don't have serveraliases
    return '' unless $self->{serveraliases} ne 'NONE';


    my ( $alias1, @aliases ) = split ',', $self->{serveraliases};
    my $other_aliases = join "\n", map "    ServerAlias $_", @aliases;
    return <<EOT;
<VirtualHost *:80>
    ServerName $alias1
$other_aliases
    Redirect permanent / http://$self->{servername}/
</VirtualHost>
EOT

}

# no arguments looks at the values of $self->{production_server} and
# $hostconf{shared_devel_server} to generate an access control
# configuration
sub _apache_access_control_str {
    my ($self) = @_;
    my %hostconf = %{ $self->{conf_object}->get_conf_hashref_single_values() };
    if ( $self->{production_server} ) {
	# for production servers, allow connections from everywhere
	<<EOT;
        # below is the access profile for a production webserver. allow connections from anywhere.
        Order allow,deny
        Allow from all
EOT
    } elsif ( $hostconf{shared_devel_server} ) {
	# for a shared development server, allow connections from just
	# a few places, and require passwords
	my $auth_user_file = "/etc/cxgn/htpasswd-$self->{project_name}";
	-f $auth_user_file
	    or die "shared_devel_server enabled, but no htpasswd file ($auth_user_file) found. aborting configuration generation.";
	<<EOT
        # below is the access profile for a shared development server, only allow connections from a list of trusted hosts
        # and subnets
        AllowOverride None
        AuthName "Development site; contact $hostconf{email} to request access"
        AuthType Basic
        AuthUserFile $auth_user_file
        Require valid-user
        Order deny,allow
        Deny from all
        Allow from 127.0.0.0/16
        Allow from 132.236.157.64/26
        Allow from 128.253.40.0/26
        Allow from 132.236.81.0/24
	Allow from 128.84.197.64/26
        Satisfy Any
EOT
    } else {
	<<EOT
        # below is the access profile for a personal development server: only allow connections from 127.0.*.*
        Order deny,allow
        Deny from all
        Allow from 127.0.0.0/16
        Allow from 192.168.0.0/16
        Allow from 172.16.0.0/12
        Allow from 10.0.0.0/8
EOT
    }
}

###
1;#do not remove
###
