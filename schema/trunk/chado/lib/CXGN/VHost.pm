=head1 NAME

CXGN::VHost

=head1 DESCRIPTION

This class is used by sgn-tools/http/vhosts.pl. vhosts.pl creates one of these for each virtual host it is setting up. This is an class which knows how to create host configuration objects and extract data from those objects. It can use that data to give apache write permissions to certain directories and to run make on other directories. It also can spit out an apache vhost configuration stanza into a file. You will need to create and use subclasses of this class if your vhost has aliases, rewrite rules, access controls, etc. You can add these to your overridden version of apache_config(), which is a function that returns a big string of whatever vhost-specific configuration text you need to add to the text generated by this module. 

=head1 OBJECT METHODS

=head2 new

Create a new object. Do not use this directly; your subclass's new() should call it instead.

=head2 chown_dirs

If apache_user and apache_writable_dirs are set in your configuration files (for an example, see CXGN::VHost::SGN.HostConf.default) this method will chown those dirs to apache.

=head2 chmod_dirs

If chmod_dirs are set in your configuration files, this method will changes these directories so they are executable and group-writable (775).

=head2 make_dirs

If make_dirs are set in your configuration files, this method will go into those directories and run 'make -k'.

=head2 generate_apache_config_file

Print an apache configuration stanza to a file which is sent in.

=head2 apache_config

You will probably want to subclass this module and override this function. See CXGN::VHost::SGN.pm for an example.

=head2 print_warning

This is used internally to print out warnings in a consistent format. Your subclass should avoid calling die because when this script is run, what we are trying to do is start apache! It is usually better to start apache incorrectly that not start it at all.

=head2 get_conf

Return the value found in the vhost configuration file(s), or, when necessary value retrieved from the environment.

=head1 MORE INFORMATION

For a better explanation of how these objects are used, see the perldoc in the script which uses them: sgn-tools/http/vhosts.pl.

=head1 AUTHOR

john binns - John Binns <zombieite@gmail.com>

=cut

use strict;
use CXGN::Configuration;
use Carp;
package CXGN::VHost;
sub new
{
    my $class=shift;
    my($params)=@_;
    unless(ref($params) eq 'HASH'){$params={};};
    my $self=bless($params,$class);
    #grab some data from environmental variables, since it is not always sent in, and not all of it is can be found in the vhost config files, as it may be set in All.MetaHostConf.default or All.MetaHostConf instead
    $self->{vhost_config}->{project_name}     =$self->{project_name}     ||=$ENV{PROJECT_NAME};
    $self->{vhost_config}->{servername}       =$self->{servername}       ||=$ENV{SERVERNAME};
    $self->{vhost_config}->{basepath}         =$self->{basepath}         ||=$ENV{BASEPATH};
    $self->{vhost_config}->{perllib_path}     =$self->{perllib_path}     ||=$ENV{PERL5LIB};
    $self->{vhost_config}->{production_server}=$self->{production_server};unless(defined($self->{vhost_config}->{production_server})){$self->{vhost_config}->{production_server}=$ENV{PRODUCTION_SERVER};}#this can be zero so we have to check if it is DEFINED rather than simply if it is "true" before discarding its value
    #this is the reverse order of precedence of the config files. every file that is visited can overwrite the data from previous files.
    my @conf_file_locations=
    (
        "/usr/local/lib/site_perl/CXGN/Configuration/VHost/Default.HostConf.default",#lowest precedence
        "/etc/cxgn/Default.HostConf",#second lowest precedence
    );
    #if we have a project name sent in, we can look further for more detailed configuration files as well, using the project name as a filename
    if($self->{vhost_config}->{project_name} and $self->{vhost_config}->{project_name} ne 'Default')
    {
        push
        (
            @conf_file_locations,
            (
                "/usr/local/lib/site_perl/CXGN/Configuration/VHost/$self->{vhost_config}->{project_name}.HostConf.default",#second highest precedence
                "/etc/cxgn/$self->{vhost_config}->{project_name}.HostConf"#highest precedence
            )
	);
    }
    $self->{conf_object}=CXGN::Configuration->new(@conf_file_locations);
    return $self;
}
sub chown_dirs
{
    my $self=shift;
    if(my $user=$self->{conf_object}->get_conf('apache_user'))
    {
        if($self->{conf_object}->get_conf('apache_writable_dirs'))
        {
            my @dirs=@{$self->{conf_object}->get_conf_arrayref('apache_writable_dirs')};
            for my $dir(@dirs)
            {
                my $cmd="chown -R $user:svn $dir";
                print"$cmd\n";
                system($cmd);
                if($?){$self->print_warning("Could not do '$cmd'. Note: this script must be run as root.");}
            }
        }
    }
}
sub chmod_dirs
{
    my $self=shift;
    if($self->{conf_object}->get_conf('chmod_dirs'))
    {
        my @dirs=@{$self->{conf_object}->get_conf_arrayref('chmod_dirs')};
        for my $dir(@dirs)
        {
            my $cmd="chmod -R 775 $dir";
            print"$cmd\n";
            system($cmd);
            if($?){$self->print_warning("Could not do '$cmd'. Note: this script must be run as root.");}
        }
    }
}
sub make_dirs
{
    my $self=shift;
    if($self->{conf_object}->get_conf('make_dirs'))
    {
        my @dirs=@{$self->{conf_object}->get_conf_arrayref('make_dirs')};
        for my $dir(@dirs)
        {
            my $cmd="cd $dir; make -k";
            print"$cmd\n";            
            system($cmd);
            if($?){$self->print_warning("Could not do (all of) '$cmd'. This is not usually a problem.");}
        }
    }
}
sub generate_apache_config_file
{
    my $self=shift;
    my($config_file_location)=@_;
    my %hostconf=%{$self->{conf_object}->get_conf_hashref_single_values()};

    #we must do some processing of our configuration values to make them into valid apache configuration syntax
    my $indexes="+Indexes";
    my $warnings="PerlWarn On";
    my $serveraliases="";
    my $serve_data_shared="";
    my $executable_subdir="";
    my $tempfiles_subdir="";
    if($self->{serveraliases} and $self->{serveraliases} ne 'NONE')
    {
        $serveraliases=join("\n",(map {"    ServerAlias $_"} split(',',$self->{serveraliases})));
    }
    my $password_require=<<END_HEREDOC;
        Order allow,deny
        Allow from all
END_HEREDOC
    my $statinc=<<END_HEREDOC;
        PerlModule Apache::StatINC
        PerlInitHandler Apache::StatINC
END_HEREDOC
    my $taint_mode='PerlTaintCheck Off';

    #anything which needs to be different on production and devel servers can be added here
    if($self->{production_server}) 
    {
        $statinc="";
        $indexes="-Indexes";
    }
    else
    {
        $password_require=<<END_HEREDOC;
        AuthName "Development site; contact sgn-feedback\@sgn.cornell.edu if you need access"
        AuthType Basic
        AuthUserFile /etc/cxgn/htpasswd-$self->{project_name}
        Require valid-user
        Order deny,allow
        Deny from all
        Allow from 127.0.0.0/26
        Allow from 132.236.157.64/26
        Allow from 128.253.40.0/26
        Satisfy Any
END_HEREDOC
    }

    #serve files directly from /data/shared
    if($hostconf{data_shared_url} and $hostconf{data_shared_website_path})
    {
            $serve_data_shared=<<END_HEREDOC;        
    Alias $hostconf{data_shared_url} $hostconf{data_shared_website_path}
    <Directory $hostconf{data_shared_website_path}>
        AllowOverride All
        Options $indexes -ExecCGI +FollowSymLinks
        Order allow,deny
        Allow from all
    </Directory>
END_HEREDOC
    }

    #set up executable perl scripts
    if($hostconf{executable_subdir})
    {
        $executable_subdir=<<END_HEREDOC;
    <Directory $self->{basepath}$hostconf{executable_subdir}>
        AllowOverride All
        #execute cgi scripts, auto indexing of directories
	Options +ExecCGI $indexes
        #if only a directory is specified, look for index.pl.
        DirectoryIndex index.pl
        #reuse database connections rather than getting new ones every time a new query is made
        PerlModule Apache::DBI 
        #autoreloading of modules
$statinc
        #set up perl script parsing
	SetHandler perl-script
        #use this module
        PerlModule CXGN::Apache::Registry
        #send perl scripts to this module for parsing
	PerlHandler CXGN::Apache::Registry
        #send things that look like http headers as http headers
        PerlSendHeader On
        #the output of our perl scripts is to be interpreted as text/html
	AddType text/html .pl
        #the favicon is expected to be right under document root, but don't execute 
        <Files favicon.ico>
            SetHandler none
        </Files>
        #the robots.txt file is expected to be right under document root, but don't execute 
        <Files robots.txt>
            SetHandler none
        </Files>
    </Directory>
END_HEREDOC
    }

    #set up default plain content-type for tempfiles subdir
    if($hostconf{tempfiles_subdir}) {
      $tempfiles_subdir = <<EOH;
    <Directory $self->{basepath}$hostconf{tempfiles_subdir}>
        DefaultType text/plain
    </Directory>
EOH
    }

    #generate apache config
    my $opener_string=<<END_HEREDOC;
################### BEGIN $self->{vhost_config}->{project_name} ###################
<VirtualHost *>
    #set an environmental variable which will allow modules which are used by multiple virtual hosts (for instance, CXGN::Page) to find out which virtual host they are running on
    PerlSetEnv PROJECT_NAME $self->{project_name}
    #set an environmental variable for cookies as implemented by CXGN::Page (i suspect this would not be necessary if we were doing cookies correctly --john)
    PerlSetEnv SERVERNAME $self->{servername}
    #set an environmental variable for basepath, since there may be more than one basepath for similar configurations, if multiple users have similar vhost setups on a machine
    PerlSetEnv BASEPATH $self->{basepath}
    #are we running as a production server
    PerlSetEnv PRODUCTION_SERVER $self->{production_server}
    #tell perl where to look for modules
    PerlSetEnv PERL5LIB $self->{perllib_path}
    #the name of the virtual host we are defining
    ServerName $self->{servername}
    #and any aliases
$serveraliases

    #supposedly reloads all scripts and modules after a restart but does not seem to work. you must actually stop and start apache as two steps. --john
    PerlFreshRestart On
    #give warnings
    $warnings
    #do not allow raw user-submitted data to be eval'd or used in system calls
    $taint_mode 

    #who to email with problems
    ServerAdmin $hostconf{email}

    #respond to all requests by looking in this directory...
    DocumentRoot $self->{basepath}$hostconf{document_root_subdir}

    #where to write error messages
    ErrorLog $self->{basepath}$hostconf{error_log}
    CustomLog $self->{basepath}$hostconf{access_log} combined
    CustomLog $self->{basepath}$hostconf{access_log} timing

    <Directory />
        #allow symlinks
        Options +FollowSymLinks
        #specify who can come to our website
$password_require
    </Directory>

    #when a page is forbidden, go here    
    #ErrorDocument 403 $hostconf{error_document}

    #when a page is not found, go here    
    ErrorDocument 404 $hostconf{error_document}

    #when a script dies, go here. this should always be handled by CXGN::Apache::Registry, but sometimes things break badly. LEAVE THE INITIAL QUOTE IN (unless replacing this with a path to a file)
    ErrorDocument 500 \"Internal server error: The server encountered an internal error or misconfiguration and was unable to complete your request. Feel free to contact us at sgn-feedback\@sgn.cornell.edu and inform us of the error.

$serve_data_shared
$executable_subdir
$tempfiles_subdir
END_HEREDOC
    my $closer_string=<<END_HEREDOC;
</VirtualHost>
################### END $self->{vhost_config}->{project_name} #####################
END_HEREDOC
    #let our subclass tack on its special configuration as well
    $self->{config_text}=$opener_string."    #$self->{vhost_config}->{project_name} VHOST SUBCLASS CONFIGURATION\n".$self->apache_config()."    #END $self->{vhost_config}->{project_name} VHOST SUBCLASS CONFIGURATION\n".$closer_string;

    #print apache config to file
    my $FILE_HANDLE;
    if(open $FILE_HANDLE,$config_file_location)
    {
        print $FILE_HANDLE $self->{config_text};
        close $FILE_HANDLE;
    }
}
sub apache_config
{
    return'';#this method is meant to be overridden in your subclass if you need it. you can use this method to return a string of whatever else you would like to add to your virtual host configuration.
}
sub test_config
{
    my $self=shift;
    #check for presence of required settings
    unless($self->{vhost_config}->{project_name}){$self->print_warning("No project_name given; unable to create vhost object.");return 0;}
    unless($self->{servername}){$self->print_warning("No servername given; unable to create vhost object.");return 0;}
    unless($self->{basepath}){$self->print_warning("No basepath given; unable to create vhost object.");return 0;}
    unless($self->{perllib_path}){$self->print_warning("No perllib_path given; unable to create vhost object.");return 0;}
    unless(defined($self->{production_server})){$self->print_warning("No production server value given; unable to create vhost object.");return 0;}
    #make sure we can create a configuration object
    my $conf;
    unless($conf=$self->{conf_object})
    {
        $self->print_warning("Unable to create configuration object for '$self->{vhost_config}->{project_name}'. This vhost object cannot be created.");
        return 0;
    }
    #now run any test we can think of which might catch a problem before it happens.
    my $basepath=$self->{basepath};
    unless(-d($basepath))
    {
        $self->print_warning("Basepath '$basepath' not found.");
        return 0;
    }
    my $perllib_path=$self->{perllib_path};
    unless(-d($perllib_path))
    {
        $self->print_warning("Perllib path '$perllib_path' not found.");
        return 0;
    }
    my $docroot=$conf->get_conf('document_root_subdir');
    unless(-d($basepath.$docroot))
    {
        $self->print_warning("Document root '$basepath$docroot' not found.");
        return 0;
    }
    my $executable_subdir=$conf->get_conf('executable_subdir');
    if($executable_subdir)
    {
        unless(-d($basepath.$executable_subdir))
        {
            $self->print_warning("Executable directory '$basepath$executable_subdir' not found.");
            return 0;
        }
    }
    my $data_shared_website_path=$conf->get_conf('data_shared_website_path');
    if($data_shared_website_path)
    {
        unless(-d($data_shared_website_path))
        {
            $self->print_warning("Data shared website path '$data_shared_website_path' not found. Attempting configuration anyway.");
        }
    }
    my $rewrite_log=$conf->get_conf('rewrite_log');
    if($rewrite_log)
    {
        unless(-f($basepath.$rewrite_log))
        {
            $self->print_warning("Rewrite log file '$basepath$rewrite_log' not found. Apache will attempt to create this file. If apache cannot create this file, it WILL FAIL TO START.");
        }
    }
    return 1;#all tests passed
}
sub print_warning
{
    my $self=shift;
    my($message)=@_;
    my $WARNING_HEADER="***** $self->{vhost_config}->{project_name} WARNING *****\n";
    my $WARNING_FOOTER="";
    print"$WARNING_HEADER$message\n$WARNING_FOOTER";
}
sub get_conf
{
    my $self=shift;
    my($requested_config)=@_;
    unless($requested_config){Carp::carp("CXGN::Configuration::VHost: no configuration requested");return;}
    #we hold some configuration values in this object--the ones which are gathered from environmental variables
    if(defined($self->{vhost_config}->{$requested_config}))
    {
        return $self->{vhost_config}->{$requested_config};
    }
    #all other configuration values are found in the conf object, which gathers them from the configuration files
    else
    {
        return $self->{conf_object}->get_conf($requested_config);
    }
}
1;
