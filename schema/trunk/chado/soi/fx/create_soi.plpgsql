--- create ontology that has instantiated located_sequence_feature part of SO
--- way as it is written, the function can not be execute more than once in one connection
--- when you get error like ERROR:  relation with OID NNNNN does not exist
--- as this is not meant to execute >1 time in one session so it should never happen
--- except at testing and test failed
--- disconnect and try again, in other words, it can NOT be executed >1 time in one connection
--- if using EXECUTE, we can avoid this problem but code is hard to write and read (lots of ', escape char)

--NOTE: private, don't call directly as relying on having temp table tmpcvtr

CREATE OR REPLACE FUNCTION _fill_cvtermpath4soi(INTEGER, INTEGER, INTEGER) RETURNS INTEGER AS
'
DECLARE
    rootid alias for $1;
    cvid alias for $2;
    soitermid alias for $3;
    pcount integer := 1;
    depth integer := 1;
    query text := '''';
    total integer := 0;
BEGIN
    CREATE TEMP TABLE tmpparent (cvterm_id INTEGER, status INTEGER DEFAULT 0);
---has to use execute as it is repeated called in session and temp table, need || for variable in execute stmnt
    EXECUTE ''INSERT INTO tmpparent VALUES('' || rootid || '', 0);'';
    WHILE (pcount > 0) LOOP
        -- get all children
        query := ''INSERT INTO cvtermpath (type_id, subject_id, object_id, cv_id, pathdistance)
            SELECT DISTINCT c.tmp_type, c.subject_id, '' || rootid || '', '' || cvid || '', '' || depth ||
            '' FROM tmpcvtr c, tmpparent p
            WHERE c.object_id = p.cvterm_id AND p.status = 0 AND c.type_id ='' || soitermid || '';'';
        RAISE NOTICE ''%'', query;
        EXECUTE query;

        EXECUTE ''UPDATE tmpparent SET status = 1 WHERE status = 0;'';
        EXECUTE ''INSERT INTO tmpparent SELECT DISTINCT c.subject_id, 0 
            FROM tmpcvtr c, tmpparent p 
            WHERE c.object_id = p.cvterm_id AND p.status = 1 AND c.type_id ='' || soitermid || '';'';
        -- set status to indicate parents are done
        EXECUTE ''UPDATE tmpparent SET status = 2 WHERE status = 1;'';
        EXECUTE ''SELECT * FROM tmpparent WHERE status = 0;'';
        GET DIAGNOSTICS pcount = ROW_COUNT;
        depth := depth + 1;
    END LOOP;

    DROP TABLE tmpparent;
    RETURN 1;
END;   
'
LANGUAGE 'plpgsql';


DROP TYPE soi_type CASCADE;
CREATE TYPE soi_type AS (
    cv_id INT,
    cvterm_id INT,
    status INT
);

CREATE OR REPLACE FUNCTION create_soi() RETURNS INTEGER AS
'
DECLARE
    parent soi_type%ROWTYPE;
    isa_id cvterm.cvterm_id%TYPE;
    so_term TEXT := ''so'';
    soi_term TEXT := ''soi'';
    soi_def TEXT := ''ontology of SO feature instantiated in database'';
    soi_id INTEGER;
    soiterm_id INTEGER;
    pcount INTEGER;
    count INTEGER := 0;
    cquery TEXT;
BEGIN

    SELECT INTO isa_id cvterm_id FROM cvterm WHERE name = ''isa'';

    SELECT INTO soi_id cv_id FROM cv WHERE name = soi_term;
    IF (soi_id > 0) THEN
        DELETE FROM cvtermpath WHERE cv_id = soi_id;
        DELETE FROM cvterm WHERE cv_id = soi_id;
    ELSE
        INSERT INTO cv (name, definition) VALUES(soi_term, soi_def);
    END IF;
    SELECT INTO soi_id cv_id FROM cv WHERE name = soi_term;
    INSERT INTO cvterm (name, cv_id) VALUES(soi_term, soi_id);
    SELECT INTO soiterm_id cvterm_id FROM cvterm WHERE name = soi_term;

    CREATE TEMP TABLE tmpcvtr (tmp_type INT, type_id INT, subject_id INT, object_id INT);
    INSERT INTO tmpcvtr (tmp_type, type_id, subject_id, object_id)
        SELECT DISTINCT isa_id, soiterm_id, f.type_id, soiterm_id FROM feature f, cvterm t
        WHERE f.type_id = t.cvterm_id AND f.type_id > 0;
    EXECUTE ''select * from tmpcvtr where type_id = '' || soiterm_id || '';'';
    get diagnostics pcount = row_count;
    raise notice ''all types in feature %'',pcount;
--- do it hard way, delete any child feature type from above (NOT IN clause did not work)
    FOR parent IN SELECT DISTINCT 0, c.type_id, 0 FROM feature c, feature_relationship fr, cvterm t
            WHERE t.cvterm_id = c.type_id AND c.feature_id = fr.subject_id LOOP
        DELETE FROM tmpcvtr WHERE type_id = soiterm_id and object_id = soiterm_id
            AND subject_id = parent.cvterm_id;
    END LOOP;
    EXECUTE ''select * from tmpcvtr where type_id = '' || soiterm_id || '';'';
    get diagnostics pcount = row_count;
    raise notice ''all types in feature after delete child %'',pcount;

    CREATE TEMP TABLE tmproot (cv_id INTEGER not null, cvterm_id INTEGER not null, status INTEGER DEFAULT 0);
    cquery := ''SELECT * FROM tmproot tmp WHERE tmp.status = 0;'';
    ---temp use tmpcvtr to hold instantiated SO relationship for speed
    ---use soterm_id as type_id, will delete from tmpcvtr
    ---us tmproot for this as well
    INSERT INTO tmproot (cv_id, cvterm_id, status) SELECT DISTINCT soi_id, c.subject_id, 0 FROM tmpcvtr c
        WHERE c.object_id = soiterm_id;
    EXECUTE cquery;
    GET DIAGNOSTICS pcount = ROW_COUNT;
    WHILE (pcount > 0) LOOP
        RAISE NOTICE ''num child temp (to be inserted) in tmpcvtr: %'',pcount;
        INSERT INTO tmpcvtr (tmp_type, type_id, subject_id, object_id)
            SELECT DISTINCT fr.type_id, soiterm_id, c.type_id, p.cvterm_id FROM feature c, feature_relationship fr,
            tmproot p, feature pf, cvterm t WHERE c.feature_id = fr.subject_id AND fr.object_id = pf.feature_id
            AND p.cvterm_id = pf.type_id AND t.cvterm_id = c.type_id AND p.status = 0;
        UPDATE tmproot SET status = 1 WHERE status = 0;
        INSERT INTO tmproot (cv_id, cvterm_id, status)
            SELECT DISTINCT soi_id, c.type_id, 0 FROM feature c, feature_relationship fr,
            tmproot tmp, feature p, cvterm t WHERE c.feature_id = fr.subject_id AND fr.object_id = p.feature_id
            AND tmp.cvterm_id = p.type_id AND t.cvterm_id = c.type_id AND tmp.status = 1;
        UPDATE tmproot SET status = 2 WHERE status = 1;
        EXECUTE cquery;
        GET DIAGNOSTICS pcount = ROW_COUNT; 
    END LOOP;
    DELETE FROM tmproot;

    ---get transitive closure for soi
    PERFORM _fill_cvtermpath4soi(soiterm_id, soi_id, soiterm_id);

    INSERT INTO tmproot (cv_id, cvterm_id, status) SELECT DISTINCT soi_id, c.subject_id, 0 FROM tmpcvtr c
        WHERE c.object_id = soiterm_id;
    EXECUTE cquery;
    GET DIAGNOSTICS pcount = ROW_COUNT;

    WHILE (pcount > 0) LOOP
        RAISE NOTICE ''num child: %'',pcount;
        FOR parent IN SELECT * FROM tmproot WHERE status = 0 LOOP
            PERFORM _fill_cvtermpath4soi(parent.cvterm_id, parent.cv_id, soiterm_id);
        END LOOP;
        UPDATE tmproot SET status = 1 WHERE status = 0;
        INSERT INTO tmproot (cv_id, cvterm_id, status) SELECT DISTINCT soi_id, c.subject_id, 0 FROM tmpcvtr c,
            tmproot p WHERE p.cvterm_id = c.object_id AND c.type_id = soiterm_id AND p.status = 1;
        UPDATE tmproot SET status = 2 WHERE status = 1;
        EXECUTE cquery;
        GET DIAGNOSTICS pcount = ROW_COUNT;
    END LOOP; 

    DROP TABLE tmpcvtr;
    DROP TABLE tmproot;

    RETURN 1;
END;
'
LANGUAGE 'plpgsql';

