$Id: snps.txt,v 1.1 2002-12-07 02:04:01 cmungall Exp $

This outlines one way of modeling SNPs in chado. it also illustrates
use of the featureloc table.

Most of this applies to other variation features, but I'll illustrute
using SNPs for now to keep it simple.

A SNP is represented as a single feature in chado.

Let's take a basic example - a SNP that flips an A to a G on the
genome.

Here we would have one feature and two featurelocs.

(feature
  (name "SNP_01")
  (featureloc
    (srcfeature "Chromosome_arm_2L") ;;; dna feature identifier
    (nbeg 1000000)
    (nend 1000001)
    (strand 1)
    (residue_info "A")
    (rank 0)
    (locgroup 0))
  (featureloc
    (residue_info "G")
    (rank 1)
    (locgroup 0)))

the first location is on the chromosome arm (presumably wildtype). the
second location has no srcfeature (ie it is set to null). however, it
is effectively paired with the first location. if we later wished to
instantiate the mutant chromosome arm feature, we would fill in the
second locgroup's srcfeature.

Let's take another example - a SNP that has only been characterised at
the protein level. This SNP flips an I to a V

(feature
  (name "SNP_02")
  (featureloc
    (srcfeature "dpp-P1")    ;;; protein feature identifier
    (nbeg 23)
    (nend 24)
    (strand 1)
    (residue_info "I")
    (rank 0)
    (locgroup 0))
  (featureloc
    (residue_info "V")
    (rank 1)
    (locgroup 0)))

Again, the second featureloc has no srcfeature. the mutant protein is
implicit. the mutant protein sequence can be infered by taking the
sequence of "dpp-P1" and substituting the 24th residue with a V.

To do a query for all SNPs that switch I to V or vice versa:

SELECT snp.*
FROM
  featureloc AS wildloc,
  featureloc AS mutloc,
  feature AS snp,
  cvterm AS ftype
WHERE
  snp.type_id = ftype.cvterm_id        AND
  ftype.termname = 'snp'               AND
  wildloc.feature_id = snp.feature_id  AND
  mutloc.feature_id = snp.feature_id   AND
  wildloc.locgroup = mutloc.locgroup   AND
  wildloc.residue_info = 'I'           AND
  mutloc.residue_info = 'I';


note that this query remains the same even if mutant protein features
are instantiated as opposed to left implicit.


Let's look at a more complex example. If we have a SNP that has been
localised to the genome, and the SNP has an effect on a protein
(Isoleucine to Threonine), and we want to redundantly store the SNP
effect on the genome, transcript and translation.

[note that in this example, the transcript is on the reverse strand,
so the residue is reverse complemented]

(feature
  (name "SNP_03")

  ;; position on genome
  (featureloc
    (srcfeature "chrom_arm_3R")
    (nbeg 2000000)
    (nend 2000001)
    (strand 1)
    (residue_info "A")
    (rank 0)                       ;; wild
    (locgroup 0))
  (featureloc
    (residue_info "G")
    (rank 1)                       ;; mutant
    (locgroup 0))

  ;; position on transcript
  (featureloc
    (srcfeature "blah-transcript001")     ;; processed transcript ID
    (nbeg 1000)
    (nend 1001)
    (strand 1)
    (residue_info "T")
    (rank 0)                       ;; wild
    (locgroup 1))
  (featureloc
    (residue_info "C")
    (rank 1)                       ;; mutant
    (locgroup 1))

  ;; position on protein
  (featureloc
    (srcfeature "blah-protein001")    ;;; protein feature identifier
    (nbeg 23)
    (nend 24)
    (strand 1)
    (residue_info "I")
    (rank 0)                       ;; wild
    (locgroup 2))
  (featureloc
    (residue_info "T")
    (rank 1)                       ;; mutant
    (locgroup 2)))

Here we have 6 locations for one SNP. The 6 locations can be imagined
to be in a 2D matrix. the purpose of rank and locgroup is to specify
the column and row in the matrix

        | genome    transcript   protein
--------+-------------------------------
wild    |   A           T        I
        |
mutant  |   G           C        T

rank is used to group the strain and locgroup is used for the grouping
within that strain. rank=0 should be used for the wildtype, but this
is not always possible; locgroup=0 should be used for primary (as
opposed to derived) location, this is not always possible. the
important thing is consistency within a SNP to preserve the matrix.

One can imagine rare (but entirely possible) cases where by a single
SNP causes different protein level changes in two proteins (for
instance, HIV carries a doubly encoded gene - ie the ORFs overlap but
have different frames).

Here we would want to add another locgroup, for the second protein

        | genome    transcript   protein1 protein2
--------+-----------------------------------------
wild    |   A           T        I        Y
        |
mutant  |   G           C        T        H

Again, if we don't need to instantiate the 2 mutant proteins, but
their sequence can be reconstructed from the wild proteins plus the
corresponding mutation

[remember chado is interbase, and postgresql substring counts from 1]

The following query dynamically constructs mutant feature residues
based on the wildtype feature and the mutant residue changes. this
should work for a variety of variation features, not just SNPs. Note
that we need to use locgroup to properly group wild/mutant pairs of
locations otherwise this query will give bad data.

SELECT
 snp.name,
 wildfeat.name,
 substr(wildfeat.residues,
        1,
        wildloc.nbeg) ||
 mutloc.residue_info  ||
 substr(wildfeat.residues,
        wildloc.nend+1)
FROM
  featureloc AS wildloc,
  feature AS wildfeat,
  featureloc AS mutloc,
  feature AS snp,
  cvterm AS ftype
WHERE
  snp.type_id = ftype.cvterm_id         AND
  ftype.termname = 'snp'                AND
  wildloc.feature_id = snp.feature_id   AND
  mutloc.feature_id = snp.feature_id    AND
  wildloc.locgroup = mutloc.locgroup    AND
  wildloc.srcfeature = wildfeat


EXTENSIONS
==========

The above will also work if we have a polymorphic site with a number
of different possibilities across multiple strains. We just extend the
number of rows in the location matrix (ie we have rank > 1).

We could also instantiate multiple SNPs, one per strain, and keep the
locations pairwise.

SIMILARITIES TO ALIGNMENTS
==========================

You should hopefully notice the parallels between modeling SNPs and
modeling pairwise (eg BLAST) and multiple alignments. The difference
is, alignments would always have locgroup=0, with the rank
distinguishing query from subject. Also, with an HSP feature, the
residue_info is used to store the alignment string.

REDUNDANT STORAGE OF COORDINATES ON DIFFERENT ASSEMBLY LEVELS
=============================================================

Some groups may find it advantageous to redundantly store features
relative to both BACs and chromosomes (or to mini-contigs and
scaffolds... choose your favourite assembly units). The approach
outlined above works perfectly well with this, we would simple add
another column in the location matrix (ie another wild/mutant pair
with a distinct locgroup). All queries should work the same.
