CHADO POLICY LAYER
==================

                       Chris Mungall BDGP

Chado is a generic schema, which means anyone writing software to
query or write to chado (either middleware or applications) should be
aware of the different ways in which data can be stored. We want to
strike a nice balance between flexibility and extensibility on the one
hand, and strong typing and rigor on the other. We want to avoid the
situation we have with GenBank entries where there are a dozen ways of
representing a gene model, but we need to be able to cope with the
constant surprises biology throws at us in an attempt to confound our
nice computable models.

I am suggesting a layered model - this is tried and tested in software
engineering. Some generic software can be targeted at the lower layers
and be guaranteed to work no matter what. Other more specific software
needs a more tightly defined rigorous model and should be targeted at
the upper layers.

We require validation software and more formal/computable descriptions
of these layers and policies - for now natural language descriptions
will have to suffice.

LAYERS
------

  Level 0 conformance basically means the schema is adhered
  to. Obviously, this is enforced by the DBMS.

  Level 1 conformance is minimal conformance to SO - all feature.types
  must be SO terms, and all feature_relationship.types must be SO
  relationship types.

  Level 2 conformance is graph conformance to SO - all
  feature_relationships between a feature of type X and Y must
  correspond to relationship of that type in SO; for example, mRNA can
  be part_of gene, but mRNA can not be part_of
  golden_path_region. [more detailed/formal explanation to come]. In
  practice Level 2 conformance may be undesirable, we may need to make
  modifications to SO.

Orthogonal to these layers are various additional policy
decisions. Some of these are more tolerant of non-conformance than
others. (there is also some overlaps with levels 1/2).

I have listed how FB implements each policy choice - other chado
instances feel free to add....

TIGR: Currently at level 0 conformance, though most (if not all) of the 
terms being used have an obvious counterpart in SO.  Therefore these
"TIGR Ontology" terms are used in the answers to the SO-related questions
that appear below.  We plan on updating our terms with SO terms very soon.

POLICY CHOICES
--------------

* SO terms used for standard central-dogma gene model

FB: gene mRNA exon protein [other types are derivable]
TIGR: gene transcript CDS exon protein [though the strict answer is for any of these SO questions is "none" since we do not yet meet level 1 conformance]

  NOTE: we should be using 'polypeptide' instead of 'protein'. For
  now, software should be tolerant of both these uses.

* SO terms used for storing alignments

FB: match
TIGR: match

  NOTE: we want to use the new more specific SO types for match_set,
  match_part, for hits and hsps respectively. For now, software should
  be tolerant of either usage.

  TIGR: We've also extended the model for storing pairwise alignments
  to store multiple alignments.  Each member of the alignment is
  featureloced to the 'match' feature.  We've used this representation
  to store paralogous/orthologous gene families.

* feature_relationship.types

FB: partof (for mRNA to gene and exon to mRNA)
    producedby (for protein to mRNA)
TIGR: part_of (gene-assembly, exon-transcript, assembly-supercontig)
      produced_by (protein-CDS, CDS-transcript, transcript-gene)

  NOTE: this should be "part_of" and "derived_from" to conform to
  SO. Most read-only software should be able to safely ignore
  feature_relationship.type anyway. Protein should be polypeptide -
  see note above

  NOTE: the main difference between FB and TIGR here is that TIGR
  introduce an intermediate CDS feature between mRNA and protein

* featureloc policy

FB: all constituent parts of a central dogma gene model are located
relative to the same srcfeature (the chromosome arm). No redundant
locations (ie featureloc.group > 0) are used

TIGR: Redundant locations are used and indicated with featureloc.group > 0.


  NOTE: we want to allow some flexibility with this policy. I believe
  that the constituent parts linked located relative to the feature
  should always be followed. This can be stated more formally as:

    IF   X is linked to Y via feature_relationship
    AND  X is located relative to Z via featureloc.srcfeature_id
    THEN Y must also be located relative to Z via featureloc.srcfeature_id 

TIGR: We've followed this policy in adding a featureloc between the
protein and genomic contig in our databases (such a featureloc does
not appear in the Chado usage documents).  This additional featureloc
simplifies many queries, especially when looking at the genomic
context of 'match' features associated with proteins.

  We should also expect that the fmin/fmax boundaries of a feature be
  defined the the outermost boundaries of the outermost constituent
  part features (this rule may require refinement when we have
  promoters, enhancers and so on - but for now we don't).

  As to what the srcfeature should be, it could be a contig, and
  assembly or a top-level locatable feature such as chromosome or
  chromosome arm. Software should be tolerant of different choices
  here. Whilst it is generally always best to locate relative to the
  topmost feature (ie the arm/chromosome), sometimes this is not
  possible or desirable (eg low coverage, heterochromatin). 

* non-central dogma gene models

FB: we store a lot of non-central dogma gene models; noncoding gene
models and pseudogenes [need to fill in more details here]
TIGR: not many of these stored yet, save for a few pseudogenes
and the occasional non-coding ORF

* other features

FB: the FlyBase implementation includes many other feature types,
including polyA_site and sequence_variant [need to fill in details]
TIGR: using 'SNP' in some databases

* derivable features types

FB: derivable features (introns, UTRs, intergenic_region) are not
included. Feature typing is always done to the most specific,
non-derivale level. For example, we never use types "5_prime_exon",
"dicistronic_gene", "coding_exon" as these are always inferrable. We
always use type "gene" - the specific type of gene is inferred from
the child type (mRNA, tRNA, snRNA, etc).
TIGR: derivable features are not included.  currently not storing any
tRNAs or snRNAs.

  NOTE: whilst it is perfectly permissable to include redundant
  derivable features (useful for warehouse-style querying), you should
  not write software that expects to find these if you want the
  software to work on different chado db instances.

* sequence_variants

FB: these are included in chado, but they are lacking full detail
TIGR: only SNPs so far.  the SNPs currently being stored are computed from
pairwise alignments of sequences already loaded into Chado, so each SNP 
feature is featureloc'ed to the appropriate place on each of the two 
sequences (rather than having one of the featurelocs "dangling", as 
indicated in some of the Chado usage documents.)  featureloc.residue_info
is used to redundantly store the base referenced in each of the two 
sequences.

  NOTE: variation features should specify the edit that makes one
  feature (such as the reference/wild-type) from another (the
  variant/mutant/non-reference). There were perhaps 2 proposals for
  this [more details required...]

//
