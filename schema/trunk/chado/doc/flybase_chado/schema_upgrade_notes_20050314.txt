-- Tables needing changes to bring current implementation of dmel chado 
-- (chado_dmel_r4_3) to standard of chado_20050313


---------------------
-- CV module changes
---------------------
-- ALTER TABLE: contact
alter table contact add column name varchar(30);
update contact set name = '';
alter table contact alter column name set not null;


-- ADD TABLE: tableinfo
create table tableinfo (
    tableinfo_id serial not null,
    primary key (tableinfo_id),
    name varchar(30) not null,
    primary_key_column varchar(30) null,
    is_view int not null default 0,
    view_on_table_id int null,
    superclass_table_id int null,
    is_updateable int not null default 1,
    modification_date date not null default now(),
    constraint tableinfo_c1 unique (name)
);
COMMENT ON TABLE tableinfo IS NULL;


-- ALTER TABLE: db
alter table db alter column contact_id drop not null;


-- ADD TABLE: project
create table project (
    project_id serial not null,  
    primary key (project_id),
    name varchar(255) not null,
    description varchar(255) not null,
    constraint project_c1 unique (name)
);
COMMENT ON TABLE project IS NULL;

-- CV module modifications taken from cv/update_cv_module.ddl
-- 17 Feb 2005
-- DDL to change cv module tables used on chado_dmel_r4_1 implementation to 
-- reflect the current cv module


-- ALTER TABLE: cvterm
alter table cvterm add column is_obsolete integer;
alter table cvterm alter column is_obsolete set default 0;
update cvterm set is_obsolete = 0;
alter table cvterm alter column is_obsolete set not null;

alter table cvterm add column is_relationshiptype integer;
alter table cvterm alter column is_relationshiptype set default 0;
update cvterm set is_relationshiptype = 0;
alter table cvterm alter column is_relationshiptype set not null;

-- extend cvterm.name data type to varchar(1024)
-- this is more involved than you'd think, because of all of the functions 
-- which point at name...

-- drop these views (will recreate after changing ddl)
drop view gffatts_slim cascade;
drop view gffatts_slpar;
drop view af_type cascade;
drop view fnr_type cascade;
drop view fp_key cascade;
drop view f_type cascade;
drop view f_loc cascade;
drop view cvterm_type cascade;

alter table cvterm rename column name to old_name;
alter table cvterm add column name varchar(1024);
update cvterm set name = old_name;
alter table cvterm alter column name set not null;
alter table cvterm drop column old_name;

alter table cvterm add constraint cvterm_c1_unique unique (name,cv_id,is_obsolete)

-- This doesn't execute... until we upgrade the cv module data???
-- alter table cvterm add constraint cvterm_c2 unique (dbxref_id);
-- HERE'S A WORKAROUND FOR USING XORT: We alter the XORT ddl.properties so 
-- that cvterm.dbxref_id is still nullable 
-- THESE ARE THE ddl.properties lines we're changing: 
--   cvterm_unique=name cv_id is_obsolete dbxref_id
--   cvterm_non_null_cols=is_obsolete name cv_id is_relationshiptype dbxref_id



CREATE VIEW gffatts_slim AS
    ((SELECT fs.feature_id, 'dbxref' AS "type", ((d.name || ':'::character varying) || s.accession) AS attribute FROM dbxref s, feature_dbxref fs, db d WHERE ((fs.dbxref_id = s.dbxref_id) AND (s.db_id = d.db_id))) UNION ALL (SELECT fp.feature_id, cv.name AS "type", fp.value AS attribute FROM featureprop fp, cvterm cv WHERE ((fp.type_id = cv.cvterm_id) AND ((cv.name = 'cyto_range'::character varying) OR (cv.name = 'gbunit'::character varying)))));


CREATE VIEW gffatts_slpar AS
    ((((SELECT fs.feature_id, 'dbxref' AS "type", ((d.name || ':'::character varying) || s.accession) AS attribute FROM dbxref s, feature_dbxref fs, db d WHERE ((fs.dbxref_id = s.dbxref_id) AND (s.db_id = d.db_id))) UNION ALL (SELECT fp.feature_id, cv.name AS "type", fp.value AS attribute FROM featureprop fp, cvterm cv WHERE ((fp.type_id = cv.cvterm_id) AND ((cv.name = 'cyto_range'::character varying) OR (cv.name = 'gbunit'::character varying)))))) UNION ALL (SELECT pk.subject_id AS feature_id, 'parent_oid' AS "type", CASE WHEN (pk.rank IS NULL) THEN text(pk.object_id) ELSE (((pk.object_id)::text || ':'::text) || (pk.rank)::text) END AS attribute FROM feature_relationship pk));

CREATE VIEW af_type AS
    SELECT f.feature_id, f.name, f.uniquename, f.dbxref_id, c.name AS "type", f.residues, f.seqlen, f.md5checksum, f.type_id, f.organism_id, af.analysis_id, f.timeaccessioned, f.timelastmodified FROM feature f, analysisfeature af, cvterm c WHERE ((f.type_id = c.cvterm_id) AND (f.feature_id = af.feature_id));

CREATE VIEW fnr_type AS
    SELECT f.feature_id, f.name, f.uniquename, f.dbxref_id, c.name AS "type", f.residues, f.seqlen, f.md5checksum, f.type_id, f.organism_id, f.timeaccessioned, f.timelastmodified FROM (feature f LEFT JOIN analysisfeature af ON ((f.feature_id = af.feature_id))), cvterm c WHERE ((f.type_id = c.cvterm_id) AND (af.feature_id IS NULL));

CREATE VIEW fp_key AS
    SELECT fp.featureprop_id, fp.feature_id, c.name AS "type", fp.value FROM featureprop fp, cvterm c WHERE (fp.type_id = c.cvterm_id);

CREATE VIEW f_type AS
    SELECT f.feature_id, f.name, f.uniquename, f.dbxref_id, c.name AS "type", f.residues, f.seqlen, f.md5checksum, f.type_id, f.organism_id, f.is_analysis, f.timeaccessioned, f.timelastmodified FROM feature f, cvterm c WHERE (f.type_id = c.cvterm_id);

CREATE VIEW f_loc AS
    SELECT f.feature_id, f.name, f.dbxref_id, fl.fmin, fl.fmax, fl.strand FROM featureloc fl, f_type f WHERE (f.feature_id = fl.feature_id);

CREATE VIEW cvterm_type AS
    SELECT cvt.cvterm_id, cvt.name, cv.name AS termtype FROM cvterm cvt, cv WHERE (cvt.cv_id = cv.cv_id);


-- ALTER TABLE: cvtermsynonym
alter table cvtermsynonym add column type_id integer;
ALTER TABLE ONLY cvtermsynonym 
	ADD CONSTRAINT "$2" FOREIGN KEY (type_id) REFERENCES cvterm(cvterm_id) 
	ON UPDATE NO ACTION ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;


-- ALTER TABLE: cvterm_dbxref
alter table cvterm_dbxref add column is_for_definition integer;
alter table cvterm_dbxref alter column is_for_definition set default 0;
update cvterm_dbxref set is_for_definition = 0;
alter table cvterm_dbxref alter column is_for_definition  set not null;


-- ADD TABLE: cvtermprop 	 
create table cvtermprop ( 
    cvtermprop_id serial not null, 
    primary key (cvtermprop_id), 
    cvterm_id int not null, 
    foreign key (cvterm_id) references cvterm (cvterm_id) on delete cascade, 
    type_id int not null, 
    foreign key (type_id) references cvterm (cvterm_id) on delete cascade, 
    value text not null default '', 
    rank int not null default 0,

    unique(cvterm_id, type_id, value, rank) 
);
create index cvtermprop_idx1 on cvtermprop (cvterm_id);
create index cvtermprop_idx2 on cvtermprop (type_id);



---------------------
-- General module changes
---------------------
-- ADD TABLE: dbxrefprop
create table dbxrefprop (
    dbxrefprop_id serial not null,
    primary key (dbxrefprop_id),
    dbxref_id int not null,
    foreign key (dbxref_id) references dbxref (dbxref_id) INITIALLY DEFERRED,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id) INITIALLY DEFERRED,
    value text not null default '',
    rank int not null default 0,
    constraint dbxrefprop_c1 unique (dbxref_id,type_id,rank)
);
create index dbxrefprop_idx1 on dbxrefprop (dbxref_id);
create index dbxrefprop_idx2 on dbxrefprop (type_id);


---------------------
-- Organism module changes
---------------------
-- ALTER TABLE: organismprop
alter table organismprop alter column value drop not null;
alter table organismprop alter column value drop default;

---------------------
-- Pub module changes
---------------------
-- This code deletes pubs which are not linked to anything (only links are via 
-- feature_pub and featureprop_pub at the moment):
-- (g4)   ~/work/gmod/schema/chado/schema_upgrade/delete_unlinked_pubs
-- this takes a few hours...  (24 on g4!)
  
-- We have some cases where there are duplicate uniquenames in the pub table.
-- These are ALL for featureprops from apollo curation, attributed to specific
-- curators.  Use the following code to get rid of the duplicates, and also to 
-- set the pub.type_id to "curated genome annotation":
-- (g4)  ~/work/gmod/schema/chado/schema_upgrade/fix_nonuninque_pubs

-- ALTER TABLE: pub
alter table pub drop constraint pub_unique_key;
alter table pub add constraint pub_unique_key unique (uniquename);
-- there were some problems with the second alter table command.  There's 
-- a duplicate record in pub: 150341 & 150338.  The former has only 11 records
-- attached, in featureprop_pub.  Two of these are also linked to the latter.
-- To fix, first we straighten out featureprop_pub using this:
-- delete from featureprop_pub where featureprop_pub_id in (select featureprop_pub_id from featureprop_pub where pub_id = 150338 and featureprop_id in (select featureprop_id from featureprop_pub where pub_id = 150341));
-- which deletes the two records linked to both 150338 and 150341
-- Once all records are relinked to the 'keeper' pub, do this:
-- delete from featureprop_pub where pub_id = 150341;

-- ALTER TABLE: pubprop
alter table pubprop drop constraint pubprop_pub_id_key;
alter table pubprop add constraint pubprop_pub_id_key unique (pub_id, type_id, rank);



-- ALTER TABLE pub_relationship
alter table pub_relationship add column subject_id int;
update pub_relationship set subject_id = subj_pub_id;
alter table pub_relationship alter column subject_id set not null;
alter table pub_relationship drop column subj_pub_id;
alter table pub_relationship 
      add constraint "$5" foreign key (subject_id) references pub (pub_id) 
      on update no action on delete cascade deferrable initially deferred;

alter table pub_relationship add column object_id int;
update pub_relationship set object_id = obj_pub_id;
alter table pub_relationship alter column object_id set not null;
alter table pub_relationship drop column obj_pub_id;
alter table pub_relationship 
      add constraint "$6" foreign key (subject_id) references pub (pub_id) 
      on update no action on delete cascade deferrable initially deferred;

drop table pub_author;
drop table author;

create table pubauthor (
    pubauthor_id serial not null,
    primary key (pubauthor_id),
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED,
    rank int not null,
    editor boolean default 'false',
    surname varchar(100) not null,
    givennames varchar(100),
    suffix varchar(100),

    constraint pubauthor_c1 unique (pub_id, rank)
);
-- givennames: first name, initials
-- suffix: Jr., Sr., etc       
-- rank: order of author in author list for this pub
-- editor: indicates whether the author is an editor for linked publication
create index pubauthor_idx2 on pubauthor (pub_id);


-- ALTER TABLE pub_dbxref: add column is_current boolean not null default true
alter table pub_dbxref add column is_current boolean;
alter table pub_dbxref alter column is_current set default 'true';
update pub_dbxref set is_current = 'true';
alter table pub_dbxref alter column is_current set not null;


---------------------
-- Sequencee module changes
---------------------
-- ALTER TABLE: featureprop
-- NOTE: BEFORE WE CAN ALTER THE UNIQUE CONSTRAINT ON THIS TABLE, WE NEED TO 
-- IDENTIFY CASES WHERE feature_id,type_id,rank (THE NEW UKEY) IS NOT UNIQUE,
-- AND INCREMENT THE RANK TO MAKE THESE ROWS UNIQUE.

run(g4)   ~/work/gmod/schema/chado/schema_upgrade/sequence/fix_featureprop
to increment featureprop.rank for records where feature_id, type_id, rank is not
unique

alter table featureprop alter column value drop not null;
alter table featureprop alter column value drop default;

alter table featureprop drop constraint featureprop_feature_id_key;
alter table featureprop add constraint featureprop_c1 unique (feature_id, type_id, rank);


-- ALTER TABLE: feature_relationship
alter table feature_relationship add column value text;

-- Add the following new tables:
-- 	feature_relationship_pub
-- 	feature_relationshipprop
-- 	feature_relationshipprop_pub
-- 	feature_cvtermprop
--   this ddl taken from sequence/add_new_sequence_tabs.sql

-- ADD TABLE: feature_relationshipprop
create table feature_relationshipprop (
    feature_relationshipprop_id serial not null,
    primary key (feature_relationshipprop_id),
    feature_relationship_id int not null,
    foreign key (feature_relationship_id) references feature_relationship (feature_relationship_id) on delete cascade,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id) on delete cascade INITIALLY DEFERRED,
    value text null,
    rank int not null default 0,
    constraint feature_relationshipprop_c1 unique (feature_relationship_id,type_id,rank)
);
create index feature_relationshipprop_idx1 on feature_relationshipprop (feature_relationship_id);
create index feature_relationshipprop_idx2 on feature_relationshipprop (type_id);

-- ADD TABLE: feature_relationshipprop_pub
create table feature_relationshipprop_pub (
    feature_relationshipprop_pub_id serial not null,
    primary key (feature_relationshipprop_pub_id),
    feature_relationshipprop_id int not null,
    foreign key (feature_relationshipprop_id) references feature_relationshipprop (feature_relationshipprop_id) on delete cascade INITIALLY DEFERRED,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED,
    constraint feature_relationshipprop_pub_c1 unique (feature_relationshipprop_id,pub_id)
);
create index feature_relationshipprop_pub_idx1 on feature_relationshipprop_pub (feature_relationshipprop_id);
create index feature_relationshipprop_pub_idx2 on feature_relationshipprop_pub (pub_id);

-- ADD TABLE: feature_relationship_pub
create table feature_relationship_pub (
	feature_relationship_pub_id serial not null,
	primary key (feature_relationship_pub_id),
	feature_relationship_id int not null,
	foreign key (feature_relationship_id) references feature_relationship (feature_relationship_id) on delete cascade INITIALLY DEFERRED,
	pub_id int not null,
	foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED,
    constraint feature_relationship_pub_c1 unique (feature_relationship_id,pub_id)
);
create index feature_relationship_pub_idx1 on feature_relationship_pub (feature_relationship_id);
create index feature_relationship_pub_idx2 on feature_relationship_pub (pub_id);
 
-- ADD TABLE: feature_cvtermprop
-- store attributes of feature_cvterm relationships, for instance GO evidence
-- codes
create table feature_cvtermprop (
    feature_cvtermprop_id serial not null,
    primary key (feature_cvtermprop_id),
    feature_cvterm_id int not null,
    foreign key (feature_cvterm_id) references feature_cvterm (feature_cvterm_id) on delete cascade,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id) on delete cascade INITIALLY DEFERRED,
    value text null,
    rank int not null default 0,
    constraint feature_cvtermprop_c1 unique (feature_cvterm_id,type_id,rank)
);
create index feature_cvtermprop_idx1 on feature_cvtermprop (feature_cvterm_id);
create index feature_cvtermprop_idx2 on feature_cvtermprop (type_id);

-- ADD TABLE: feature_cvterm_dbxref
create table feature_cvterm_dbxref (
    feature_cvterm_dbxref_id serial not null,
    primary key (feature_cvterm_dbxref_id),
    feature_cvterm_id int not null,
    foreign key (feature_cvterm_id) references feature_cvterm (feature_cvterm_id) on delete cascade,
    dbxref_id int not null,
    foreign key (dbxref_id) references dbxref (dbxref_id) on delete cascade INITIALLY DEFERRED,
    constraint feature_cvterm_dbxref_c1 unique (feature_cvterm_id,dbxref_id)
);
create index feature_cvterm_dbxref_idx1 on feature_cvterm_dbxref (feature_cvterm_id);
create index feature_cvterm_dbxref_idx2 on feature_cvterm_dbxref (dbxref_id);

COMMENT ON TABLE feature_cvterm_dbxref IS 'Additional dbxrefs for an association. Rows in the feature_cvterm table may be backed up by dbxrefs. For example, a feature_cvterm association that was inferred via a protein-protein interaction may be backed by by refering to the dbxref for the alternate protein. Corresponds to the WITH column in a GO gene association file (but can also be used for other analagous associations). See http://www.geneontology.org/doc/GO.annotation.shtml#file for more details';

-- ALTER TABLE feature_synonym
alter table feature_synonym alter column is_current set default 'true';

---------------------
-- Genetics module changes
---------------------
-- This is a completely new implementation of the genetics module.  Since it 
-- isn't populated, we simply delete all tables and replace with the new ones.
drop table gcontext;
drop table gcontext_relationship;
drop table feature_gcontext;
drop table gcontextprop;
drop table phenstatement;
drop table phendesc;
drop table phenstatement_relationship;
drop table phenstatement_cvterm;
drop table phenstatementprop;
-- It looks like there may be an earlier implementation of the new genetics
-- module in chado_dmel_r4_3.  The drop statements below get rid of that...
drop table interaction;
drop table genotype cascade;
drop table feature_genotype cascade;
drop table environment cascade;
drop table environment_cvterm cascade;
drop table phenotype cascade;
drop table phenotype_cvterm cascade;
drop table phenstatement cascade;
drop table feature_phenotype cascade;
drop table phendesc cascade;
drop table phenotype_comparison cascade;


-- ==========================================
-- USING GENETICS MODULE FROM 13-MAR-2005
-- ==========================================
-- ==========================================
-- Chado genetics module
--
-- redesigned 2003-10-28
--
-- changes 2003-11-10:
--   incorporating suggestions to make everything a gcontext; use 
--   gcontext_relationship to make some gcontexts derivable from others. we 
--   would incorporate environment this way - just add the environment 
--   descriptors as properties of the child gcontext
--
-- changes 2004-06 (Documented by DE: 10-MAR-2005):
--   Many, including rename of gcontext to genotype,  split 
--   phenstatement into phenstatement & phenotype, created environment
--
-- for modeling simple or complex genetic screens
--
-- most genetic statements are about "alleles", although
-- sometimes the definition of allele is stretched
-- (RNAi, engineered construct). genetic statements can
-- also be about large aberrations that take out
-- multiple genes (in FlyBase the policy here is to create
-- alleles for genes within the end-points only, and to
-- attach phenotypic data and so forth to the aberration)
--
-- in chado, a mutant allele is just another feature of type "gene";
-- it is just another form of the canonical wild-type gene feature.
--
-- it is related via an "allele-of" feature_relationship; eg
-- [id:FBgn001, type:gene] <-- [id:FBal001, type:gene]
--
-- with the genetic module, features can either be attached
-- to features of type sequence_variation, or to features of
-- type 'gene' (in the case of mutant alleles).
--
-- if a sequence_variation is large (eg a deficiency) and
-- knocks out multiple genes, then we want to attach the
-- phenotype directly to the sequence variation.
--
-- if the mutation is simple, and affects a single wild-type
-- gene feature, then we would create the mutant allele
-- (another gene feature) and attach the phenotypic data via
-- that feature
--
-- this allows us the option of doing a full structural
-- annotation of the mutant allele gene feature in the future
--
-- we don't necessarily know the molecular details of the
-- the sequence variation (but if we later discover them,
-- we can simply add a featureloc to the sequence_variation
--
-- we can also have sequence variations (of type haplotype_block)
-- that are collections of smaller variations (i.e. via
-- "part_of" feature_relationships) - we could attach phenotypic
-- stuff via this haplotype_block feature or to the alleles it
-- causes
--
-- if we have a mutation affecting the shared region of a nested
-- gene, and we did not know which of the two mutant gene forms were
-- responsible for the resulting phenotype, we would attach the
-- phenotype directly to sequence_variation feature; if we knew
-- which of the two mutant forms of the gene were responsible for
-- the phenotype, we would attach it to them
--
-- we leave open the opportunity for attaching phenotypes via
-- mutant forms of transcripts/proteins/promoters
--
-- we can represent the relationship between a variation and
-- the mutant gene features via a "causes" feature_relationship
--
-- LINKING ALLELES AND VARIATIONS TO PHENOTYPES
--
-- we link via a "genetic context" table - this is essentially
-- the genotype
--
-- most genetic statements take the form
--
-- "allele x[1] shows phenotype P"
--
-- which we represent as "the genetic context defined by x[1] shows P"
--
-- we also allow
--
-- "allele x[1] shows phenotypes P, Q against a background of sev[3]"
--
-- but we actually represent it as
-- "x[1], sev[3] shows phenotypes P, Q"
--
-- x[1] sev[3] is the geneticcontext - genetic contexts can also
-- include things not part of a genotype - e.g. RNAi introduced into cell
--
-- representing environment:
--
-- "allele x[1] shows phenotype P against a background of sev[TS1] at 38 degrees"
-- "allele x[1] shows NO phenotype P against a background of sev[TS1] at 36 degrees"
--
-- we specify this with an environmental context
--
-- we use the phendesc relation to represent the actual organismal 
-- context under observation
--
-- for the description of the phenotype, we are using the standard
-- Observable/Attribute/Value model from the Phenotype Ontology
--
-- we also allow genetic interactions:
--
-- "dx[24] suppresses the wing vein phenotype of H[2]"
--
-- but we actually represent this as:
--
-- "H[2] -> wing vein phenotype P1"
-- "dx[24] -> wing vein phenotype P2"
-- "P2 < P1"
--
-- from this we can do the necessary inference
--
-- complementation:
--
-- "x[1] complements x[2]"
--
-- is actually
--
-- "x[1] -> P1"
-- "x[2] -> P2"
-- "x[2],x[2] -> P3"
-- P3 < P1, P3 < P2
--
-- complementation can be qualified, (eg due to transvection/transsplicing)
--
-- RNAi can be handled - in this case the "allele" is a RNA construct (another
-- feature type) introduced to the cell (but not the genome??) which has an
-- observable phenotypic effect
--
-- "foo[RNAi.1] shows phenotype P"
--
-- mis-expression screens (eg GAL4/UAS) are handled - here the
-- "alleles" are either the construct features, or the insertion features
-- holding the construct (we may need SO type "gal4_insertion" etc);
-- we actually need two alleles in these cases - for both GAL4 and UAS
-- we then record statements such as:
--
-- "Ras85D[V12.S35], gal4[dpp.blk1]  shows phenotype P"
--
-- we use feature_relationships to represent the relationship between
-- the construct and the original non-Scer gene
--
-- we can also record experiments made with other engineered constructs:
-- for example, rescue constructs made from transcripts with an without
-- introns, and recording the difference in phenotype
--
-- the design here is heavily indebted to Rachel Drysdale's paper
-- "Genetic Data in FlyBase"
--
-- ALLELE CLASS
--
-- alleles are amorphs, hypomorphs, etc
--
-- since alleles are features of type gene, we can just use feature_cvterm
-- for this
--
-- SHOULD WE ALSO MAKE THIS CONTEXTUAL TO PHENOTYPE??
--
-- OPEN QUESTION: homologous recombination events
--
-- STOCKS
--
-- this should be in a sub-module of this one; basically we want some
-- kind of linking table between stock and genotype
--
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- ============
-- DEPENDENCIES
-- ============
-- :import feature from sequence
-- :import cvterm from cv
-- :import pub from pub
-- :import dbxref from general
-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


-- ================================================
-- TABLE: genotype
-- ================================================
-- genetic context
-- the uniquename should be derived from the features
-- making up the genoptype
--
-- uniquename: a human-readable unique identifier
--
create table genotype (
    genotype_id serial not null,
    primary key (genotype_id),
    uniquename text not null,      
    description varchar(255),
    constraint genotype_c1 unique (uniquename)
);
create index genotype_idx1 on genotype(uniquename);

COMMENT ON TABLE genotype IS NULL;


-- ===============================================
-- TABLE: feature_genotype
-- ================================================
-- A genotype is defined by a collection of features
-- mutations, balancers, deficiencies, haplotype blocks, engineered
-- constructs
-- 
-- rank can be used for n-ploid organisms
-- 
-- group can be used for distinguishing the chromosomal groups
-- 
-- (RNAi products and so on can be treated as different groups, as
-- they do not fall on a particular chromosome)
-- 
-- OPEN QUESTION: for multicopy transgenes, should we include a 'n_copies'
-- column as well?
-- 
-- chromosome_id       : a feature of SO type 'chromosome'
-- rank                : preserves order
-- group               : spatially distinguishable group
--
create table feature_genotype (
    feature_genotype_id serial not null,
    primary key (feature_genotype_id),
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id) on delete cascade,
    genotype_id int not null,
    foreign key (genotype_id) references genotype (genotype_id) on delete cascade,
    chromosome_id int,
    foreign key (chromosome_id) references feature (feature_id) on delete set null,
    rank int not null,
    cgroup     int not null,
    cvterm_id int not null,
    foreign key (cvterm_id) references cvterm (cvterm_id) on delete cascade,
    constraint feature_genotype_c1 unique (feature_id, genotype_id, cvterm_id)
);
create index feature_genotype_idx1 on feature_genotype (feature_id);
create index feature_genotype_idx2 on feature_genotype (genotype_id);

COMMENT ON TABLE feature_genotype IS NULL;



-- ================================================
-- TABLE: environment
-- ================================================
-- The environmental component of a phenotype description
create table environment (
    environment_id serial not NULL,
    primary key  (environment_id),
    uniquename text not null,
    description text,
    constraint environment_c1 unique (uniquename)
);
create index environment_idx1 on environment(uniquename);

COMMENT ON TABLE environment IS NULL;


-- ================================================
-- TABLE: environment_cvterm
-- ================================================
create table environment_cvterm (
    environment_cvterm_id serial not null,
    primary key  (environment_cvterm_id),
    environment_id int not null,
    foreign key (environment_id) references environment (environment_id) on delete cascade,
    cvterm_id int not null,
    foreign key (cvterm_id) references cvterm (cvterm_id) on delete cascade,
    constraint environment_cvterm_c1 unique (environment_id, cvterm_id)
);
create index environment_cvterm_idx1 on environment_cvterm (environment_id);
create index environment_cvterm_idx2 on environment_cvterm (cvterm_id);

COMMENT ON TABLE environment_cvterm IS NULL;

-- ================================================
-- TABLE: phenotype
-- ================================================
-- a phenotypic statement, or a single atomic phenotypic
-- observation
-- 
-- a controlled sentence describing observable effect of non-wt function
-- 
-- e.g. Obs=eye, attribute=color, cvalue=red
-- 
-- see notes from Phenotype Ontology meeting
-- 
-- observable_id       : e.g. anatomy_part, biological_process
-- attr_id             : e.g. process
-- value               : unconstrained free text value
-- cvalue_id           : constrained value from ontology, e.g. "abnormal", "big"
-- assay_id            : e.g. name of specific test
--
create table phenotype (
    phenotype_id serial not null,
    primary key (phenotype_id),
    uniquename text not null,  
    observable_id int,
    foreign key (observable_id) references cvterm (cvterm_id) on delete cascade,
    attr_id int,
    foreign key (attr_id) references cvterm (cvterm_id) on delete set null,
    value text,
    cvalue_id int,
    foreign key (cvalue_id) references cvterm (cvterm_id) on delete set null,
    assay_id int,
    foreign key (assay_id) references cvterm (cvterm_id) on delete set null,
    constraint phenotype_c1 unique (uniquename)
);
create index phenotype_idx1 on phenotype (cvalue_id);
create index phenotype_idx2 on phenotype (observable_id);
create index phenotype_idx3 on phenotype (attr_id);

COMMENT ON TABLE phenotype IS NULL;


-- ================================================
-- TABLE: phenotype_cvterm
-- ================================================
create table phenotype_cvterm (
    phenotype_cvterm_id serial not null,
    primary key (phenotype_cvterm_id),
    phenotype_id int not null,
    foreign key (phenotype_id) references phenotype (phenotype_id) on delete cascade,
    cvterm_id int not null,
    foreign key (cvterm_id) references cvterm (cvterm_id) on delete cascade,
    constraint phenotype_cvterm_c1 unique (phenotype_id, cvterm_id)
);
create index phenotype_cvterm_idx1 on phenotype_cvterm (phenotype_id);
create index phenotype_cvterm_idx2 on phenotype_cvterm (cvterm_id);

COMMENT ON TABLE phenotype_cvterm IS NULL;


-- ================================================
-- TABLE: phenstatement
-- ================================================
-- Phenotypes are things like "larval lethal".  Phenstatements are things
-- like "dpp[1] is recessive larval lethal". So essentially phenstatement
-- is a linking table expressing the relationship between genotype, environment,
-- and phenotype.
-- 
create table phenstatement (
    phenstatement_id serial not null,
    primary key (phenstatement_id),
    genotype_id int not null,
    foreign key (genotype_id) references genotype (genotype_id) on delete cascade,
    environment_id int not null,
    foreign key (environment_id) references environment (environment_id) on delete cascade,
    phenotype_id int not null,
    foreign key (phenotype_id) references phenotype (phenotype_id) on delete cascade,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id) on delete cascade,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade,
    constraint phenstatement_c1 unique (genotype_id,phenotype_id,environment_id,type_id,pub_id)
);
create index phenstatement_idx1 on phenstatement (genotype_id);
create index phenstatement_idx2 on phenstatement (phenotype_id);

COMMENT ON TABLE phenstatement IS NULL;


-- ================================================
-- TABLE: feature_phenotype
-- ================================================
create table feature_phenotype (
    feature_phenotype_id serial not null,
    primary key (feature_phenotype_id),
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id) on delete cascade,
    phenotype_id int not null,
    foreign key (phenotype_id) references phenotype (phenotype_id) on delete cascade,
    constraint feature_phenotype_c1 unique (feature_id,phenotype_id)       
);
create index feature_phenotype_idx1 on feature_phenotype (feature_id);
create index feature_phenotype_idx2 on feature_phenotype (phenotype_id);

COMMENT ON TABLE feature_phenotype IS NULL;


-- ================================================
-- TABLE: phendesc
-- ================================================
-- RELATION: phendesc
--
-- a summary of a _set_ of phenotypic statements for any one
-- gcontext made in any one
-- publication
-- 
create table phendesc (
    phendesc_id serial not null,
    primary key (phendesc_id),
    genotype_id int not null,
    foreign key (genotype_id) references genotype (genotype_id) on delete cascade,
    environment_id int not null,
    foreign key (environment_id) references environment ( environment_id) on delete cascade,
    description text not null,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade,
    constraint phendesc_c1 unique (genotype_id,environment_id,pub_id)
);
create index phendesc_idx1 on phendesc (genotype_id);
create index phendesc_idx2 on phendesc (environment_id);
create index phendesc_idx3 on phendesc (pub_id);

COMMENT ON TABLE phendesc IS NULL;


-- ================================================
-- TABLE: phenotype_comparison
-- ================================================
-- comparison of phenotypes
-- eg, genotype1/environment1/phenotype1 "non-suppressible" wrt 
-- genotype2/environment2/phenotype2
-- 
create table phenotype_comparison (
    phenotype_comparison_id serial not null,
    primary key (phenotype_comparison_id),
    genotype1_id int not null,
        foreign key (genotype1_id) references genotype (genotype_id) on delete cascade,
    environment1_id int not null,
        foreign key (environment1_id) references environment (environment_id) on delete cascade,
    genotype2_id int not null,
        foreign key (genotype2_id) references genotype (genotype_id) on delete cascade,
    environment2_id int not null,
        foreign key (environment2_id) references environment (environment_id) on delete cascade,
    phenotype1_id int not null,
        foreign key (phenotype1_id) references phenotype (phenotype_id) on delete cascade,
    phenotype2_id int,
        foreign key (phenotype2_id) references phenotype (phenotype_id) on delete cascade,
    type_id int not null,
        foreign key (type_id) references cvterm (cvterm_id) on delete cascade,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade,
    constraint phenotype_comparison_c1 unique (genotype1_id,environment1_id,genotype2_id,environment2_id,phenotype1_id,type_id,pub_id)
);

COMMENT ON TABLE phenotype_comparison IS NULL;

-- ==========================================
-- END OF GENETICS MODULE FROM 13-MAR-2005
-- ==========================================

---------------------
-- Map module changes
---------------------
-- There are some differences between the map module tables in chado_dmel_r4_3
-- and the ddl in sourceforge.  Since these tables dont have any data 
-- implemented in them at the moment, we'll just drop them all and create anew 
-- using the sourceforge ddl

drop table featuremap_pub;
drop table featuremap;
drop table featurerange;
drop table featurepos;

-- NOTE: this module is all due for revision...

-- A possibly problematic case is where we want to localize an object
-- to the left or right of a feature (but not within it):
--
--                     |---------|  feature-to-map
--        ------------------------------------------------- map
--                |------|         |----------|   features to map wrt
--
-- How do we map the 3' end of the feature-to-map?

-- TODO:  Get a comprehensive set of mapping use-cases 

-- one set of use-cases is aberrations (which will all be involved with this 
-- module).   Simple aberrations should be do-able, but what about cases where
-- a breakpoint interrupts a gene?  This would be an example of the problematic
-- case above...  (or?)

-- ================================================
-- TABLE: featuremap
-- ================================================

create table featuremap (
    featuremap_id serial not null,
    primary key (featuremap_id),
    name varchar(255),
    description text,
    unittype_id int null,
    foreign key (unittype_id) references cvterm (cvterm_id) on delete set null INITIALLY DEFERRED,
    constraint featuremap_c1 unique (name)
);

-- ================================================
-- TABLE: featurerange
-- ================================================

-- In cases where the start and end of a mapped feature is a range, leftendf
-- and rightstartf are populated.  
-- featuremap_id is the id of the feature being mapped
-- leftstartf_id, leftendf_id, rightstartf_id, rightendf_id are the ids of
-- features with respect to with the feature is being mapped.  These may
-- be cytological bands.

create table featurerange (
    featurerange_id serial not null,
    primary key (featurerange_id),
    featuremap_id int not null,
    foreign key (featuremap_id) references featuremap (featuremap_id) on delete cascade INITIALLY DEFERRED,
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    leftstartf_id int not null,
    foreign key (leftstartf_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    leftendf_id int,
    foreign key (leftendf_id) references feature (feature_id) on delete set null INITIALLY DEFERRED,
    rightstartf_id int,
    foreign key (rightstartf_id) references feature (feature_id) on delete set null INITIALLY DEFERRED,
    rightendf_id int not null,
    foreign key (rightendf_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    rangestr varchar(255)
);
create index featurerange_idx1 on featurerange (featuremap_id);
create index featurerange_idx2 on featurerange (feature_id);
create index featurerange_idx3 on featurerange (leftstartf_id);
create index featurerange_idx4 on featurerange (leftendf_id);
create index featurerange_idx5 on featurerange (rightstartf_id);
create index featurerange_idx6 on featurerange (rightendf_id);

-- ================================================
-- TABLE: featurepos
-- ================================================

create table featurepos (
    featurepos_id serial not null,
    primary key (featurepos_id),
    featuremap_id serial not null,
    foreign key (featuremap_id) references featuremap (featuremap_id) on delete cascade INITIALLY DEFERRED,
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    map_feature_id int not null,
    foreign key (map_feature_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    mappos float not null
);
-- map_feature_id links to the feature (map) upon which the feature is
-- being localized
create index featurepos_idx1 on featurepos (featuremap_id);
create index featurepos_idx2 on featurepos (feature_id);
create index featurepos_idx3 on featurepos (map_feature_id);


-- ================================================
-- TABLE: featuremap_pub
-- ================================================

create table featuremap_pub (
    featuremap_pub_id serial not null,
    primary key (featuremap_pub_id),
    featuremap_id int not null,
    foreign key (featuremap_id) references featuremap (featuremap_id) on delete cascade INITIALLY DEFERRED,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED
);
create index featuremap_pub_idx1 on featuremap_pub (featuremap_id);
create index featuremap_pub_idx2 on featuremap_pub (pub_id);



---------------------
-- Library module changes
---------------------
-- The library module is new, we add it straight from the sourceforge ddl
-- ================================================
-- TABLE: library
-- ================================================

create table library (
    library_id serial not null,
    primary key (library_id),
    organism_id int not null,
    foreign key (organism_id) references organism (organism_id),
    name varchar(255),
    uniquename text not null,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id),
    constraint library_c1 unique (organism_id,uniquename,type_id)
);
-- The type_id foreign key links to a controlled vocabulary of library types.
-- examples of this would be: 'cDNA_library' or 'genomic_library'
create index library_name_ind1 on library(name);
create index library_idx1 on library (organism_id);
create index library_idx2 on library (type_id);
create index library_idx3 on library (uniquename);


-- ================================================
-- TABLE: library_synonym
-- ================================================

create table library_synonym (
    library_synonym_id serial not null,
    primary key (library_synonym_id),
    synonym_id int not null,
    foreign key (synonym_id) references synonym (synonym_id) on delete cascade INITIALLY DEFERRED,
    library_id int not null,
    foreign key (library_id) references library (library_id) on delete cascade INITIALLY DEFERRED,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED,
    is_current boolean not null default 'true',
    is_internal boolean not null default 'false',
    constraint library_synonym_c1 unique (synonym_id,library_id,pub_id)
);
-- pub_id: the pub_id link is for relating the usage of a given synonym to the
-- publication in which it was used
-- is_current: the is_current bit indicates whether the linked synonym is the 
-- current -official- symbol for the linked library
-- is_internal: typically a synonym exists so that somebody querying the db 
-- with an obsolete name can find the object they're looking for (under its 
-- current name.  If the synonym has been used publicly & deliberately (eg in 
-- a paper), it my also be listed in reports as a synonym.   If the synonym 
-- was not used deliberately (eg, there was a typo which went public), then 
-- the is_internal bit may be set to 'true' so that it is known that the 
-- synonym is "internal" and should be queryable but should not be listed 
-- in reports as a valid synonym.
create index library_synonym_idx1 on library_synonym (synonym_id);
create index library_synonym_idx2 on library_synonym (library_id);
create index library_synonym_idx3 on library_synonym (pub_id);


-- ================================================
-- TABLE: library_pub
-- ================================================

create table library_pub (
    library_pub_id serial not null,
    primary key (library_pub_id),
    library_id int not null,
    foreign key (library_id) references library (library_id) on delete cascade INITIALLY DEFERRED,
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id) on delete cascade INITIALLY DEFERRED,
    constraint library_pub_c1 unique (library_id,pub_id)
);
create index library_pub_idx1 on library_pub (library_id);
create index library_pub_idx2 on library_pub (pub_id);


-- ================================================
-- TABLE: libraryprop
-- ================================================

create table libraryprop (
    libraryprop_id serial not null,
    primary key (libraryprop_id),
    library_id int not null,
    foreign key (library_id) references library (library_id) on delete cascade INITIALLY DEFERRED,
    type_id int not null,
    foreign key (type_id) references cvterm (cvterm_id),
    value text null,
    rank int not null default 0,
    constraint libraryprop_c1 unique (library_id,type_id,rank)
);
create index libraryprop_idx1 on libraryprop (library_id);
create index libraryprop_idx2 on libraryprop (type_id);


-- ================================================
-- TABLE: library_cvterm
-- ================================================

create table library_cvterm (
    library_cvterm_id serial not null,
    primary key (library_cvterm_id),
    library_id int not null,
    foreign key (library_id) references library (library_id) on delete cascade INITIALLY DEFERRED,
    cvterm_id int not null,
    foreign key (cvterm_id) references cvterm (cvterm_id),
    pub_id int not null,
    foreign key (pub_id) references pub (pub_id),
    constraint library_cvterm_c1 unique (library_id,cvterm_id,pub_id)
);
-- The table library_cvterm links a library to controlled vocabularies which
-- describe the library.  For instance, there might be a link to the anatomy
-- cv for "head" or "testes" for a head or testes library.
create index library_cvterm_idx1 on library_cvterm (library_id);
create index library_cvterm_idx2 on library_cvterm (cvterm_id);
create index library_cvterm_idx3 on library_cvterm (pub_id);


-- ================================================
-- TABLE: library_feature
-- ================================================

create table library_feature (
    library_feature_id serial not null,
    primary key (library_feature_id),
    library_id int not null,
    foreign key (library_id) references library (library_id) on delete cascade INITIALLY DEFERRED,
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id) on delete cascade INITIALLY DEFERRED,
    constraint library_feature_c1 unique (library_id,feature_id)
);
-- library_feature links a library to the clones which are contained in the 
-- library.  Examples of such linked features might be "cDNA_clone" or 
-- "genomic_clone".
create index library_feature_idx1 on library_feature (library_id);
create index library_feature_idx2 on library_feature (feature_id);


---------------------
-- Grant permissions on all new tables
---------------------

grant ALL on tableinfo to public;
grant ALL on tableinfo_tableinfo_id_seq to public;
grant ALL on project to public;
grant ALL on project_project_id_seq to public;
grant ALL on cvtermprop  to public;
grant ALL on cvtermpro_cvtermpro_id_seq to public;
grant ALL on dbxrefprop to public;
grant ALL on dbxrefprop_dbxrefprop_id_seq to public;
grant ALL on pubauthor to public;
grant ALL on pubauthor_pubauthor_id_seq to public;
grant ALL on feature_relationshipprop to public;
grant ALL on feature_relationshipprop_feature_relationshipprop_id_seq to public;
grant ALL on feature_relationshipprop_pub to public;
grant ALL on feature_relationshipprop_pub_feature_relationshipprop_pub_id_seq to public;
grant ALL on feature_relationship_pub to public;
grant ALL on feature_relationship_pub_feature_relationship_pub_id_seq to public;
grant ALL on feature_cvtermprop to public;
grant ALL on feature_cvtermprop_feature_cvtermprop_id_seq to public;
grant ALL on feature_cvterm_dbxref to public;
grant ALL on feature_cvterm_dbxref_feature_cvterm_dbxref_id_seq to public;
grant ALL on genotype to public;
grant ALL on genotype_genotype_id_seq to public;
grant ALL on feature_genotype to public;
grant ALL on feature_genotype_feature_genotype_id_seq to public;
grant ALL on environment to public;
grant ALL on environment_environment_id_seq to public;
grant ALL on environment_cvterm to public;
grant ALL on environment_cvterm_environment_cvterm_id_seq to public;
grant ALL on phenotype to public;
grant ALL on phenotype_phenotype_id_seq to public;
grant ALL on phenotype_cvterm to public;
grant ALL on phenotype_cvterm_phenotype_cvterm_id_seq to public;
grant ALL on phenstatement to public;
grant ALL on phenstatement_phenstatement_id_seq to public;
grant ALL on feature_phenotype to public;
grant ALL on feature_phenotype_feature_phenotype_id_seq to public;
grant ALL on phendesc to public;
grant ALL on phendesc_phendesc_id_seq to public;
grant ALL on phenotype_comparison to public;
grant ALL on phenotype_comparison_phenotype_comparison_id_seq to public;
grant ALL on featuremap to public;
grant ALL on featuremap_featuremap_id_seq to public;
grant ALL on featurerange to public;
grant ALL on featurerange_featurerange_id_seq to public;
grant ALL on featurepos to public;
grant ALL on featurepos_featurepos_id_seq to public;
grant ALL on featuremap_pub to public;
grant ALL on featuremap_pub_featuremap_pub_id_seq to public;
grant ALL on library to public;
grant ALL on library_library_id_seq to public;
grant ALL on library_synonym to public;
grant ALL on library_synonym_library_synonym_id_seq to public;
grant ALL on library_pub to public;
grant ALL on library_pub_library_pub_id_seq to public;
grant ALL on libraryprop to public;
grant ALL on libraryprop_libraryprop_id_seq to public;
grant ALL on library_cvterm to public;
grant ALL on library_cvterm_library_cvterm_id_seq to public;
grant ALL on library_feature to public;
grant ALL on library_feature_library_feature_id_seq to public;



