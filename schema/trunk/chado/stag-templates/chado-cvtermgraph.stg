:SELECT 
  *
:FROM
  xcvterm 
  INNER JOIN cvtermpath        
          ON (cvterm.cvterm_id=cvtermpath.object_id)
  INNER JOIN xcvterm AS subj_xcvterm
          ON (subj_xcvterm.cvterm_id=cvterm_relationship.subject_id)
  LEFT OUTER JOIN cvterm_relationship
          ON (cvtermpath.subject_id=cvterm_relationship.subject_id)
:WHERE
    [xcvterm.accession => &cvterm_accession&]
    [xcvterm.db => &cvterm_db&]
    [xcvterm.name => &cvterm_name&]
    [xcvterm.cvname => &cvterm_cvname&]
    [xcvterm.definition => &cvterm_definition&]

    [subj_xcvterm.accession => &subj_cvterm_accession&]
    [subj_xcvterm.db => &subj_cvterm_db&]
    [subj_xcvterm.name => &subj_cvterm_name&]
    [subj_xcvterm.cvname => &subj_cvterm_cvname&]
    [subj_xcvterm.definition => &subj_cvterm_definition&]
:ORDER BY xcvterm.name
:USE NESTING (set(xcvterm(cvtermpath(subj_xcvterm(cvterm_relationship)))))

//
schema: chado
desc: 

  Fetches a graph based around a cvterm

  The graph is either built from object to subjects (downwards), based
  around xcvterm

  OR it is build from subject to objects (upwards), based around
  subj_xcvterm

  Of course, the data structure returned is not a graph
  
  As XML/Stag, the resulting data will have the object cvterm as root
  element, and will nest all descendents directly underneath. each
  descendent (subj_xcvterm) will have it's parent relationships nested
  underneath it (with trailing cvterm_ids) - from this you can
  reconstruct the whole graph

  REQUIRES: modules/sequence/bdgp/bdgp-views.sql

example_input: cvterm_accession => SELECT DISTINCT cvterm.accession FROM cvterm WHERE cvterm_id IN (SELECT object_id FROM cvterm_relationship)
example_input: cvterm_name => SELECT DISTINCT cvterm.name FROM cvterm WHERE cvterm_id IN (SELECT object_id FROM cvterm_relationship)

