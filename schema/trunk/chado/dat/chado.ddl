-- ================================================
-- TABLE: analysis
-- ================================================

-- an analysis is a particular execution of a computational analysis;
-- it may be a blast of one sequence against another, or an all by all
-- blast, or a different kind of analysis altogether.
-- it is a single unit of computation - if different blast runs
-- were instantiated over differnet query sequences, there would
-- be multiple entries here.
--
-- name: 
--   a way of grouping analyses. this should be a handy
--   short identifier that can help people find an analysis they
--   want. for instance "tRNAscan", "cDNA", "FlyPep", "SwissProt"
--   it should not be assumed to be unique. for instance, there may
--   be lots of seperate analyses done against a cDNA database.
--
-- program: 
--   e.g. blastx, blastp, sim4, genscan
--
-- programversion:
--   e.g. TBLASTX 2.0MP-WashU [09-Nov-2000]
--
-- algorithm:
--   e.g. blast
--
-- sourcename: 
--   e.g. cDNA, SwissProt
--
-- queryfeature_id:
--   the sequence that was used as the query sequence can be
--   optionally included via queryfeature_id - even though this
--   is redundant with the tables below. this can still
--   be useful - for instance, we may have an analysis that blasts
--   contigs against a database. we may then transform those hits
--   into global coordinates; it may be useful to keep a record
--   of which contig was blasted as the query.
--
--
-- MAPPING (bioperl): maps to Bio::Search::Result::ResultI

--
-- sourceuri: 
--   This is an optional permanent URL/URI for the source of the
--   analysis. The idea is that someone could recreate the analysis
--   directly by going to this URI and fetching the source data
--   (eg the blast database, or the training model).

create table analysis (
    analysis_id serial not null,
    primary key (analysis_id),
    name varchar(255),
    description text,
    program varchar(255) not null,
    programversion varchar(255) not null,
    algorithm varchar(255),
    sourcename varchar(255),
    sourceversion varchar(255),
    sourceuri text,
    queryfeature_id int,
    foreign key (queryfeature_id) references feature (feature_id),
    timeexecuted timestamp not null default current_timestamp,

    unique(program, programversion, sourcename)
);
create index analysis_idx1 on analysis (queryfeature_id);


-- ================================================
-- TABLE: analysisprop
-- ================================================

-- analyses can have various properties attached - eg the parameters
-- used in running a blast

create table analysisprop (
    analysisprop_id serial not null,
    primary key (analysisprop_id),
    analysis_id int not null,
    foreign key (analysis_id) references analysis (analysis_id),
    pkey_id int not null,
    foreign key (pkey_id) references cvterm (cvterm_id),
    pval text,

    unique(analysis_id, pkey_id, pval)
);
create index analysisprop_idx1 on analysisprop (analysis_id);
create index analysisprop_idx2 on analysisprop (pkey_id);


-- ================================================
-- TABLE: analysisfeature
-- ================================================

-- computational analyses generate features (eg genscan generates
-- transcripts and exons; sim4 alignments generate similarity/match
-- features)

-- analysisfeatures are stored using the feature table from
-- the sequence module. the analysisfeature table is used to
-- decorate these features, with analysis specific attributes.
--
-- a feature is an analysisfeature if and only if there is
-- a corresponding entry in the analysisfeature table
--
-- analysisfeatures will have two or more featureloc entries,
-- with rank indicating query/subject

--  analysis_id:
--    scoredsets are grouped into analyses
--
--  rawscore:
--    this is the native score generated by the program; for example,
--    the bitscore generated by blast, sim4 or genscan scores.
--    one should not assume that high is necessarily better than low.
--
--  normscore:
--    this is the rawscore but semi-normalized. complete normalization
--    to allow comparison of features generated by different programs
--    would be nice but too difficult. instead the normalization should
--    strive to enforce the following semantics:
--
--    * normscores are floating point numbers >= 0
--    * high normscores are better than low one.
--
--    for most programs, it would be sufficient to make the normscore
--    the same as this rawscore, providing these semantics are
--    satisfied.
--
--  significance:
--    this is some kind of expectation or probability metric,
--    representing the probability that the scoredset would appear
--    randomly given the model.
--    as such, any program or person querying this table can assume
--    the following semantics:
--     * 0 <= significance <= n, where n is a positive number, theoretically
--       unbounded but unlikely to be more than 10
--     * low numbers are better than high numbers.
--
--  identity:
--    percent identity between the locations compared
--
--  note that these 4 metrics do not cover the full range of scores
--  possible; it would be undesirable to list every score possible, as
--  this should be kept extensible. instead, for non-standard scores, use
--  the scoredsetprop table.

create table analysisfeature (
    analysisfeature_id serial not null,
    primary key (analysisfeature_id),
    feature_id int not null,
    foreign key (feature_id) references feature (feature_id),
    analysis_id int not null,
    foreign key (analysis_id) references analysis (analysis_id),
    rawscore double precision,
    normscore double precision,
    significance double precision,
    identity double precision,

    unique (feature_id,analysis_id)
);
create index analysisfeature_idx1 on analysisfeature (feature_id);
create index analysisfeature_idx2 on analysisfeature (analysis_id);
--- term

CREATE VIEW term AS
SELECT
 cvterm_id AS id,
--is this correct?  what is acc? -allen
 termdefinition AS acc,
 name      AS name,
 0         AS is_obsolete,
 0         AS is_root
FROM cvterm;

CREATE RULE "_RuleI_term" AS
 ON INSERT TO term
 DO INSTEAD
  INSERT INTO cvterm
  (termdefinition, name)
  VALUES
  (NEW.acc, NEW.name);

CREATE RULE "_RuleU_term" AS
 ON UPDATE TO term
 DO INSTEAD
  UPDATE cvterm
  SET
  termdefinition = NEW.acc,
  name      = NEW.name
  WHERE cvterm_id = OLD.id;

CREATE RULE "_RuleD_term" AS
 ON DELETE TO term
 DO INSTEAD
  DELETE FROM cvterm
  WHERE cvterm_id = OLD.id;

--- term_definition

CREATE VIEW term_definition AS
SELECT
 cvterm_id AS term_id,
 termdefinition AS term_definition
FROM cvterm
WHERE termdefinition IS NOT NULL;

CREATE RULE "_RuleI_term_definition" AS
 ON INSERT TO term_definition
 DO INSTEAD
  UPDATE cvterm
  SET
  termdefinition = NEW.term_definition
  WHERE cvterm_id = NEW.term_id;

CREATE RULE "_RuleU_term_definition" AS
 ON UPDATE TO term_definition
 DO INSTEAD
  UPDATE cvterm
  SET
  termdefinition = NEW.term_definition
  WHERE cvterm_id = OLD.term_id;

CREATE RULE "_RuleD_term_definition" AS
 ON DELETE TO term_definition
 DO INSTEAD
  UPDATE cvterm
  SET
  termdefinition = NULL
  WHERE cvterm_id = OLD.term_id;

--- term2term

CREATE VIEW term2term AS
SELECT
 cvrelationship_id AS id,
 reltype_id        AS relationship_type_id,
 objterm_id        AS term1_id,
 subjterm_id       AS term2_id
FROM cvrelationship;

CREATE RULE "_RuleI_term2term" AS
 ON INSERT TO term2term
 DO INSTEAD
  INSERT INTO cvrelationship
  (
   reltype_id,
   objterm_id,
   subjterm_id)
  VALUES
  (
   NEW.relationship_type_id, 
   NEW.term1_id,
   NEW.term2_id
  );

CREATE RULE "_RuleU_term2term" AS
 ON UPDATE TO term2term
 DO INSTEAD
  UPDATE cvrelationship
  SET
 reltype_id        = NEW.relationship_type_id,
 objterm_id        = NEW.term1_id,
 subjterm_id       = NEW.term2_id
  WHERE cvrelationship_id = OLD.id;

CREATE RULE "_RuleD_term2term" AS
 ON DELETE TO term2term
 DO INSTEAD
  DELETE FROM cvrelationship
  WHERE cvrelationship_id = OLD.id;

--- graph_path

CREATE VIEW graph_path AS
SELECT
 cvpath_id AS id,
 NULL              AS relationship_type_id,
 objterm_id        AS term1_id,
 subjterm_id       AS term2_id,
 pathdistance      AS distance
FROM cvpath;

CREATE RULE "_RuleI_graph_path" AS
 ON INSERT TO graph_path
 DO INSTEAD
  INSERT INTO cvpath
  (
   reltype_id,
   objterm_id,
   subjterm_id,
   pathdistance)
  VALUES
  (
   NULL,
   NEW.term1_id,
   NEW.term2_id,
   NEW.distance
  );

CREATE RULE "_RuleU_graph_path" AS
 ON UPDATE TO graph_path
 DO INSTEAD
  UPDATE cvpath
  SET
 reltype_id        = NULL,
 objterm_id        = NEW.term1_id,
 subjterm_id       = NEW.term2_id,
 pathdistance      = NEW.distance
  WHERE cvpath_id = OLD.id;

CREATE RULE "_RuleD_graph_path" AS
 ON DELETE TO graph_path
 DO INSTEAD
  DELETE FROM cvpath
  WHERE cvpath_id = OLD.id;

--- term_synonym

CREATE VIEW term_synonym AS
SELECT
 cvterm_id AS term_id,
 termsynonym  AS term_synonym
FROM cvtermsynonym;

CREATE RULE "_RuleI_term_synonym" AS
 ON INSERT TO term_synonym
 DO INSTEAD
  INSERT INTO cvtermsynonym
  (cvterm_id, termsynonym)
  VALUES
  (NEW.term_id, NEW.term_synonym);

CREATE RULE "_RuleU_term_synonym" AS
 ON UPDATE TO term_synonym
 DO INSTEAD
  UPDATE cvtermsynonym
  SET
 cvterm_id = NEW.term_id,
 termsynonym  = NEW.term_synonym
  WHERE cvterm_id = OLD.term_id AND termsynonym = OLD.term_synonym;

CREATE RULE "_RuleD_term_synonym" AS
 ON DELETE TO term_synonym
 DO INSTEAD
  DELETE FROM cvtermsynonym
  WHERE cvterm_id = OLD.term_id AND termsynonym = OLD.term_synonym;

--- term_dbxref

CREATE VIEW term_dbxref AS
SELECT
 cvterm_id AS term_id,
 dbxref_id  AS dbxref_id
FROM cvterm_dbxref;

CREATE RULE "_RuleI_term_dbxref" AS
 ON INSERT TO term_dbxref
 DO INSTEAD
  INSERT INTO cvterm_dbxref
  (cvterm_id, dbxref_id)
  VALUES
  (NEW.term_id, NEW.dbxref_id);

CREATE RULE "_RuleU_term_dbxref" AS
 ON UPDATE TO term_dbxref
 DO INSTEAD
  UPDATE cvterm_dbxref
  SET
 cvterm_id = NEW.term_id,
 dbxref_id  = NEW.dbxref_id
  WHERE cvterm_id = OLD.term_id AND dbxref_id = OLD.dbxref_id;

CREATE RULE "_RuleD_term_dbxref" AS
 ON DELETE TO term_dbxref
 DO INSTEAD
  DELETE FROM cvterm_dbxref
  WHERE cvterm_id = OLD.term_id AND dbxref_id = OLD.dbxref_id;

---- dbxref - tricky, namespace clash...

-- The cvterm module design is based on the ontology 

-- ================================================
-- TABLE: cv
-- ================================================

create table cv (
       cv_id serial not null,
       primary key (cv_id),
       cvname varchar(255) not null,
       cvdefinition text,

       unique(cvname)
);

-- ================================================
-- TABLE: cvterm
-- ================================================

create table cvterm (
       cvterm_id serial not null,
       primary key (cvterm_id),
       cv_id int not null,
       foreign key (cv_id) references cv (cv_id),
       name varchar(255) not null,
       termdefinition text,
       dbxref_id int,
       foreign key (dbxref_id) references dbxref (dbxref_id),

       unique(name, cv_id)
);
create index cvterm_idx1 on cvterm (cv_id);
-- the primary dbxref for this term.  Other dbxrefs may be cvterm_dbxref
-- The unique key on termname, cv_id ensures that all terms are 
-- unique within a given cv


-- ================================================
-- TABLE: cvrelationship
-- ================================================

create table cvrelationship (
       cvrelationship_id serial not null,
       primary key (cvrelationship_id),
       reltype_id int not null,
       foreign key (reltype_id) references cvterm (cvterm_id),
       subjterm_id int not null,
       foreign key (subjterm_id) references cvterm (cvterm_id),
       objterm_id int not null,
       foreign key (objterm_id) references cvterm (cvterm_id),

       unique(reltype_id, subjterm_id, objterm_id)
);
create index cvrelationship_idx1 on cvrelationship (reltype_id);
create index cvrelationship_idx2 on cvrelationship (subjterm_id);
create index cvrelationship_idx3 on cvrelationship (objterm_id);


-- ================================================
-- TABLE: cvpath
-- ================================================

create table cvpath (
       cvpath_id serial not null,
       primary key (cvpath_id),
       reltype_id int,
       foreign key (reltype_id) references cvterm (cvterm_id),
       subjterm_id int not null,
       foreign key (subjterm_id) references cvterm (cvterm_id),
       objterm_id int not null,
       foreign key (objterm_id) references cvterm (cvterm_id),
       cv_id int not null,
       foreign key (cv_id) references cv (cv_id),
       pathdistance int,

       unique (subjterm_id, objterm_id)
);
create index cvpath_idx1 on cvpath (reltype_id);
create index cvpath_idx2 on cvpath (subjterm_id);
create index cvpath_idx3 on cvpath (objterm_id);
create index cvpath_idx4 on cvpath (cv_id);


-- ================================================
-- TABLE: cvtermsynonym
-- ================================================

create table cvtermsynonym (
       cvtermsynonym_id int not null,
       primary key (cvtermsynonym_id),
       cvterm_id int not null,
       foreign key (cvterm_id) references cvterm (cvterm_id),
       termsynonym varchar(255) not null,

       unique(cvterm_id, termsynonym)
);
create index cvtermsynonym_idx1 on cvtermsynonym (cvterm_id);


-- ================================================
-- TABLE: cvterm_dbxref
-- ================================================

create table cvterm_dbxref (
       cvterm_dbxref_id serial not null,
       primary key (cvterm_dbxref_id),
       cvterm_id int not null,
       foreign key (cvterm_id) references cvterm (cvterm_id),
       dbxref_id int not null,
       foreign key (dbxref_id) references dbxref (dbxref_id),

       unique(cvterm_id, dbxref_id)
);
create index cvterm_dbxref_idx1 on cvterm_dbxref (cvterm_id);
create index cvterm_dbxref_idx2 on cvterm_dbxref (dbxref_id);

-- This module is totally dependant on the sequence module.  Objects in the
-- genetic module cannot connect to expression data except by going via the
-- sequence module

-- We assume that we'll *always* have a controlled vocabulary for expression 
-- data.   If an experiment used a set of cv terms different from the ones
-- FlyBase uses (bodypart cv, bodypart qualifier cv, and the temporal cv
-- (which is stored in the curaton.doc under GAT6 btw)), they'd have to give
-- us the cv terms, which we could load into the cv module

-- ================================================
-- TABLE: expression
-- ================================================

create table expression (
       expression_id serial not null,
       primary key (expression_id),
       description text
);

-- ================================================
-- TABLE: feature_expression
-- ================================================

create table feature_expression (
       feature_expression_id serial not null,
       primary key (feature_expression_id),
       expression_id int not null,
       foreign key (expression_id) references expression (expression_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),

       unique(expression_id,feature_id)       
);
create index feature_expression_idx1 on feature_expression (expression_id);
create index feature_expression_idx2 on feature_expression (feature_id);


-- ================================================
-- TABLE: expression_cvterm
-- ================================================

-- What are the possibities of combination when more than one cvterm is used
-- in a field?   
--
-- For eg (in <p> here):   <t> E | early <a> <p> anterior & dorsal
-- If the two terms used in a particular field are co-equal (both from the
-- same CV, is the relation always "&"?   May we find "or"?
--
-- Obviously another case is when a bodypart term and a bodypart qualifier
-- term are used in a specific field, eg:
--   <t> L | third instar <a> larval antennal segment sensilla | subset <p  
--
-- WRT the three-part <t><a><p> statements, are the values in the different 
-- parts *always* from different vocabularies in proforma.CV?   If not,
-- we'll need to have some kind of type qualifier telling us whether the
-- cvterm used is <t>, <a>, or <p>

create table expression_cvterm (
       expression_cvterm_id serial not null,
       primary key (expression_cvterm_id),
       expression_id int not null,
       foreign key (expression_id) references expression (expression_id),
       cvterm_id int not null,
       foreign key (cvterm_id) references cvterm (cvterm_id),
       rank int not null,

       unique(expression_id,cvterm_id)
);
create index expression_cvterm_idx1 on expression_cvterm (expression_id);
create index expression_cvterm_idx2 on expression_cvterm (cvterm_id);


-- ================================================
-- TABLE: expression_pub
-- ================================================

create table expression_pub (
       expression_pub_id serial not null,
       primary key (expression_pub_id),
       expression_id int not null,
       foreign key (expression_id) references expression (expression_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),

       unique(expression_id,pub_id)       
);
create index expression_pub_idx1 on expression_pub (expression_id);
create index expression_pub_idx2 on expression_pub (pub_id);


-- ================================================
-- TABLE: eimage
-- ================================================

create table eimage (
       eimage_id serial not null,
       primary key (eimage_id),
       eimage_data text,
       eimage_type varchar(255) not null,
       image_uri varchar(255)
);
-- we expect images in eimage_data (eg jpegs) to be uuencoded
-- describes the type of data in eimage_data


-- ================================================
-- TABLE: expression_image
-- ================================================

create table expression_image (
       expression_image_id serial not null,
       primary key (expression_image_id),
       expression_id int not null,
       foreign key (expression_id) references expression (expression_id),
       eimage_id int not null,
       foreign key (eimage_id) references eimage (eimage_id),

       unique(expression_id,eimage_id)
);
create index expression_image_idx1 on expression_image (expression_id);
create index expression_image_idx2 on expression_image (eimage_id);
--changed some of the pk/fk names to conform to chado conventions (removed _)
--changed field names (removed _s)
--changed some tablenames by adding _ to link tables, dropping _ where no link.
--dropped trailing '-imp' off some tablenames
--dropped external_database_release_id fields
--mapped contact links to author table
--mapped bibliographic references to pub table
--source_id changed to dbxref_id

--ok
--drop table acquisition;
create table acquisition (
    acquisition_id           																				serial not null,
	primary key (acquisition_id),
    assay_id                 																				int not null,
	foreign key (assay_id) references  assay (assay_id),
    protocol_id              																				int null,
	foreign key (protocol_id) references protocol (protocol_id),
    channel_id               																				int null,
	foreign key (channel_id) references channel (channel_id),
    acquisitiondate          																				date null,
    name                     																				varchar(100) null,
    uri                      																				varchar(255) null
);

--ok
--drop table if exists acquisitionparam;
create table acquisitionparam (
    acquisitionparam_id      																				serial not null,
	primary key (acquisitionparam_id),
    acquisition_id           																				int not null,
	foreign key (acquisition_id) references acquisition (acquisition_id),
    name                     																				varchar(100) not null,
    value                    																				varchar(50) not null
);

--ok
--drop table if exists analysis;
create table analysis (
    analysis_id              																				serial not null,
	primary key (analysis_id),
    name                     																				varchar(100) not null,
    description              																				varchar(500) null
);

--ok
--drop table if exists analysisimplementation;
create table analysisimplementation (
    analysisimplementation_id          																		serial not null,
	primary key (analysisimplementation_id),
    analysis_id                        																		int not null,
	foreign key (analysis_id) references analysis (analysis_id),
    name                               																		varchar(100) not null,
    description  																		         			varchar(500) null
);

--ok
--drop table if exists analysisimplementationparam;
create table analysisimplementationparam (
    analysisimplementationparam_id     																		serial not null,
	primary key (analysisimplementationparam_id),
    analysisimplementation_id          																		int not null,
	foreign key (analysisimplementation_id) references analysisimplementation (analysisimplementation_id),
    name                               																		varchar(100) not null,
    value                              																		varchar(100) not null
);

--ok
--drop table if exists analysisinput;
create table analysisinput (
    analysisinput_id         																				serial not null,
	primary key (analysisinput_id),
    analysisinvocation_id    																				int not null,
	foreign key (analysisinvocation_id) references analysisinvocation (analysisinvocation_id),
    tableinfo_id                 																			int null,
	foreign key (tableinfo_id) references tableinfo (tableinfo_id),
    inputrow_id             																				int null,
    inputvalue              																				varchar(50) null
);

--ok
--drop table if exists analysisinvocation;
create table analysisinvocation (
    analysisinvocation_id              																		serial not null,
	primary key (analysisinvocation_id),
    analysisimplementation_id          																		int not null,
	foreign key (analysisimplementation_id) references analysisimplementation (analysisimplementation_id),
    name                               																		varchar(100) not null,
    description                        																		varchar(500) null
);

--ok
--drop table if exists analysisinvocationparam;
create table analysisinvocationparam (
    analysisinvocationparam_id         																		serial not null,
	primary key (analysisinvocationparam_id),
    analysisinvocation_id              																		int not null,
	foreign key (analysisinvocation_id) references analysisinvocation (analysisinvocation_id),
    name                               																		varchar(100) not null,
    value                            																		varchar(100) not null
);

--ok
--drop table if exists analysisoutput;
create table analysisoutput (
    analysisoutput_id       																				serial not null,
	primary key (analysisoutput_id),
    analysisinvocation_id   																				int not null,
	foreign key (analysisinvocation_id) references analysisinvocation (analysisinvocation_id),
    name                    																				varchar(100) not null,
    type                    																				varchar(50) not null,
    value                   																				int not null
);

--ok
--drop table if exists array;
create table array (
    array_id                           																		serial not null,
	primary key (array_id),
    manufacturer_id                    																		int not null,
	foreign key (manufacturer_id) references author (author_id),
    platformtype_id                   																		int not null,
	foreign key (platformtype_id) references cvterm (cvterm_id),
    substrate_type_id                  																		int null,
	foreign key (substrate_type_id) references cvterm (cvterm_id),
    protocol_id                        																		int null,
	foreign key (protocol_id) references protocol (protocol_id),
    dbxref_id                          																		int null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    name                               																		varchar(100) not null,
    version                            																		varchar(50)  null,
    description                        																		varchar(500) null,
    array_dimensions                   																		varchar(50) null,
    element_dimensions                 																		varchar(50) null,
    number_of_elements                 																		int null,
    num_array_columns                  																		int null,
    num_array_rows                     																		int null,
    num_grid_columns                   																		int null,
    num_grid_rows                      																		int null,
    num_sub_columns                    																		int null,
    num_sub_rows                       																		int null
);

--ok
--drop table if exists arrayannotation;
create table arrayannotation (
    arrayannotation_id      																				int not null,
	primary key (arrayannotation_id),
    array_id                																				int not null,
	foreign key (array_id) references array (array_id),
    name                    																				varchar(500) not null,
    value                   																				varchar(100) not null
);

--ok
--drop table if exists assay;
create table assay (
    assay_id                           																		serial not null,
	primary key (assay_id),
    array_id                         																		int not null,
	foreign key (array_id) references array (array_id),
    protocol_id                        																		int null,
	foreign key (protocol_id) references protocol (protocol_id),
    assaydate                         																		date null,
    arrayidentifier                   																		varchar(100) null,
    arraybatchidentifier             																		varchar(100) null,
    operator_id                        																		int not null,
	foreign key (operator_id) references author (author_id),
    dbxref_id                          																		int null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    name                               																		varchar(100) null,
    description                        																		varchar(500) null
);

--ok
--drop table if exists assay_biomaterial;
create table assay_biomaterial (
    assay_biomaterial_id    																				serial not null,
	primary key (assay_biomaterial_id),
    assay_id                 																				int not null,
	foreign key (assay_id) references assay (assay_id),
    biomaterial_id          																				int not null,
	foreign key (biomaterial_id) references biomaterial (biomaterial_id)
);

--ok
--drop table if exists assay_labeledextract;
create table assay_labeledextract (
    assay_labeledextract_id 																				serial not null,
	primary key (assay_labeledextract_id),
    assay_id                																				int not null,
	foreign key (assay_id) references assay (assay_id),
    labeledextract_id       																				int not null,
	foreign key (labeledextract_id) references biomaterial (biomaterial_id),
    channel_id              																				int not null,
	foreign key (channel_id) references channel (channel_id)
);

--ok
--renamed biomaterialcharacteristic to biomaterial_cvterm
--drop table if exists biomaterial_cvterm;
create table biomaterial_cvterm (
    biomaterial_cvterm_id     																				serial not null,
	primary key (biomaterial_cvterm_id),
    biomaterial_id            																				int not null,
	foreign key (biomaterial_id) references biomaterial (biomaterial_id),
    cvterm_id                 																				int not null,
	foreign key (cvterm_id) references cvterm (cvterm_id),
    value                     																				varchar(100) null
);

--ok
--renamed from biomaterialimp
--drop table if exists biomaterial;
create table biomaterial (
    biomaterial_id                   																		serial not null,
	primary key (biomaterial_id),
    labelmethod_id                  																		int null,
	foreign key (labelmethod_id) references labelmethod (labelmethod_id),
    taxon_id                         																		int null,
	foreign key (taxon_id) references organism (organism_id),
    biosourceprovider_id             																		int null,
	foreign key (biosourceprovider_id) references author (author_id),
    subclass_view                    																		varchar(27) not null,
    dbxref_id                        																		varchar(50) null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    string1                          																		varchar(100) null,
    string2                          																		varchar(500) null
);

--ok
--drop table if exists biomaterialmeasurement;
create table biomaterialmeasurement (
    biomaterialmeasurement_id        																		serial not null,
	primary key (biomaterialmeasurement_id),
    treatment_id                     																		int not null,
	foreign key (treatment_id) references treatment (treatment_id),
    biomaterial_id                   																		int not null,
	foreign key (biomaterial_id) references biomaterial (biomaterial_id),
    value                            																		float(15) null,
    unittype_id                     																		int null,
	foreign key (unittype_id) references cvterm (cvterm_id)
);

--ok
--drop table if exists channel;
create table channel (
    channel_id               																				serial not null,
	primary key (channel_id),
    name                     																				varchar(100) not null,
    definition               																				varchar(500) not null
);

--dropped compositeelementannotation.  use featureprop instead.
--dropped compositeelementgus.         use feature instead.
--dropped compositeelement.            use feature instead.

--ok
--drop table if exists compositeelementresult;
create table compositeelementresult (
    compositeelementresult_id          																		serial not null,
	primary key (compositeelementresult_id),
    compositeelement_id                																		int not null,
	foreign key (compositeelement_id) references feature (feature_id),
    quantification_id                  																		int not null,
	foreign key (quantification_id) references quantification (quantification_id),
    subclass_view                      																		varchar(27) not null,
    float1                             																		float(15) null,
    float2                             																		float(15) null,
    float3                             																		float(15) null,
    float4                             																		float(15) null,
    int1                               																		int null,
    smallint1                          																		int null,
    smallint2                          																		int null,
    smallint3                          																		int null,
    tinyint1                           																		int null,
    tinyint2                           																		int null,
    tinyint3                           																		int null,
    char1                              																		varchar(5) null,
    char2                              																		varchar(5) null,
    char3                              																		varchar(5) null,
    string1                            																		varchar(500) null,
    string2                            																		varchar(500) null
);

--ok
--drop table if exists control;
create table control (
    control_id               																				serial not null,
	primary key (control_id),
    controltype_id          																				int not null,
	foreign key (controltype_id) references cvterm (cvterm_id),
    assay_id                 																				int not null,
	foreign key (assay_id) references assay (assay_id),
    tableinfo_id                 																			int not null,
	foreign key (tableinfo_id) references tableinfo (tableinfo_id),
    row_id                   																				int not null,
    name                     																				varchar(100) null,
    value                    																				varchar(255) null
);

--dropped elementannotation.  use featureprop instead.

--ok
--drop table if exists element;
create table element (
    element_id                         																		serial not null,
	primary key (element_id),
    feature_id           		     																		int null,
	foreign key (feature_id) references feature (feature_id),
    array_id                           																		int not null,
	foreign key (array_id) references array (array_id),
    element_type_id                    																		int null,
	foreign key (element_type_id) references cvterm (cvterm_id),
    dbxref_id                          																		int null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    subclass_view                      																		varchar(27) not null,
    tinyint1                           																		int null,
    smallint1                          																		int null,
    char1                              																		varchar(5) null,
    char2                              																		varchar(5) null,
    char3                              																		varchar(5) null,
    char4                              																		varchar(5) null,
    char5                              																		varchar(5) null,
    char6                              																		varchar(5) null,
    char7                              																		varchar(5) null,
    tinystring1                        																		varchar(50) null,
    tinystring2                        																		varchar(50) null,
    smallstring1                       																		varchar(100) null,
    smallstring2                       																		varchar(100) null,
    string1                            																		varchar(500) null,
    string2                            																		varchar(500) null
);

--ok
--drop table if exists elementresult;
create table elementresult (
    elementresult_id                   																		serial not null,
	primary key (elementresult_id),
    element_id                         																		int not null,
	foreign key (element_id) references element (element_id),
    compositeelementresult_id          																		int null,
	foreign key (compositeelementresult_id) references compositeelementresult (compositeelementresult_id),
    quantification_id                  																		int not null,
	foreign key (quantification_id) references quantification (quantification_id),
    subclass_view                      																		varchar(27) not null,
    foreground                         																		float(15) null,
    background                         																		float(15) null,
    foreground_sd                      																		float(15) null,
    background_sd                      																		float(15) null,
    float1                             																		float(15) null,
    float2                             																		float(15) null,
    float3                             																		float(15) null,
    float4                             																		float(15) null,
    float5                             																		float(15) null,
    float6                             																		float(15) null,
    float7                             																		float(15) null,
    float8                             																		float(15) null,
    float9                             																		float(15) null,
    float10                            																		float(15) null,
    float11                            																		float(15) null,
    float12                            																		float(15) null,
    float13                            																		float(15) null,
    float14                            																		float(15) null,
    int1                               																		int null,
    int2                               																		int null,
    int3                               																		int null,
    int4                               																		int null,
    int5                               																		int null,
    int6                               																		int null,
    int7                               																		int null,
    int8                              																		int null,
    int9                               																		int null,
    int10                              																		int null,
    int11                              																		int null,
    int12                              																		int null,
    int13                              																		int null,
    int14                              																		int null,
    int15                              																		int null,
    tinyint1                           																		int null,
    tinyint2                           																		int null,
    tinyint3                           																		int null,
    smallint1                          																		int null,
    smallint2                          																		int null,
    smallint3                          																		int null,
    char1                              																		varchar(5) null,
    char2                              																		varchar(5) null,
    char3                              																		varchar(5) null,
    char4                              																		varchar(5) null,
    tinystring1                        																		varchar(50) null,
    tinystring2                        																		varchar(50) null,
    tinystring3                        																		varchar(50) null,
    smallstring1                       																		varchar(100) null,
    smallstring2                       																		varchar(100) null,
    string1                            																		varchar(500) null,
    string2                            																		varchar(500) null
);

--ok
--drop table if exists labelmethod;
create table labelmethod (
    labelmethod_id           																				serial not null,
	primary key (labelmethod_id),
    protocol_id              																				int not null,
	foreign key (protocol_id) references protocol (protocol_id),
    channel_id               																				int not null,
	foreign key (channel_id) references channel (channel_id),
    labelused               																				varchar(50) null,
    labelmethod             																				varchar(1000) null
);

--ok
--drop table if exists magedocumentation;
create table magedocumentation (
    magedocumentation_id     																				serial not null,
	primary key (magedocumentation_id),
    mageml_id                																				int not null,
	foreign key (mageml_id) references mageml (mageml_id),
    tableinfo_id                 																			int not null,
	foreign key (tableinfo_id) references tableinfo (tableinfo_id),
    row_id                   																				int not null,
    mageidentifier          																				varchar(100) not null
);

--ok
-- warning - mage_ml does not appear in core.tableinfo
--drop table if exists mageml;
create table mageml (
    mageml_id                																				serial not null,
	primary key (mageml_id),
    mage_package             																				varchar(100) not null,
    mage_ml                  																				varchar not null
);

--ok
--drop table if exists processimplementation;
create table processimplementation (
    processimplementation_id           																		serial not null,
	primary key (processimplementation_id),
    processtype_id                    																		int not null,
	foreign key (processtype_id) references cvterm (cvterm_id),
    name                               																		varchar(100) null
);

--ok
--drop table if exists processimplementationparam;
create table processimplementationparam (
    processimplementationparam_id       																		serial not null,
	primary key (processimplementationparam_id),
    processimplementation_id           																		int not null,
	foreign key (processimplementation_id) references processimplementation (processimplementation_id),
    name                               																		varchar(100) not null,
    value                              																		varchar(100) not null
);

--ok
--drop table if exists processinvocation;
create table processinvocation (
    processinvocation_id              																		serial not null,
	primary key (processinvocation_id),
    processimplementation_id          																		int not null,
	foreign key (processimplementation_id) references processimplementation (processimplementation_id),
    processinvocationdate             																		date not null,
    description                        																		varchar(500) null
);

--ok
--drop table if exists processinvocationparam;
create table processinvocationparam (
    processinvocationparam_id          																		serial not null,
	primary key (processinvocationparam_id),
    processinvocation_id               																		int not null,
	foreign key (processinvocation_id) references processinvocation (processinvocation_id),
    name                               																		varchar(100) not null,
    value                              																		varchar(100) not null
);

--ok
--renamed from processinv_quantification to processinvocation_quantification
--drop table if exists processinvocation_quantification;
create table processinvocation_quantification (
    processinvocation_quantification_id      																serial not null,
	primary key (processinvocation_quantification_id),
    processinvocation_id                     																int not null,
	foreign key (processinvocation_id) references processinvocation (processinvocation_id),
    quantification_id                        																int not null,
	foreign key (quantification_id) references quantification (quantification_id)
);

--ok
--drop table if exists processio;
create table processio (
    processio_id             																				serial not null,
	primary key (processio_id),
    processinvocation_id     																				int not null,
	foreign key (processinvocation_id) references processinvocation (processinvocation_id),
    inputtable_id                 																			int not null,
	foreign key (inputtable_id) references tableinfo (tableinfo_id),
    inputrow_id          																					int not null,
    input_role               																				varchar(50) null,
    outputrow_id         																					int not null,
	foreign key (outputrow_id) references processresult (processresult_id)
);

--ok
--drop table if exists processresult;
create table processresult (
    processresult_id         																				serial not null,
	primary key (processresult_id),
    value                   																				float(15) not null,
    unittype_id             																				int null,
	foreign key (unittype_id) references cvterm (cvterm_id)
);

--ok
--drop table if exists projectlink;
create table projectlink (
    projectlink_id           																				serial not null,
	primary key (projectlink_id),
    project_id               																			int not null,
	foreign key (project_id) references project (project_id),
    tableinfo_id                 																			int not null,
	foreign key (tableinfo_id) references tableinfo (tableinfo_id),
    id                       																				int not null,
    currentversion          																				varchar(4) null
);

--ok
--drop table if exists protocol;
create table protocol (
    protocol_id                        																		serial not null,
	primary key (protocol_id),
    protocol_type_id                   																		int not null,
	foreign key (protocol_type_id) references cvterm (cvterm_id),
    pub_id         																							int null,
	foreign key (pub_id) references pub (pub_id),
    dbxref_id                          																		int null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    name                               																		varchar(100) not null,
    uri                                																		varchar(100) null,
    protocoldescription               																		varchar(4000) null,
    hardwaredescription               																		varchar(500) null,
    softwaredescription               																		varchar(500) null
);

--ok
--drop table if exists protocolparam;
create table protocolparam (
    protocolparam_id         																				serial not null,
	primary key (protocolparam_id),
    protocol_id              																				int not null,
	foreign key (protocol_id) references protocol (protocol_id),
    name                     																				varchar(100) not null,
    datatype_id             																				int null,
	foreign key (datatype_id) references cvterm (cvterm_id),
    unittype_id             																				int null,
	foreign key (unittype_id) references cvterm (cvterm_id),
    value                    																				varchar(100) null
);

--ok
--drop table if exists quantification;
create table quantification (
    quantification_id        																				serial not null,
	primary key (quantification_id),
    acquisition_id           																				int not null,
	foreign key (acquisition_id) references acquisition (acquisition_id),
    operator_id              																				int null,
	foreign key (operator_id) references author (author_id),
    protocol_id              																				int null,
	foreign key (protocol_id) references protocol (protocol_id),
    resulttable_id          																				int null,
	foreign key (resulttable_id) references tableinfo (tableinfo_id),
    quantificationdate       																				date null,
    name                     																				varchar(100) null,
    uri                      																				varchar(500) null
);

--ok
--drop table if exists quantificationparam;
create table quantificationparam (
    quantificationparam_id   																				serial not null,
	primary key (quantificationparam_id),
    quantification_id        																				int not null,
	foreign key (quantification_id) references quantification (quantification_id),
    name                     																				varchar(100) not null,
    value                    																				varchar(50) not null
);

--ok
--drop table if exists relatedacquisition;
create table relatedacquisition (
    relatedacquisition_id              																		serial not null,
	primary key (relatedacquisition_id),
    acquisition_id                     																		int not null,
	foreign key (acquisition_id) references acquisition (acquisition_id),
    associatedacquisition_id          																		int not null,
	foreign key (associatedacquisition_id) references acquisition (acquisition_id),
    name                               																		varchar(100) null,
    designation                        																		varchar(50) null,
    associateddesignation             																		varchar(50) null
);

--ok
--drop table if exists relatedquantification;
create table relatedquantification (
    relatedquantification_id           																		serial not null,
	primary key (relatedquantification_id),
    quantification_id                  																		int not null,
	foreign key (quantification_id) references quantification (quantification_id),
    associatedquantification_id       																		int not null,
	foreign key (associatedquantification_id) references quantification (quantification_id),
    name                               																		varchar(100) null,
    designation                        																		varchar(50) null,
    associateddesignation             																		varchar(50) null
);

--ok
--drop table if exists study;
create table study (
    study_id                           																		serial not null,
	primary key (study_id),
    contact_id                         																		int not null,
	foreign key (contact_id) references author (author_id),
   	pub_id         																							int null,
	foreign key (pub_id) references pub (pub_id),
    dbxref_id                          																		int null,
	foreign key (dbxref_id) references dbxref (dbxref_id),
    name                               																		varchar(100) not null,
    description                        																		varchar(4000) null
);

--ok
--renamed from studyassay to study_assay
--drop table if exists study_assay;
create table study_assay (
    study_assay_id           																				serial not null,
	primary key (study_assay_id),
    study_id                 																				int not null,
	foreign key (study_id) references study (study_id),
    assay_id                 																				int not null,
	foreign key (assay_id) references assay (assay_id)
);

--ok
--drop table if exists studydesign;
create table studydesign (
    studydesign_id           																				serial not null,
	primary key (studydesign_id),
    study_id                 																				int not null,
	foreign key (study_id) references study (study_id),
    studydesigntype_id     																					int  null,
	foreign key (studydesigntype_id) references cvterm (cvterm_id),
    description              																				varchar(4000) null
);

--ok
--renamed from studydesignassay to studydesign_assay
--drop table if exists studydesign_assay;
create table studydesign_assay (
    studydesign_assay_id    																				serial not null,
	primary key (studydesign_assay_id),
    studydesign_id          																				int not null,
	foreign key (studydesign_id) references studydesign (studydesign_id),
    assay_id                																				int not null,
	foreign key (assay_id) references assay (assay_id)
);

--ok
--drop table if exists studydesigndescription;
create table studydesigndescription (
    studydesigndescription_id         																		serial not null,
	primary key (studydesigndescription_id),
    studydesign_id                     																		int not null,
	foreign key (studydesign_id) references studydesign (studydesign_id),
    descriptiontype_id                 																		int not null,
	foreign key (descriptiontype_id) references cvterm (cvterm_id),
    description                        																		varchar(4000) not null
);

--ok
--drop table if exists studyfactor;
create table studyfactor (
    studyfactor_id          																				serial not null,
	primary key (studyfactor_id),
    studydesign_id          																				int not null,
	foreign key (studydesign_id) references studydesign (studydesign_id),
    studyfactortype_id     																					int null,
	foreign key (studyfactortype_id) references cvterm (cvterm_id),
    name                     																				varchar(100) not null,
    description              																				varchar(500) null
);

--ok
--drop table if exists studyfactorvalue;
create table studyfactorvalue (
    studyfactorvalue_id      																				serial not null,
	primary key (studyfactorvalue_id),
    studyfactor_id           																				int not null,
	foreign key (studyfactor_id) references studyfactor (studyfactor_id),
    assay_id                 																				int not null,
	foreign key (assay_id) references assay (assay_id),
    factorvalue             																				varchar(100) not null,
    name                     																				varchar(100) null
);

--ok
--drop table if exists treatment;
create table treatment (
    treatment_id             																				serial not null,
	primary key (treatment_id),
    ordernum                																				int not null,
    biomaterial_id           																				int not null,
	foreign key (biomaterial_id) references biomaterial (biomaterial_id),
    treatmenttype_id        																				int not null,
	foreign key (treatmenttype_id) references cvterm (cvterm_id),
    protocol_id              																				int null,
	foreign key (protocol_id) references protocol (protocol_id),
    name                     																				varchar(100) null
);
-- ================================================
-- TABLE: db
-- ================================================

create table db (
       db_id varchar(255) not null,
       primary key (db_id),
       name varchar(255) not null,
       description varchar(255) null,
       url varchar(255) null,
       unique (name)
);


-- ================================================
-- TABLE: dbxref
-- ================================================

create table dbxref (
       dbxref_id serial not null,
       primary key (dbxref_id),
       dbname varchar(255) not null,
       foreign key (dbname) references db (db_id),
       accession varchar(255) not null,
       version varchar(255) not null default '',
       dbxrefdescription text,

       unique (dbname, accession, version)
);

-- ================================================
-- TABLE: dbxrefprop
-- ================================================

create table dbxrefprop (
       dbxrefprop_id serial not null,
       primary key (dbxrefprop_id),
       dbxref_id int not null,
       foreign key (dbxref_id) references dbxref (dbxref_id),
       pkey_id int not null,
       foreign key (pkey_id) references cvterm (cvterm_id),
       pval text not null default '',
       prank int not null default 0,

       unique(dbxref_id, pkey_id, pval, prank)
);
create index dbxrefprop_idx1 on dbxrefprop (dbxref_id);
create index dbxrefprop_idx2 on dbxrefprop (pkey_id);

-- ================================================
-- TABLE: tableinfo
-- ================================================

create table tableinfo (
       tableinfo_id serial not null,
       primary key (tableinfo_id),
       name varchar(30) not null,
       table_type varchar(40) not null,
       primary_key_column varchar(30) null,
       database_id int not null,
       is_versioned int not null,
       is_view int not null,
       view_on_table_id int null,
       superclass_table_id int null,
       is_updateable int not null,
       modification_date date not null
);

-- ================================================
-- TABLE: project
-- ================================================
create table project (
       project_id serial not null,
       primary key (project_id),
       name varchar(255) not null,
      description varchar(255) not null
);
-- This module depends on the sequence, pub, and cv modules 
-- 18-JAN-03 (DE): This module is unfinished and due for schema review (Bill 
-- Gelbart will be leading the charge)   

-- ================================================
-- TABLE: genotype
-- ================================================

create table genotype (
       genotype_id serial not null,
       primary key (genotype_id),
       description varchar(255)
);


-- ================================================
-- TABLE: feature_genotype
-- ================================================

create table feature_genotype (
       feature_genotype_id serial not null,
       primary key (feature_genotype_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       genotype_id int not null,
       foreign key (genotype_id) references genotype (genotype_id),

       unique(feature_id,genotype_id)
);
create index feature_genotype_idx1 on feature_genotype (feature_id);
create index feature_genotype_idx2 on feature_genotype (genotype_id);


-- ================================================
-- TABLE: phenotype
-- ================================================

create table phenotype (
       phenotype_id serial not null,
       primary key (phenotype_id),
       description text,
       statement_type int not null,
       foreign key (statement_type) references cvterm (cvterm_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
       background_genotype_id int,
       foreign key (background_genotype_id) references genotype (genotype_id)
);
-- type of phenotypic statement  [Chris, we need this or something like it
-- for FB where we have three types of statement in *k: "Phenotypic class:",
-- "Phenotype manifest in:", and free-text]
-- Do we want to call this simply genotype_id to allow natural joins?
create index phenotype_idx1 on phenotype (statement_type);
create index phenotype_idx2 on phenotype (pub_id);
create index phenotype_idx3 on phenotype (background_genotype_id);


-- ================================================
-- TABLE: feature_phenotype
-- ================================================

create table feature_phenotype (
       feature_phenotype_id serial not null,
       primary key (feature_phenotype_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       phenotype_id int not null,
       foreign key (phenotype_id) references phenotype (phenotype_id),

       unique(feature_id,phenotype_id)       
);
create index feature_phenotype_idx1 on feature_phenotype (feature_id);
create index feature_phenotype_idx2 on feature_phenotype (phenotype_id);


-- ================================================
-- TABLE: phenoype_cvterm
-- ================================================

create table phenotype_cvterm (
       phenotype_cvterm_id serial not null,
       primary key (phenotype_cvterm_id),
       phenotype_id int not null,
       foreign key (phenotype_id) references phenotype (phenotype_id),
       cvterm_id int not null,
       foreign key (cvterm_id) references cvterm (cvterm_id),
       prank int not null,

       unique(phenotype_id,cvterm_id,prank)
);
create index phenotype_cvterm_idx1 on phenotype_cvterm (phenotype_id);
create index phenotype_cvterm_idx2 on phenotype_cvterm (cvterm_id);


-- ================================================
-- TABLE: interaction
-- ================================================

create table interaction (
       interaction_id serial not null,
       primary key (interaction_id),
       description text,
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
-- Do we want to call this simply genotype_id to allow natural joins?
       background_genotype_id int,
       foreign key (background_genotype_id) references genotype (genotype_id),
       phenotype_id int,
       foreign key (phenotype_id) references phenotype (phenotype_id)
);
create index interaction_idx1 on interaction (pub_id);
create index interaction_idx2 on interaction (background_genotype_id);
create index interaction_idx3 on interaction (phenotype_id);


-- ================================================
-- TABLE: interaction_subj
-- ================================================

create table interaction_subj (
       interaction_subj_id serial not null,
       primary key (interaction_subj_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       interaction_id int not null,
       foreign key (interaction_id) references interaction (interaction_id),

       unique(feature_id,interaction_id)
);
create index interaction_subj_idx1 on interaction_subj (feature_id);
create index interaction_subj_idx2 on interaction_subj (interaction_id);


-- ================================================
-- TABLE: interaction_obj
-- ================================================

create table interaction_obj (
       interaction_obj_id serial not null,
       primary key (interaction_obj_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       interaction_id int not null,
       foreign key (interaction_id) references interaction (interaction_id),

       unique(feature_id,interaction_id)
);
create index interaction_obj_idx1 on interaction_obj (feature_id);
create index interaction_obj_idx2 on interaction_obj (interaction_id);
-- NOTE: this module is all due for revision...

-- A possibly problematic case is where we want to localize an object
-- to the left or right of a feature (but not within it):
--
--                     |---------|  feature-to-map
--        ------------------------------------------------- map
--                |------|         |----------|   features to map wrt
--
-- How do we map the 3' end of the feature-to-map?

-- TODO:  Get a comprehensive set of mapping use-cases 

-- one set of use-cases is aberrations (which will all be involved with this 
-- module).   Simple aberrations should be do-able, but what about cases where
-- a breakpoint interrupts a gene?  This would be an example of the problematic
-- case above...  (or?)

-- ================================================
-- TABLE: featuremap
-- ================================================

create table featuremap (
       featuremap_id serial not null,
       primary key (featuremap_id),
       mapname varchar(255),
       mapdesc varchar(255),
       mapunit varchar(255),

       unique(mapname)
);


-- ================================================
-- TABLE: featurerange
-- ================================================

-- In cases where the start and end of a mapped feature is a range, leftendf
-- and rightstartf are populated.  
-- featuremap_id is the id of the feature being mapped
-- leftstartf_id, leftendf_id, rightstartf_id, rightendf_id are the ids of
-- features with respect to with the feature is being mapped.  These may
-- be cytological bands.

create table featurerange (
       featurerange_id serial not null,
       primary key (featurerange_id),
       featuremap_id int not null,
       foreign key (featuremap_id) references featuremap (featuremap_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       leftstartf_id int not null,
       foreign key (leftstartf_id) references feature (feature_id),       
       leftendf_id int,
       foreign key (leftendf_id) references feature (feature_id),       
       rightstartf_id int,
       foreign key (rightstartf_id) references feature (feature_id),       
       rightendf_id int not null,
       foreign key (rightendf_id) references feature (feature_id),
       rangestr varchar(255)
);
create index featurerange_idx1 on featurerange (featuremap_id);
create index featurerange_idx2 on featurerange (feature_id);
create index featurerange_idx3 on featurerange (leftstartf_id);
create index featurerange_idx4 on featurerange (leftendf_id);
create index featurerange_idx5 on featurerange (rightstartf_id);
create index featurerange_idx6 on featurerange (rightendf_id);


-- ================================================
-- TABLE: featurepos
-- ================================================

create table featurepos (
       featurepos_id serial not null,
       primary key (featurepos_id),
       featuremap_id serial not null,
       foreign key (featuremap_id) references featuremap (featuremap_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       map_feature_id int not null,
       foreign key (map_feature_id) references feature (feature_id),
       mappos float not null
);
-- map_feature_id links to the feature (map) upon which the feature is
-- being localized
create index featurepos_idx1 on featurepos (featuremap_id);
create index featurepos_idx2 on featurepos (feature_id);
create index featurepos_idx3 on featurepos (map_feature_id);


-- ================================================
-- TABLE: featuremap_pub
-- ================================================

create table featuremap_pub (
       featuremap_pub_id serial not null,
       primary key (featuremap_pub_id),
       featuremap_id int not null,
       foreign key (featuremap_id) references featuremap (featuremap_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id)
);
create index featuremap_pub_idx1 on featuremap_pub (featuremap_id);
create index featuremap_pub_idx2 on featuremap_pub (pub_id);





-- ================================================
-- TABLE: organism
-- ================================================

create table organism (
	organism_id serial not null,
	primary key (organism_id),
	abbrev varchar(255) null,
	genus varchar(255) not null,
	taxgroup varchar(255) not null,
	species varchar(255) not null,
	common_name varchar(255) null,
	comment text null,

	unique(taxgroup, genus, species)
);
-- Compared to mol5..Species, organism table lacks "approved char(1) null".  
-- We need to work w/ Aubrey & Michael to ensure that we don't need this in 
-- future [dave]
--
-- in response: this is very specific to a limited use case I think;
-- if it's really necessary we can have an organismprop table
-- for adding internal project specific data
-- [cjm]


-- ================================================
-- TABLE: organism_dbxref
-- ================================================

create table organism_dbxref (
       organism_dbxref_id serial not null,
       primary key (organism_dbxref_id),
       organism_id int not null,
       foreign key (organism_id) references organism (organism_id),
       dbxref_id int not null,
       foreign key (dbxref_id) references dbxref (dbxref_id),

       unique(organism_id,dbxref_id)
);
create index organism_dbxref_idx1 on organism_dbxref (organism_id);
create index organism_dbxref_idx2 on organism_dbxref (dbxref_id);

-- We should take a look in OMG for a standard representation we might use 
-- instead of this.

-- ================================================
-- TABLE: pub
-- ================================================

create table pub (
       pub_id serial not null,
       primary key (pub_id),
       title text,
       volumetitle text,
       volume  varchar(255),
       series_name varchar(255),
       issue  varchar(255),
       pyear  varchar(255),
       pages  varchar(255),
       miniref varchar(255) not null,
       type_id int not null,
       foreign key (type_id) references cvterm (cvterm_id),
       is_obsolete boolean default 'false',
       publisher varchar(255),
       pubplace varchar(255),

       unique(miniref)
);
-- title: title of paper, chapter of book, journal, etc
-- volumetitle: title of part if one of a series
-- series_name: full name of (journal) series
-- pages: page number range[s], eg, 457--459, viii + 664pp, lv--lvii
-- type_id: the type of the publication (book, journal, poem, graffiti, etc)
-- is_obsolete: do we want this even though we have the relationship in pub_relationship?
create index pub_idx1 on pub (type_id);

-- ================================================
-- TABLE: pub_relationship
-- ================================================

-- Handle relationships between publications, eg, when one publication
-- makes others obsolete, when one publication contains errata with
-- respect to other publication(s), or when one publication also 
-- appears in another pub (I think these three are it - at least for fb)

create table pub_relationship (
       pub_relationship_id serial not null,
       primary key (pub_relationship_id),
       subj_pub_id int not null,
       foreign key (subj_pub_id) references pub (pub_id),
       obj_pub_id int not null,
       foreign key (obj_pub_id) references pub (pub_id),
       type_id int not null,
       foreign key (type_id) references cvterm (cvterm_id),

       unique(subj_pub_id, obj_pub_id, type_id)
);
create index pub_relationship_idx1 on pub_relationship (subj_pub_id);
create index pub_relationship_idx2 on pub_relationship (obj_pub_id);
create index pub_relationship_idx3 on pub_relationship (type_id);


-- ================================================
-- TABLE: pub_dbxref
-- ================================================

-- Handle links to eg, pubmed, biosis, zoorec, OCLC, mdeline, ISSN, coden...

create table pub_dbxref (
       pub_dbxref_id serial not null,
       primary key (pub_dbxref_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
       dbxref_id int not null,
       foreign key (dbxref_id) references dbxref (dbxref_id),

       unique(pub_id,dbxref_id)
);
create index pub_dbxref_idx1 on pub_dbxref (pub_id);
create index pub_dbxref_idx2 on pub_dbxref (dbxref_id);


-- ================================================
-- TABLE: author
-- ================================================

-- using the FB author table columns

create table author (
       author_id serial not null,
       primary key (author_id),
       surname varchar(100) not null,
       givennames varchar(100),
       suffix varchar(100),

       unique(surname,givennames,suffix)
);
-- givennames: first name, initials
-- suffix: Jr., Sr., etc       


-- ================================================
-- TABLE: pub_author
-- ================================================

create table pub_author (
       pub_author_id serial not null,
       primary key (pub_author_id),
       author_id int not null,
       foreign key (author_id) references author (author_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
       arank int not null,
       editor boolean default 'false',

       unique(author_id,pub_id)
);
-- arank: order of author in author list for this pub
-- editor: indicates whether the author is an editor for linked publication
create index pub_author_idx1 on pub_author (author_id);
create index pub_author_idx2 on pub_author (pub_id);


-- ================================================
-- TABLE: pubprop
-- ================================================

create table pubprop (
       pubprop_id serial not null,
       primary key (pubprop_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
       pkey_id int not null,
       foreign key (pkey_id) references cvterm (cvterm_id),
       pval text not null,
       prank integer,

       unique(pub_id,pkey_id,pval)
);
create index pubprop_idx1 on pubprop (pub_id);
create index pubprop_idx2 on pubprop (pkey_id);

-- ================================================
-- TABLE: feature
-- ================================================

create table feature (
       feature_id serial not null,
       primary key (feature_id),
       dbxref_id int,
       foreign key (dbxref_id) references dbxref (dbxref_id),
       organism_id int not null,
       foreign key (organism_id) references organism (organism_id),
       name varchar(255),
       uniquename text not null,
       residues text,
       seqlen int,
       md5checksum char(32),
       type_id int not null,
       foreign key (type_id) references cvterm (cvterm_id),
	is_analysis boolean not null default 'false',
-- timeaccessioned and timelastmodified are for handling object accession/
-- modification timestamps (as opposed to db auditing info, handled elsewhere).
-- The expectation is that these fields would be available to software 
-- interacting with chado.
       timeaccessioned timestamp not null default current_timestamp,
       timelastmodified timestamp not null default current_timestamp,

       unique(organism_id,uniquename)
);
-- dbxref_id here is intended for the primary dbxref for this feature.   
-- Additional dbxref links are made via feature_dbxref
-- name: the human-readable common name for a feature, for display
-- uniquename: the unique name for a feature; may not be particularly human-readable

-- timeaccessioned and timelastmodified are for handling object accession/
-- modification timestamps (as opposed to db auditing info, handled elsewhere).
-- The expectation is that these fields would be available to software 
-- interacting with chado.
create sequence feature_uniquename_seq;
create index feature_name_ind1 on feature(name);
create index feature_idx1 on feature (dbxref_id);
create index feature_idx2 on feature (organism_id);
create index feature_idx3 on feature (type_id);
create index feature_idx4 on feature (uniquename);
create index feature_lc_name on feature (lower(name));



-- ================================================
-- TABLE: featureloc
-- ================================================

-- each feature can have 0 or more locations.
-- multiple locations do NOT indicate non-contiguous locations.
-- instead they designate alternate locations or grouped locations;
-- for instance, a feature designating a blast hit or hsp will have two
-- locations, one on the query feature, one on the subject feature.
-- features representing sequence variation could have alternate locations
-- instantiated on a feature on the mutant strain.
-- the field "rank" is used to differentiate these different locations.
-- the default rank '0' is used for the main/primary location (eg in
-- similarity features, 0 is query, 1 is subject), although sometimes
-- this will be symmeytical and there is no primary location.
--
-- redundant locations can also be stored - for instance, the position
-- of an exon on a BAC and in global coordinates. the field "locgroup"
-- is used to differentiate these groupings of locations. the default
-- locgroup '0' is used for the main/primary location, from which the
-- others can be derived via coordinate transformations. another
-- example of redundant locations is storing ORF coordinates relative
-- to both transcript and genome. redundant locations open the possibility
-- of the database getting into inconsistent states; this schema gives
-- us the flexibility of both 'warehouse' instantiations with redundant
-- locations (easier for querying) and 'management' instantiations with
-- no redundant locations.

-- most features (exons, transcripts, etc) will have 1 location, with
-- locgroup and rank equal to 0
--
-- an example of using both locgroup and rank:
-- imagine a feature indicating a conserved region between the chromosomes
-- of two different species. we may want to keep redundant locations on
-- both contigs and chromosomes. we would thus have 4 locations for the
-- single conserved region feature - two distinct locgroups (contig level
-- and chromosome level) and two distinct ranks (for the two species).

-- altresidues is used to store alternate residues of a feature, when these
-- differ from feature.residues. for instance, a SNP feature located on
-- a wild and mutant protein would have different alresidues.
-- for alignment/similarity features, the altresidues is used to represent
-- the alignment string.

-- note on variation features; even if we don't want to instantiate a mutant
-- chromosome/contig feature, we can still represent a SNP etc with 2 locations,
-- one (rank 0) on the genome, the other (rank 1) would have most fields null,
-- except for altresidues

-- IMPORTANT: fnbeg and fnend are space-based (INTERBASE) coordinates
-- this is vital as it allows us to represent zero-length
-- features eg splice sites, insertion points without
-- an awkward fuzzy system

-- nbeg, nend are for feature natural begin/end
-- by natural begin, end we mean these are the actual
-- beginning (5' position) and actual end (3' position)
-- rather than the low position and high position, as
-- these terms are sometimes erroneously used

create table featureloc (
       featureloc_id serial not null,
       primary key (featureloc_id),

       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       srcfeature_id int,
       foreign key (srcfeature_id) references feature (feature_id),

       nbeg int,
       is_nbeg_partial boolean not null default 'false',
       nend int,
       is_nend_partial boolean not null default 'false',
       strand smallint,
       phase int,

       residue_info text,

       locgroup int not null default 0,
       rank     int not null default 0,

       unique (feature_id, locgroup, rank)
);
-- phase: phase of translation wrt srcfeature_id.  Values are 0,1,2
create index featureloc_idx1 on featureloc (feature_id);
create index featureloc_idx2 on featureloc (srcfeature_id);
create index featureloc_idx3 on featureloc (srcfeature_id,nbeg,nend);

-- ================================================
-- TABLE: feature_pub
-- ================================================

create table feature_pub (
       feature_pub_id serial not null,
       primary key (feature_pub_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),

       unique(feature_id, pub_id)
);
create index feature_pub_idx1 on feature_pub (feature_id);
create index feature_pub_idx2 on feature_pub (pub_id);


-- ================================================
-- TABLE: featureprop
-- ================================================

create table featureprop (
       featureprop_id serial not null,
       primary key (featureprop_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       pkey_id int not null,
       foreign key (pkey_id) references cvterm (cvterm_id),
       pval text not null default '',
       prank int not null default 0,

       unique(feature_id, pkey_id, pval, prank)
);
create index featureprop_idx1 on featureprop (feature_id);
create index featureprop_idx2 on featureprop (pkey_id);


-- ================================================
-- TABLE: featureprop_pub
-- ================================================

create table featureprop_pub (
       featureprop_pub_id serial not null,
       primary key (featureprop_pub_id),
       featureprop_id int not null,
       foreign key (featureprop_id) references featureprop (featureprop_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),

       unique(featureprop_id, pub_id)
);
create index featureprop_pub_idx1 on featureprop_pub (featureprop_id);
create index featureprop_pub_idx2 on featureprop_pub (pub_id);


-- ================================================
-- TABLE: feature_dbxref
-- ================================================
-- links a feature to dbxrefs.  Note that there is also feature.dbxref_id
-- link for the primary dbxref link.
create table feature_dbxref (
       feature_dbxref_id serial not null,
       primary key (feature_dbxref_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       dbxref_id int not null,
       foreign key (dbxref_id) references dbxref (dbxref_id),
       is_current boolean not null default 'true',

       unique(feature_id, dbxref_id)
);
create index feature_dbxref_idx1 on feature_dbxref (feature_id);
create index feature_dbxref_idx2 on feature_dbxref (dbxref_id);


-- ================================================
-- TABLE: feature_relationship
-- ================================================

-- features can be arranged in graphs, eg exon partof transcript 
-- partof gene; translation madeby transcript
-- if type is thought of as a verb, each arc makes a statement
-- [SUBJECT VERB OBJECT]
-- object can also be thought of as parent, and subject as child
--
-- we include the relationship rank/order, because even though
-- most of the time we can order things implicitly by sequence
-- coordinates, we can't always do this - eg transpliced genes.
-- it's also useful for quickly getting implicit introns

create table feature_relationship (
       feature_relationship_id serial not null,
       primary key (feature_relationship_id),
       subjfeature_id int not null,
       foreign key (subjfeature_id) references feature (feature_id),
       objfeature_id int not null,
       foreign key (objfeature_id) references feature (feature_id),
       type_id int not null,
       foreign key (type_id) references cvterm (cvterm_id),
       relrank int,

       unique(subjfeature_id, objfeature_id, type_id)
);
create index feature_relationship_idx1 on feature_relationship (subjfeature_id);
create index feature_relationship_idx2 on feature_relationship (objfeature_id);
create index feature_relationship_idx3 on feature_relationship (type_id);


-- ================================================
-- TABLE: feature_cvterm
-- ================================================

create table feature_cvterm (
       feature_cvterm_id serial not null,
       primary key (feature_cvterm_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       cvterm_id int not null,
       foreign key (cvterm_id) references cvterm (cvterm_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),

       unique(feature_id, cvterm_id, pub_id)
);
create index feature_cvterm_idx1 on feature_cvterm (feature_id);
create index feature_cvterm_idx2 on feature_cvterm (cvterm_id);
create index feature_cvterm_idx3 on feature_cvterm (pub_id);


-- ================================================
-- TABLE: synonym
-- ================================================

create table synonym (
       synonym_id serial not null,
       primary key (synonym_id),
       name varchar(255) not null,
       type_id int not null,
       synonym_sgml varchar(255) not null,
       foreign key (type_id) references cvterm (cvterm_id),

       unique(name,type_id)
);
-- type_id: types would be symbol and fullname for now
-- synonym_sgml: sgml-ized version of symbols
create index synonym_idx1 on synonym (type_id);


-- ================================================
-- TABLE: feature_synonym
-- ================================================

create table feature_synonym (
       feature_synonym_id serial not null,
       primary key (feature_synonym_id),
       synonym_id int not null,
       foreign key (synonym_id) references synonym (synonym_id),
       feature_id int not null,
       foreign key (feature_id) references feature (feature_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),
       is_current boolean not null,
       is_internal boolean not null default 'false',

       unique(synonym_id, feature_id, pub_id)
);
-- pub_id: the pub_id link is for relating the usage of a given synonym to the
-- publication in which it was used
-- is_current: the is_current bit indicates whether the linked synonym is the 
-- current -official- symbol for the linked feature
-- is_internal: typically a synonym exists so that somebody querying the db with an
-- obsolete name can find the object they're looking for (under its current
-- name.  If the synonym has been used publicly & deliberately (eg in a 
-- paper), it my also be listed in reports as a synonym.   If the synonym 
-- was not used deliberately (eg, there was a typo which went public), then 
-- the is_internal bit may be set to 'true' so that it is known that the 
-- synonym is "internal" and should be queryable but should not be listed 
-- in reports as a valid synonym.
create index feature_synonym_idx1 on feature_synonym (synonym_id);
create index feature_synonym_idx2 on feature_synonym (feature_id);
create index feature_synonym_idx3 on feature_synonym (pub_id);


-- ================================================
-- TABLE: synonym_pub
-- ================================================

create table synonym_pub (
       synonym_pub_id serial not null,
       primary key (synonym_pub_id),
       synonym_id int not null,
       foreign key (synonym_id) references synonym (synonym_id),
       pub_id int not null,
       foreign key (pub_id) references pub (pub_id),

       unique(synonym_id, pub_id)
);
create index synonym_pub_idx1 on synonym_pub (synonym_id);
create index synonym_pub_idx2 on synonym_pub (pub_id);
--------------------------------
---- f_type --------------------
--------------------------------
DROP VIEW f_type;
CREATE VIEW f_type
AS
  SELECT  f.feature_id,
          f.name,
          f.dbxrefstr,
          c.termname AS type,
          f.residues,
          f.seqlen,
          f.md5checksum,
          f.type_id,
          f.timeentered,
          f.timelastmod
    FROM  feature f, cvterm c
   WHERE  f.type_id = c.cvterm_id;

--------------------------------
---- fnr_type ------------------
--------------------------------
DROP VIEW fnr_type;
CREATE VIEW fnr_type
AS
  SELECT  f.feature_id,
          f.name,
          f.dbxrefstr,
          c.termname AS type,
          f.residues,
          f.seqlen,
          f.md5checksum,
          f.type_id,
          f.timeentered,
          f.timelastmod
    FROM  feature f left outer join analysisfeature af
          on (f.feature_id = af.feature_id), cvterm c
   WHERE  f.type_id = c.cvterm_id
          and af.feature_id is null;

--------------------------------
---- f_loc ---------------------
--------------------------------
DROP VIEW f_loc;
CREATE VIEW f_loc
AS
  SELECT  f.feature_id,
          f.name,
          f.dbxrefstr,
          fl.nbeg,
          fl.nend,
          fl.strand
    FROM  featureloc fl, f_type f
   WHERE  f.feature_id = fl.feature_id;

--------------------------------
---- fp_key -------------------
--------------------------------
DROP VIEW fp_key;
CREATE VIEW fp_key
AS
  SELECT  fp.feature_id,
          c.termname AS pkey,
          fp.pval
    FROM  featureprop fp, cvterm c
   WHERE  fp.pkey_id = c.cvterm_id;

-- ================================================
-- TABLE: wwwuser
-- ================================================
-- keep track of www users.  this may also be useful
-- in an audit module at some point (?).

create table wwwuser (
	wwwuser_id serial not null,
	primary key (wwwuser_id),
	username varchar(32) not null,
	unique(username),
	password varchar(32) not null,
	email varchar(128) not null,
	profile text null
);
create index wwwuser_idx1 on wwwuser (username);

-- ================================================
-- TABLE: wwwuser
-- ================================================
-- link wwwuser accounts to projects

create table wwwuser_project (
	wwwuser_project_id serial not null,
	primary key (wwwuser_project_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	project_id int not null,
	foreign key (project_id) references project (project_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,project_id)
);
create index wwwuser_project_idx1 on wwwuser_project(wwwuser_id);
create index wwwuser_project_idx2 on wwwuser_project(project_id);

-- ================================================
-- TABLE: wwwuser_author
-- ================================================
-- track wwwuser interest in authors

create table wwwuser_author (
	wwwuser_author_id serial not null,
	primary key (wwwuser_author_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	author_id int not null,
	foreign key (author_id) references author (author_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,author_id)
);
create index wwwuser_author_idx1 on wwwuser_author(wwwuser_id);
create index wwwuser_author_idx2 on wwwuser_author(author_id);

-- ================================================
-- TABLE: wwwuser_cvterm
-- ================================================
-- track wwwuser interest in cvterms

create table wwwuser_cvterm (
	wwwuser_cvterm_id serial not null,
	primary key (wwwuser_cvterm_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	cvterm_id int not null,
	foreign key (cvterm_id) references cvterm (cvterm_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,cvterm_id)
);
create index wwwuser_cvterm_idx1 on wwwuser_cvterm(wwwuser_id);
create index wwwuser_cvterm_idx2 on wwwuser_cvterm(cvterm_id);

-- ================================================
-- TABLE: wwwuser_expression
-- ================================================
-- track wwwuser interest in expressions

create table wwwuser_expression (
	wwwuser_expression_id serial not null,
	primary key (wwwuser_expression_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	expression_id int not null,
	foreign key (expression_id) references expression (expression_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,expression_id)
);
create index wwwuser_expression_idx1 on wwwuser_expression(wwwuser_id);
create index wwwuser_expression_idx2 on wwwuser_expression(expression_id);

-- ================================================
-- TABLE: wwwuser_feature
-- ================================================
-- track wwwuser interest in features

create table wwwuser_feature (
	wwwuser_feature_id serial not null,
	primary key (wwwuser_feature_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	feature_id int not null,
	foreign key (feature_id) references feature (feature_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,feature_id)
);
create index wwwuser_feature_idx1 on wwwuser_feature(wwwuser_id);
create index wwwuser_feature_idx2 on wwwuser_feature(feature_id);

-- ================================================
-- TABLE: wwwuser_genotype
-- ================================================
-- track wwwuser interest in genotypes

create table wwwuser_genotype (
	wwwuser_genotype_id serial not null,
	primary key (wwwuser_genotype_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	genotype_id int not null,
	foreign key (genotype_id) references genotype (genotype_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,genotype_id)
);
create index wwwuser_genotype_idx1 on wwwuser_genotype(wwwuser_id);
create index wwwuser_genotype_idx2 on wwwuser_genotype(genotype_id);

-- ================================================
-- TABLE: wwwuser_interaction
-- ================================================
-- track wwwuser interest in interactions

create table wwwuser_interaction (
	wwwuser_interaction_id serial not null,
	primary key (wwwuser_interaction_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	interaction_id int not null,
	foreign key (interaction_id) references interaction (interaction_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,interaction_id)
);
create index wwwuser_interaction_idx1 on wwwuser_interaction(wwwuser_id);
create index wwwuser_interaction_idx2 on wwwuser_interaction(interaction_id);

-- ================================================
-- TABLE: wwwuser_organism
-- ================================================
-- track wwwuser interest in organisms

create table wwwuser_organism (
	wwwuser_organism_id serial not null,
	primary key (wwwuser_organism_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	organism_id int not null,
	foreign key (organism_id) references organism (organism_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,organism_id)
);
create index wwwuser_organism_idx1 on wwwuser_organism(wwwuser_id);
create index wwwuser_organism_idx2 on wwwuser_organism(organism_id);

-- ================================================
-- TABLE: wwwuser_phenotype
-- ================================================
-- track wwwuser interest in phenotypes

create table wwwuser_phenotype (
	wwwuser_phenotype_id serial not null,
	primary key (wwwuser_phenotype_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	phenotype_id int not null,
	foreign key (phenotype_id) references phenotype (phenotype_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,phenotype_id)
);
create index wwwuser_phenotype_idx1 on wwwuser_phenotype(wwwuser_id);
create index wwwuser_phenotype_idx2 on wwwuser_phenotype(phenotype_id);

-- ================================================
-- TABLE: wwwuser_pub
-- ================================================
-- track wwwuser interest in publications

create table wwwuser_pub (
	wwwuser_pub_id serial not null,
	primary key (wwwuser_pub_id),
	wwwuser_id int not null,
	foreign key (wwwuser_id) references wwwuser (wwwuser_id),
	pub_id int not null,
	foreign key (pub_id) references pub (pub_id),
	world_read smallint not null default 1,
	unique(wwwuser_id,pub_id)
);
create index wwwuser_pub_idx1 on wwwuser_pub(wwwuser_id);
create index wwwuser_pub_idx2 on wwwuser_pub(pub_id);

-- ================================================
-- TABLE: wwwuserrelationship
-- ================================================
-- track wwwuser interest in other wwwusers

create table wwwuserrelationship (
	wwwuserrelationship_id serial not null,
	primary key (wwwuserrelationship_id),
	objwwwuser_id int not null,
	foreign key (objwwwuser_id) references wwwuser (wwwuser_id),
	subjwwwuser_id int not null,
	foreign key (subjwwwuser_id) references wwwuser (wwwuser_id),
	world_read smallint not null default 1,
	unique(objwwwuser_id,subjwwwuser_id)
);
create index wwwuserrelationship_idx1 on wwwuserrelationship(subjwwwuser_id);
create index wwwuserrelationship_idx2 on wwwuserrelationship(objwwwuser_id);

