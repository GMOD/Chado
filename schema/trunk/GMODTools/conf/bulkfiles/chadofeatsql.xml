<opt
  name="chadofeatsql" 
  date="20040821"
  >

  <title>FlyBase Chado DB SQL</title>
  
  <about>
    This is a collection of Chado DB SQL calls to extract
    all basic genome features, into intermediate feature_table form
    
  arm     fmin    fmax    strand  type    name    id      oid     attr_type       attribute
  2L      0       305900  1       golden_path_region      AE003590        AE003590        1273141 dbxref   Gadfly:AE003590
  2L      6364    6366    1       transcription_start_site        6365-6366-AE999999.Fake-dummy-promoter   6365-6366-AE999999.Fake-dummy-promoter  1273564         
  2L      6773    6808    1       exon            NULL:960558     1273721 parent_oid      1273720:1
  2L      6773    9276            mRNA    6773,9276-AE999999.Fake-dummy-piecegenie        NULL:9605
  
    There is a tag feature_sql, type="feature_table" for each group of
    features needing separate SQL: chromosome/super-contigs,
    gene_models, matches, analyses, syntenic features ..
    
    Logic in Bulkfiles::FeatureWriter then merges, selects/reformats
    these feature_tables and writes bulk files per chromosome.  One can
    also attach post-processing scripts (see matches below).
  </about>
  
  
  <feature_sql id="countfeats" type="list" output="chadofeats.count">
  <sql>
  -- use for overview of chado feature contents
  SELECT featcv.name, featcv.cvterm_id, count(armft.feature_id)
  FROM feature armft, cvterm featcv
  WHERE armft.type_id = featcv.cvterm_id
  GROUP by featcv.name;
  </sql>
  </feature_sql>
  
  <feature_sql id="fbids" type="list" output="chado-fb.ids">
  <sql>
    -- used for flybase to exclude cytologic features with same genome feature id
    SELECT accession FROM dbxref 
    WHERE accession like '%FBgn%' or accession like '%FBti%'
    ;
  </sql>
  </feature_sql>

<!-- ? add organism table output and use organism_id in all feature_tables ? -->
  <feature_sql id="organism" type="organism_table" output="organism.tsv">
  <sql>
  SELECT organism_id,abbreviation,genus,species,common_name,comment FROM organism;
  </sql>
  
  <script name="orgtab" type="IGNORE_postprocess" shell="perl -ni.old" language="perl">
<![CDATA[
  #? create genus_species column ?
  print unless (/Computational/i);
]]>
  </script>

  </feature_sql>

<!-- dmel r4 note: uniquename == chromosome name; name == genbank accession  -->

  <feature_sql id="chromosomes" type="feature_table" output="chromosomes.tsv">
  <sql>
<![CDATA[
-- get chromosome/arm/supercontig/... lengths/names
-- need ENV/other subsitution Variable for 'chromosome', 'chromosome_arm', 'ultra_scaffold'
-- add get-residues to file 
-- made chr == uniqname nov04; new dmel4r uses name == genbank accession
SELECT 
  -- CASE WHEN armft.name IS NULL THEN armft.uniquename ELSE armft.name END AS arm, 
  armft.uniquename as arm,
  '1' as fmin, armft.seqlen as fmax, '0' as strand,
  armft.organism_id,
  featcv.name as type,
  armft.name as name,
  armft.uniquename as id,
  armft.feature_id as oid,
  'species' as attr_type, 
  org.genus || '_' || org.species AS attribute
FROM 
  feature armft, organism org, cvterm featcv, cv socv
WHERE 
  featcv.name in ( ${golden_path} ) -- 'chromosome_arm', 'ultra_scaffold'   
  and featcv.cv_id = socv.cv_id and socv.name = 'SO'
  and armft.organism_id = org.organism_id
  and armft.type_id = featcv.cvterm_id
ORDER BY arm ;
]]>
  </sql>
    
  <script name="remapunk" type="postprocess" shell="perl -i.old" language="perl">
<![CDATA[
# remap dpse Unknown ultra_scaffold singletons and groups to one bag U chromosome
# need to impose artificial ordering; rewrite start/stop locations after sort by name
# species set in release.xml as ENV variable ; Drosophila_pseudoobscura

BEGIN { @r=(); $Uchr= "${unknown_chr}" || "U"; }  
while(<>) { 
  if (/^arm\t/) { print $_; next; } #header
  my @v= split "\t"; # [0] == arm; [-1] == species
  if ($v[-1] =~ /${species}/ && $v[0] =~ /^(Unknown\D*)(\d*)$/) { 
    my ($t,$n)= ($1,$2); $n= 0 unless($n);
    $v[0]= sprintf("$t%08d",$n);  # make sortable
    push(@r, \@v); 
    }
  else { 
    if ($v[-1] =~ /${species}/ && $v[0] =~ /group/) {
      $v[5] = 'golden_path'; 
      }
    elsif ($v[-1] =~ /${species}/) {
      $v[5] = 'chromosome_arm'; 
      }
    print join("\t",@v);
    }
 } 
END { mapunk(); }

sub mapunk {
  if (@r) {
    open(ARGVOUT, ">>$ARGV"); select(ARGVOUT); # perl closes before this
    @r= sort{ $$a[0] cmp $$b[0] } @r; # sort by arm name
    my ($cmin,$orgid, $spp)= (0,0,'unknown');
    foreach my $r (@r) {
      $$r[0] =  $Uchr; # or "U" ?
      $$r[1] += $cmin;
      $$r[2] += $cmin;
      $orgid = $$r[4];
      $spp   = $$r[-1];
      $$r[5] = 'golden_path_fragment'; # need new type for part of unknown...
      $cmin  = $$r[2];
      }
    print join("\t", $Uchr, 1, $cmin, 0, $orgid, "golden_path", 0, "species",$spp), "\n";
    foreach my $r (@r) { print join("\t",@$r); } ## put fragments at end 
    }
  @r=(); 
} 

]]>
  </script>

  </feature_sql>

  
  <feature_sql id="features" type="feature_table" output="features.tsv">
  <sql>
-- standard features (excluding matches, analyses)
SELECT  distinct
  -- CASE WHEN armft.name IS NULL THEN armft.uniquename ELSE armft.name END AS arm, 
  armft.uniquename as arm,
  armloc.fmin, armloc.fmax, armloc.strand,
  armft.organism_id,
  targcv.name as type,
  targft.name as name,
  targft.uniquename as id,
  targft.feature_id as oid,
  attr.type as attr_type, attr.attribute

FROM
  feature armft, 
  feature targft left outer join gffattr_gmodel attr
    on (targft.feature_id = attr.feature_id),
  featureloc armloc, 
  cvterm targcv

WHERE
  NOT (targcv.name in ('match', 'syntenic_region', 'orthologous_region')) --  add orthologous_region, syntenic_region
  and targft.type_id = targcv.cvterm_id 
  and armft.feature_id = armloc.srcfeature_id  
  and targft.feature_id = armloc.feature_id  
  
-- dont need ORDER clause? but see below
ORDER BY arm, armloc.fmin --, targcv.name
;

-- add this arm type restriction ?
-- , cvterm armcv, cv socv
--   and armcv.name in ( ${golden_path} )  
--   and armcv.cv_id = socv.cv_id and socv.name = 'SO'
--   and armcv.cvterm_id = armft.type_id  

  </sql>
  </feature_sql>
  
<!--
# make gnomap/synteny-idmap.tsv for gbrowse ;
# idmap for use w/ dpse gbrowse table like
# synt:id   dmel-chr  dmel-range
# ortho:id  ... use dpse synt/ortho 'name' field, not id field for now.
# lookup by FFFdb.pm is hashmap by synt:id, ortho:id ...

egrep 'to_species.3' synteny.tsv | perl -ne \
'($c,$b,$e,$t,$og,$ft,$nm,$id,$xx)=split"\t";print"$id\t$c\t$b..$e\n";' \
> dmel-synt-idmap.tsv

egrep 'to_species.1' synteny.tsv | perl -ne \
'($c,$b,$e,$t,$og,$ft,$nm,$id,$xx)=split"\t";print"$id\t$c\t$b..$e\n";' \
> dpse-synt-idmap.tsv

-->

  <feature_sql id="synteny" type="feature_table"  output="synteny.tsv">
  <sql>
  -- dpse-synteny.sql for cross-species features (syntenic_region, orthologous_region)
  -- split output by species ? 
  -- this feature_table has extra column for species,to_species, no strand
  -- need other type="synteny_table"? or  use attr: species2=Dpse  ?
  
SELECT distinct
  -- CASE WHEN armft.name IS NULL THEN armft.uniquename ELSE armft.name END AS arm, 
  armft.uniquename as arm,
  armloc.fmin, armloc.fmax, armloc.strand, 
  armft.organism_id,
  matchcv.name as type,
  matchft.name as name,
  matchft.uniquename as id,
  matchft.feature_id as oid,
  attr.type AS attr_type,
  attr.attribute AS attribute

FROM
  feature matchft, 
  feature armft,
  feature targft left outer join gffattr_synt2 attr 
    on (targft.feature_id = attr.feature_id),
  featureloc armloc, featureloc targloc,
  cvterm matchcv, cvterm armcv, cv socv

WHERE
  matchcv.name in ( 'syntenic_region', 'orthologous_region' )
  and matchcv.cvterm_id = matchft.type_id 

  and armcv.name in ( ${golden_path} ) -- 'chromosome_arm', 'ultra_scaffold' 
  and armcv.cv_id = socv.cv_id and socv.name = 'SO'
  and armcv.cvterm_id = armft.type_id  
  and armft.organism_id != targft.organism_id
    
  -- separate paired features here - keep chr-arm loc, target types/attr
  and matchft.feature_id = armloc.feature_id  
  and armft.feature_id = armloc.srcfeature_id
  and matchft.feature_id = targloc.feature_id  
  and targft.feature_id = targloc.srcfeature_id 

-- DO need ORDER clause
ORDER BY arm, armloc.fmin --, matchcv.name
;
  </sql>
  </feature_sql>



  <feature_sql id="matches" type="feature_table"  output="matches.tsv">
  <sql>
-- use this to get the paired genome/target match items w/ attr (or null) --
-- jun04 - need to filter out apollo dupl. evidence for
-- match features, type = transposable_element_insertion_site
SELECT distinct
  -- CASE WHEN armft.name IS NULL THEN armft.uniquename ELSE armft.name END AS arm, 
  armft.uniquename as arm,
  armloc.fmin, armloc.fmax, armloc.strand,
  armft.organism_id,
  targcv.name as type, 
  targft.name as name,
  targft.uniquename as id,
  targft.feature_id as oid,
  attr.type as attr_type, attr.attribute
 
FROM
  feature matchft, feature armft, 
  feature targft left outer join gffattr_match attr
     on (targft.feature_id = attr.feature_id),
  featureloc armloc, featureloc targloc,
  cvterm targcv, cvterm matchcv, cvterm armcv, cv socv
   
   -- tested speed of this w/ cv.names versus cvterm_id number inserted
   -- pg is smart enough to optimize cv name lookup once - leave as is
WHERE
  matchcv.name = 'match' 
  and matchcv.cvterm_id = matchft.type_id 
  and armcv.name in ( ${golden_path} ) -- 'chromosome', 'chromosome_arm', 'ultra_scaffold')
  and armcv.cv_id = socv.cv_id and socv.name = 'SO'
  and armcv.cvterm_id = armft.type_id  

  and targft.type_id = targcv.cvterm_id 
  and targft.feature_id != armft.feature_id  
  
  -- separate paired features here - keep chr-arm loc, target types/attr
  and matchft.feature_id = armloc.feature_id  
  and armft.feature_id = armloc.srcfeature_id
    
  and matchft.feature_id = targloc.feature_id  
  and targft.feature_id = targloc.srcfeature_id 
   
-- dont need ORDER clause?? but see below
ORDER BY arm, armloc.fmin
;
  </sql>
  </feature_sql>

  
  <feature_sql id="analysis" type="feature_table" output="analysis.tsv">
  
  <!-- ant-like ; is this usable? -->
  <target name="main" depends="query,postprocess"/> 
  <target name="query" action="sql" /> 
  <target name="postprocess" action="rdump" description="fix parents w/o featureloc from kid values" /> 

  <!--  this works: perl -i.old rdump $r/tmp/featdump/analysis.tsv -->
  <script name="rdump" type="postprocess" shell="perl -i.old" language="perl">
<![CDATA[
my ($loid); my @r=();
while(<>) { 
  if (/^arm\t/) { print $_; next; } #header
  my @v= split "\t";
  my $oid= $v[-1]; 
  rdump() if ($loid && $oid ne $loid);  
  push(@r,\@v); $loid= $oid; 
  } 
open(ARGVOUT, ">>$ARGV"); select(ARGVOUT); # perl closes before this
rdump();

# nov04 bug in logic: can have dupl., successive oids on diff chromosomes: ortho matches !
# see below reinstated ORDER clause should fix; 
## ! NO - Order is bad; the ones needing fixing lack arm,fmin

sub rdump() {
  if (@r > 1) {
    my $par= $r[0]; 
    unless ($$par[0] && $$par[1] && $$par[2]) {
      # add kid range to parent if missing (likely)
      my $kid= $r[1]; #? check that $par oid == kids parent_oid ?
      my($a,$b,$e,$st,$org)= @{$kid}[0..4];
      foreach $kid (@r[2..$#r]) {
        my ($kb,$ke)= @{$kid}[1..2]; 
        $b=$kb if ($kb<$b); 
        $e=$ke if ($ke>$e); 
        }
      @{$par}[0..4] = ($a,$b,$e,$st,$org);
      if ($$par[-2] eq 'object_oid') { pop(@$par);  $$par[-1]="\n"; }  
      $r[0]= $par;
      }
    
    foreach my $i (1..$#r) { $r[$i]->[5] =~ s/^match:/match_part:/; }
    }
  foreach my $r (@r) { print join("\t",@$r); } 
  @r=(); 
} 

]]>
  </script>
  
  <!-- want sql tag at top level of feature_sql like others -->
  <sql>
-- select all an features of right type, with arm featureloc when avail
-- add analysis.sourcename where needed (ignore 'dummy');
-- change 'match_' leading type ; drop or make option?
-- ? problem for null sourcename? got an.program = pinsertion, null source, no type output
--  WHEN an.sourcename = 'dummy' THEN 'match:' || an.program
SELECT 
  armft.arm, armft.fmin, armft.fmax, armft.strand, 
  armft.organism_id,  
  CASE  
    WHEN (an.sourcename IS NULL or an.sourcename = 'dummy') THEN 'match:' || an.program
    ELSE 'match:' || an.program || ':' || an.sourcename
  END 
  AS type, 
  targft.name AS name,  
  targft.uniquename AS id, 
  targft.feature_id AS oid,
  CASE WHEN attr.type IS NULL THEN text('object_oid')  ELSE attr.type  END 
  AS attr_type,
  CASE WHEN attr.attribute IS NULL THEN text(targft.feature_id) ELSE attr.attribute  END 
  AS attribute
FROM 
  feature targft left outer join gffatts_evid attr
    on (targft.feature_id = attr.feature_id),
  analysisfeature anf left outer join gffatts_anfloc armft
    on (anf.feature_id = armft.feature_id),
  analysis an
WHERE
  an.analysis_id = anf.analysis_id
  and anf.feature_id = targft.feature_id

-- NEED ORDER to get parent/match_part oids aligned
-- NO, cant use ORDER cause of missing arm, fmin for parent feats fixed in rdump above
-- ORDER BY armft.arm, armft.fmin
;
  </sql>
  </feature_sql>



  <feature_sql id="views" type="view">
  <sql>
-- from sequence-gff-views.sql 
-- dont need all of these attribs;
--   dbxref: yes, cvterm: no, synonym: no?, pub: no, 
--   featureprop - want some: cyto_range, gbunit?(no)
-- add dbxref_2nd, aug04 for dbxref need to know primary/secondary > feature_dbxref.is_current !

-- attr view for regular features which may have parent features (exons)
CREATE OR REPLACE VIEW gffattr_gmodel (
    feature_id, type, attribute
) AS
  SELECT feature_id,  
    CASE WHEN fs.is_current IS FALSE THEN 'dbxref_2nd' ELSE 'dbxref' END AS type, 
    d.name || ':' || s.accession AS attribute
  FROM dbxref s, feature_dbxref fs, db d
  WHERE fs.dbxref_id = s.dbxref_id and s.db_id = d.db_id

UNION ALL
  SELECT feature_id, cv.name AS type, fp.value AS attribute
  FROM featureprop fp, cvterm cv
  WHERE fp.type_id = cv.cvterm_id
    and (cv.name = 'cyto_range' or cv.name = 'gbunit')
    -- keep this restriction - other props not useful here: comments, sp_comment, owner ...

UNION ALL
  SELECT feature_id,
    CASE WHEN fs.is_current IS FALSE THEN 'synonym_2nd' ELSE 'synonym' END AS type, 
    s.synonym_sgml AS attribute
  FROM feature_synonym fs, synonym s
  WHERE fs.synonym_id = s.synonym_id and fs.is_internal IS FALSE

UNION ALL
  -- add parent feat ids for exons, etc.
  SELECT pk.subject_id AS feature_id, 'parent_oid' AS type, 
    CASE  
      WHEN pk.rank IS NULL THEN text(pk.object_id)
      ELSE pk.object_id || ':' || pk.rank
    END 
  FROM feature_relationship pk
;
GRANT SELECT ON gffattr_gmodel TO PUBLIC;

-- attr view for match features
CREATE OR REPLACE VIEW gffattr_match (
    feature_id,  type,  attribute
) AS
  SELECT feature_id,  
    CASE WHEN fs.is_current IS FALSE THEN 'dbxref_2nd' ELSE 'dbxref' END AS type, 
    d.name || ':' || s.accession AS attribute
  FROM dbxref s, feature_dbxref fs, db d
  WHERE fs.dbxref_id = s.dbxref_id and s.db_id = d.db_id

UNION ALL
  SELECT feature_id, cv.name AS type, fp.value AS attribute
  FROM featureprop fp, cvterm cv
  WHERE fp.type_id = cv.cvterm_id
    and (cv.name = 'cyto_range' or cv.name = 'gbunit')

UNION ALL
  SELECT feature_id,
    CASE WHEN fs.is_current IS FALSE THEN 'synonym_2nd' ELSE 'synonym' END AS type, 
    s.synonym_sgml AS attribute
  FROM feature_synonym fs, synonym s
  WHERE fs.synonym_id = s.synonym_id and fs.is_internal IS FALSE
;
GRANT SELECT ON gffattr_match TO PUBLIC;

-- attrib view for cross-species feats (syntenic_region, orthology)
CREATE OR REPLACE VIEW gffattr_synteny (
    feature_id, type,  attribute
) AS
  --  parent feat ids for source supercontigs, etc.
  SELECT pk.subject_id, text('parent_oid') as type, 
    CASE  
      WHEN pk.rank IS NULL THEN text(pk.object_id)
      ELSE pk.object_id || ':' || pk.rank
    END 
  FROM feature_relationship pk
;
GRANT SELECT ON gffattr_synteny TO PUBLIC;

-- use this one instead of above
CREATE OR REPLACE VIEW gffattr_synt2 (
    feature_id,  type,  attribute
) AS
  SELECT feature_id, text('to_species') AS type, text(targ.organism_id) AS attribute
  FROM feature targ

UNION ALL
  SELECT feature_id, text('to_name') AS type, targ.name AS attribute
  FROM feature targ
  WHERE NOT( targ.type_id IN (
    select cvterm_id from cvterm 
    where name in ( ${golden_path} ) -- ('chromosome_arm', 'ultra_scaffold')
    ) )
;
GRANT SELECT ON gffattr_synt2 TO PUBLIC;


-- for analysis features
-- problem where w/ some analysis features - promotor, transposon
-- ? need to restrict armcv to cv_id = SO id - e.g. find chromosome in 4 cv's
CREATE OR REPLACE VIEW gffatts_anfloc (
    feature_id, arm, fmin, fmax, strand, organism_id
  ) AS
  SELECT 
    armloc.feature_id,  
    -- CASE WHEN armft.name IS NULL THEN armft.uniquename ELSE armft.name END AS arm,
    armft.uniquename as arm,
    armloc.fmin, armloc.fmax, armloc.strand, armft.organism_id
  FROM  feature armft, featureloc armloc, cvterm armcv, cv socv
  WHERE 
    armft.type_id = armcv.cvterm_id
    and armcv.name in ( ${golden_path} ) -- ('chromosome_arm', 'ultra_scaffold')
    and armcv.cv_id = socv.cv_id and socv.name = 'SO'
    and armft.feature_id = armloc.srcfeature_id
;
GRANT SELECT ON gffatts_anfloc TO PUBLIC;

-- for analysis features
CREATE OR REPLACE VIEW gffatts_evid (
    feature_id, type, attribute
) AS
  SELECT pk.subject_id, text('parent_oid'), text(pk.object_id)
  FROM feature_relationship pk
;
GRANT SELECT ON gffatts_evid TO PUBLIC;

  </sql>
  </feature_sql>
</opt>
