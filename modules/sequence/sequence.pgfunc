--- ===========================
--- store_feature (accession)
--- Returns: feature_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: accession
CREATE FUNCTION store_feature (varchar) RETURNS int AS '
  DECLARE
    paccession           ALIAS FOR $1;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid feature_id
      FROM feature
      WHERE feature.accession = paccession;
    IF NOT FOUND THEN
      INSERT INTO feature 
       (accession)
         VALUES
       (paccession);
      RETURN currval(''feature_pk_seq'');
    END IF;
    UPDATE feature
      SET
         
      WHERE
         feature.accession = paccession

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_feature (accession)

--- ===========================
--- store_feature (name, accession, fmin, fmax, fstrand, residues, seqlen, md5checksum, type_id)
--- Returns: feature_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: name, accession, fmin, fmax, fstrand, residues, seqlen, md5checksum, type_id
CREATE FUNCTION store_feature (varchar, varchar, INTEGER, INTEGER, INTEGER, TEXT, INTEGER, char, INTEGER) RETURNS int AS '
  DECLARE
    pname                ALIAS FOR $1;
    paccession           ALIAS FOR $2;
    pfmin                ALIAS FOR $3;
    pfmax                ALIAS FOR $4;
    pfstrand             ALIAS FOR $5;
    presidues            ALIAS FOR $6;
    pseqlen              ALIAS FOR $7;
    pmd5checksum         ALIAS FOR $8;
    ptype_id             ALIAS FOR $9;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid feature_id
      FROM feature
      WHERE feature.name = pname AND
            feature.accession = paccession AND
            feature.fmin = pfmin AND
            feature.fmax = pfmax AND
            feature.fstrand = pfstrand AND
            feature.residues = presidues AND
            feature.seqlen = pseqlen AND
            feature.md5checksum = pmd5checksum AND
            feature.type_id = ptype_id;
    IF NOT FOUND THEN
      INSERT INTO feature 
       (name, accession, fmin, fmax, fstrand, residues, seqlen, md5checksum, type_id)
         VALUES
       (pname, paccession, pfmin, pfmax, pfstrand, presidues, pseqlen, pmd5checksum, ptype_id);
      RETURN currval(''feature_pk_seq'');
    END IF;
    UPDATE feature
      SET
         
      WHERE
         feature.name = pname AND
            feature.accession = paccession AND
            feature.fmin = pfmin AND
            feature.fmax = pfmax AND
            feature.fstrand = pfstrand AND
            feature.residues = presidues AND
            feature.seqlen = pseqlen AND
            feature.md5checksum = pmd5checksum AND
            feature.type_id = ptype_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_feature (name, accession, fmin, fmax, fstrand, residues, seqlen, md5checksum, type_id)

--- ===========================
--- store_featureprop (feature_id, pkey_id, pval, prank)
--- Returns: featureprop_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: feature_id, pkey_id, pval, prank
CREATE FUNCTION store_featureprop (INTEGER, INTEGER, TEXT, INTEGER) RETURNS int AS '
  DECLARE
    pfeature_id          ALIAS FOR $1;
    ppkey_id             ALIAS FOR $2;
    ppval                ALIAS FOR $3;
    pprank               ALIAS FOR $4;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid featureprop_id
      FROM featureprop
      WHERE featureprop.feature_id = pfeature_id AND
            featureprop.pkey_id = ppkey_id AND
            featureprop.pval = ppval AND
            featureprop.prank = pprank;
    IF NOT FOUND THEN
      INSERT INTO featureprop 
       (feature_id, pkey_id, pval, prank)
         VALUES
       (pfeature_id, ppkey_id, ppval, pprank);
      RETURN currval(''featureprop_pk_seq'');
    END IF;
    UPDATE featureprop
      SET
         
      WHERE
         featureprop.feature_id = pfeature_id AND
            featureprop.pkey_id = ppkey_id AND
            featureprop.pval = ppval AND
            featureprop.prank = pprank

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_featureprop (feature_id, pkey_id, pval, prank)

--- ===========================
--- store_featureprop_pub (featureprop_id, pub_id)
--- Returns: 0 (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: featureprop_id, pub_id
CREATE FUNCTION store_featureprop_pub (INTEGER, INTEGER) RETURNS int AS '
  DECLARE
    pfeatureprop_id      ALIAS FOR $1;
    ppub_id              ALIAS FOR $2;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid 0
      FROM featureprop_pub
      WHERE featureprop_pub.featureprop_id = pfeatureprop_id AND
            featureprop_pub.pub_id = ppub_id;
    IF NOT FOUND THEN
      INSERT INTO featureprop_pub 
       (featureprop_id, pub_id)
         VALUES
       (pfeatureprop_id, ppub_id);
      RETURN currval(''0'');
    END IF;
    UPDATE featureprop_pub
      SET
         
      WHERE
         featureprop_pub.featureprop_id = pfeatureprop_id AND
            featureprop_pub.pub_id = ppub_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_featureprop_pub (featureprop_id, pub_id)

--- ===========================
--- store_feature_dbxref (dbxref_id)
--- Returns: feature_dbxref_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: feature_dbxref_id, dbxref_id
CREATE FUNCTION store_feature_dbxref (INTEGER) RETURNS int AS '
  DECLARE
    pdbxref_id           ALIAS FOR $1;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid feature_dbxref_id
      FROM feature_dbxref
      WHERE feature_dbxref.feature_dbxref_id = pfeature_dbxref_id AND
            feature_dbxref.dbxref_id = pdbxref_id;
    IF NOT FOUND THEN
      INSERT INTO feature_dbxref 
       (dbxref_id)
         VALUES
       (pdbxref_id);
      RETURN currval(''feature_dbxref_pk_seq'');
    END IF;
    UPDATE feature_dbxref
      SET
         
      WHERE
         feature_dbxref.feature_dbxref_id = pfeature_dbxref_id AND
            feature_dbxref.dbxref_id = pdbxref_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_feature_dbxref (dbxref_id)

--- ===========================
--- store_feature_relationship (subj_feature_id, obj_feature_id, type_id)
--- Returns: feature_relationship_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: subj_feature_id, obj_feature_id, type_id
CREATE FUNCTION store_feature_relationship (INTEGER, INTEGER, INTEGER) RETURNS int AS '
  DECLARE
    psubj_feature_id     ALIAS FOR $1;
    pobj_feature_id      ALIAS FOR $2;
    ptype_id             ALIAS FOR $3;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid feature_relationship_id
      FROM feature_relationship
      WHERE feature_relationship.subj_feature_id = psubj_feature_id AND
            feature_relationship.obj_feature_id = pobj_feature_id AND
            feature_relationship.type_id = ptype_id;
    IF NOT FOUND THEN
      INSERT INTO feature_relationship 
       (subj_feature_id, obj_feature_id, type_id)
         VALUES
       (psubj_feature_id, pobj_feature_id, ptype_id);
      RETURN currval(''feature_relationship_pk_seq'');
    END IF;
    UPDATE feature_relationship
      SET
         
      WHERE
         feature_relationship.subj_feature_id = psubj_feature_id AND
            feature_relationship.obj_feature_id = pobj_feature_id AND
            feature_relationship.type_id = ptype_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_feature_relationship (subj_feature_id, obj_feature_id, type_id)

--- ===========================
--- store_feature_cvterm (feature_id, cvterm_id, pub_id)
--- Returns: feature_cvterm_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: feature_id, cvterm_id, pub_id
CREATE FUNCTION store_feature_cvterm (INTEGER, INTEGER, INTEGER) RETURNS int AS '
  DECLARE
    pfeature_id          ALIAS FOR $1;
    pcvterm_id           ALIAS FOR $2;
    ppub_id              ALIAS FOR $3;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid feature_cvterm_id
      FROM feature_cvterm
      WHERE feature_cvterm.feature_id = pfeature_id AND
            feature_cvterm.cvterm_id = pcvterm_id AND
            feature_cvterm.pub_id = ppub_id;
    IF NOT FOUND THEN
      INSERT INTO feature_cvterm 
       (feature_id, cvterm_id, pub_id)
         VALUES
       (pfeature_id, pcvterm_id, ppub_id);
      RETURN currval(''feature_cvterm_pk_seq'');
    END IF;
    UPDATE feature_cvterm
      SET
         
      WHERE
         feature_cvterm.feature_id = pfeature_id AND
            feature_cvterm.cvterm_id = pcvterm_id AND
            feature_cvterm.pub_id = ppub_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_feature_cvterm (feature_id, cvterm_id, pub_id)

--- ===========================
--- store_gene (name)
--- Returns: gene_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: name
CREATE FUNCTION store_gene (varchar) RETURNS int AS '
  DECLARE
    pname                ALIAS FOR $1;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid gene_id
      FROM gene
      WHERE gene.name = pname;
    IF NOT FOUND THEN
      INSERT INTO gene 
       (name)
         VALUES
       (pname);
      RETURN currval(''gene_pk_seq'');
    END IF;
    UPDATE gene
      SET
         
      WHERE
         gene.name = pname

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_gene (name)

--- ===========================
--- store_gene (accession)
--- Returns: gene_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: accession
CREATE FUNCTION store_gene (varchar) RETURNS int AS '
  DECLARE
    paccession           ALIAS FOR $1;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid gene_id
      FROM gene
      WHERE gene.accession = paccession;
    IF NOT FOUND THEN
      INSERT INTO gene 
       (accession)
         VALUES
       (paccession);
      RETURN currval(''gene_pk_seq'');
    END IF;
    UPDATE gene
      SET
         
      WHERE
         gene.accession = paccession

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_gene (accession)

--- ===========================
--- store_genesynonym (gsynonym)
--- Returns: genesynonym_id (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: gsynonym
CREATE FUNCTION store_genesynonym (varchar) RETURNS int AS '
  DECLARE
    pgsynonym            ALIAS FOR $1;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid genesynonym_id
      FROM genesynonym
      WHERE genesynonym.gsynonym = pgsynonym;
    IF NOT FOUND THEN
      INSERT INTO genesynonym 
       (gsynonym)
         VALUES
       (pgsynonym);
      RETURN currval(''genesynonym_pk_seq'');
    END IF;
    UPDATE genesynonym
      SET
         
      WHERE
         genesynonym.gsynonym = pgsynonym

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_genesynonym (gsynonym)

--- ===========================
--- store_gene_genesynonym (genesynonym_id, gene_id, pub_id)
--- Returns: 0 (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: genesynonym_id, gene_id, pub_id
CREATE FUNCTION store_gene_genesynonym (INTEGER, INTEGER, INTEGER) RETURNS int AS '
  DECLARE
    pgenesynonym_id      ALIAS FOR $1;
    pgene_id             ALIAS FOR $2;
    ppub_id              ALIAS FOR $3;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid 0
      FROM gene_genesynonym
      WHERE gene_genesynonym.genesynonym_id = pgenesynonym_id AND
            gene_genesynonym.gene_id = pgene_id AND
            gene_genesynonym.pub_id = ppub_id;
    IF NOT FOUND THEN
      INSERT INTO gene_genesynonym 
       (genesynonym_id, gene_id, pub_id)
         VALUES
       (pgenesynonym_id, pgene_id, ppub_id);
      RETURN currval(''0'');
    END IF;
    UPDATE gene_genesynonym
      SET
         
      WHERE
         gene_genesynonym.genesynonym_id = pgenesynonym_id AND
            gene_genesynonym.gene_id = pgene_id AND
            gene_genesynonym.pub_id = ppub_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_gene_genesynonym (genesynonym_id, gene_id, pub_id)

--- ===========================
--- store_gene_feature (gene_id, feature_id)
--- Returns: 0 (primary key)
---
--- <autogenerated function>
--- stores (updates or inserts)
--- based on unique columns: gene_id, feature_id
CREATE FUNCTION store_gene_feature (INTEGER, INTEGER) RETURNS int AS '
  DECLARE
    pgene_id             ALIAS FOR $1;
    pfeature_id          ALIAS FOR $2;

    pkeyid INTEGER;
  BEGIN
    SELECT INTO pkeyid 0
      FROM gene_feature
      WHERE gene_feature.gene_id = pgene_id AND
            gene_feature.feature_id = pfeature_id;
    IF NOT FOUND THEN
      INSERT INTO gene_feature 
       (gene_id, feature_id)
         VALUES
       (pgene_id, pfeature_id);
      RETURN currval(''0'');
    END IF;
    UPDATE gene_feature
      SET
         
      WHERE
         gene_feature.gene_id = pgene_id AND
            gene_feature.feature_id = pfeature_id

    RETURN pkeyid;
  END;
' LANGUAGE 'plpgsql';
--- end of function store_gene_feature (gene_id, feature_id)

